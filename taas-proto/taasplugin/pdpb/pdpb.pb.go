// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: pdpb.proto

package pdpb

import (
	"context"
	encoding_binary "encoding/binary"
	"fmt"
	"io"
	"math"
	math_bits "math/bits"

	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/golang/protobuf/proto"
	eraftpb "github.com/pingcap/kvproto/pkg/eraftpb"
	metapb "github.com/pingcap/kvproto/pkg/metapb"
	raft_serverpb "github.com/pingcap/kvproto/pkg/raft_serverpb"
	replication_modepb "github.com/pingcap/kvproto/pkg/replication_modepb"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package

type EventType int32

const (
	EventType_PUT    EventType = 0
	EventType_DELETE EventType = 1
)

var EventType_name = map[int32]string{
	0: "PUT",
	1: "DELETE",
}

var EventType_value = map[string]int32{
	"PUT":    0,
	"DELETE": 1,
}

func (x EventType) String() string {
	return proto.EnumName(EventType_name, int32(x))
}

func (EventType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_78b27e6f04f44c6e, []int{0}
}

type ErrorType int32

const (
	ErrorType_OK                      ErrorType = 0
	ErrorType_UNKNOWN                 ErrorType = 1
	ErrorType_NOT_BOOTSTRAPPED        ErrorType = 2
	ErrorType_STORE_TOMBSTONE         ErrorType = 3
	ErrorType_ALREADY_BOOTSTRAPPED    ErrorType = 4
	ErrorType_INCOMPATIBLE_VERSION    ErrorType = 5
	ErrorType_REGION_NOT_FOUND        ErrorType = 6
	ErrorType_GLOBAL_CONFIG_NOT_FOUND ErrorType = 7
	ErrorType_DUPLICATED_ENTRY        ErrorType = 8
	ErrorType_ENTRY_NOT_FOUND         ErrorType = 9
	ErrorType_INVALID_VALUE           ErrorType = 10
	// required watch revision is smaller than current compact/min revision.
	ErrorType_DATA_COMPACTED ErrorType = 11
)

var ErrorType_name = map[int32]string{
	0:  "OK",
	1:  "UNKNOWN",
	2:  "NOT_BOOTSTRAPPED",
	3:  "STORE_TOMBSTONE",
	4:  "ALREADY_BOOTSTRAPPED",
	5:  "INCOMPATIBLE_VERSION",
	6:  "REGION_NOT_FOUND",
	7:  "GLOBAL_CONFIG_NOT_FOUND",
	8:  "DUPLICATED_ENTRY",
	9:  "ENTRY_NOT_FOUND",
	10: "INVALID_VALUE",
	11: "DATA_COMPACTED",
}

var ErrorType_value = map[string]int32{
	"OK":                      0,
	"UNKNOWN":                 1,
	"NOT_BOOTSTRAPPED":        2,
	"STORE_TOMBSTONE":         3,
	"ALREADY_BOOTSTRAPPED":    4,
	"INCOMPATIBLE_VERSION":    5,
	"REGION_NOT_FOUND":        6,
	"GLOBAL_CONFIG_NOT_FOUND": 7,
	"DUPLICATED_ENTRY":        8,
	"ENTRY_NOT_FOUND":         9,
	"INVALID_VALUE":           10,
	"DATA_COMPACTED":          11,
}

func (x ErrorType) String() string {
	return proto.EnumName(ErrorType_name, int32(x))
}

func (ErrorType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_78b27e6f04f44c6e, []int{1}
}

type ServiceMode int32

const (
	ServiceMode_UNKNOWN_SVC_MODE ServiceMode = 0
	ServiceMode_PD_SVC_MODE      ServiceMode = 1
	ServiceMode_API_SVC_MODE     ServiceMode = 2
)

var ServiceMode_name = map[int32]string{
	0: "UNKNOWN_SVC_MODE",
	1: "PD_SVC_MODE",
	2: "API_SVC_MODE",
}

var ServiceMode_value = map[string]int32{
	"UNKNOWN_SVC_MODE": 0,
	"PD_SVC_MODE":      1,
	"API_SVC_MODE":     2,
}

func (x ServiceMode) String() string {
	return proto.EnumName(ServiceMode_name, int32(x))
}

func (ServiceMode) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_78b27e6f04f44c6e, []int{2}
}

type CheckPolicy int32

const (
	CheckPolicy_SCAN        CheckPolicy = 0
	CheckPolicy_APPROXIMATE CheckPolicy = 1
	CheckPolicy_USEKEY      CheckPolicy = 2
)

var CheckPolicy_name = map[int32]string{
	0: "SCAN",
	1: "APPROXIMATE",
	2: "USEKEY",
}

var CheckPolicy_value = map[string]int32{
	"SCAN":        0,
	"APPROXIMATE": 1,
	"USEKEY":      2,
}

func (x CheckPolicy) String() string {
	return proto.EnumName(CheckPolicy_name, int32(x))
}

func (CheckPolicy) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_78b27e6f04f44c6e, []int{3}
}

type OperatorStatus int32

const (
	OperatorStatus_SUCCESS OperatorStatus = 0
	OperatorStatus_TIMEOUT OperatorStatus = 1
	OperatorStatus_CANCEL  OperatorStatus = 2
	OperatorStatus_REPLACE OperatorStatus = 3
	OperatorStatus_RUNNING OperatorStatus = 4
)

var OperatorStatus_name = map[int32]string{
	0: "SUCCESS",
	1: "TIMEOUT",
	2: "CANCEL",
	3: "REPLACE",
	4: "RUNNING",
}

var OperatorStatus_value = map[string]int32{
	"SUCCESS": 0,
	"TIMEOUT": 1,
	"CANCEL":  2,
	"REPLACE": 3,
	"RUNNING": 4,
}

func (x OperatorStatus) String() string {
	return proto.EnumName(OperatorStatus_name, int32(x))
}

func (OperatorStatus) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_78b27e6f04f44c6e, []int{4}
}

type QueryKind int32

const (
	QueryKind_Others                 QueryKind = 0
	QueryKind_GC                     QueryKind = 1
	QueryKind_Get                    QueryKind = 2
	QueryKind_Scan                   QueryKind = 3
	QueryKind_Coprocessor            QueryKind = 4
	QueryKind_Delete                 QueryKind = 5
	QueryKind_DeleteRange            QueryKind = 6
	QueryKind_Put                    QueryKind = 7
	QueryKind_Prewrite               QueryKind = 8
	QueryKind_AcquirePessimisticLock QueryKind = 9
	QueryKind_Commit                 QueryKind = 10
	QueryKind_Rollback               QueryKind = 11
)

var QueryKind_name = map[int32]string{
	0:  "Others",
	1:  "GC",
	2:  "Get",
	3:  "Scan",
	4:  "Coprocessor",
	5:  "Delete",
	6:  "DeleteRange",
	7:  "Put",
	8:  "Prewrite",
	9:  "AcquirePessimisticLock",
	10: "Commit",
	11: "Rollback",
}

var QueryKind_value = map[string]int32{
	"Others":                 0,
	"GC":                     1,
	"Get":                    2,
	"Scan":                   3,
	"Coprocessor":            4,
	"Delete":                 5,
	"DeleteRange":            6,
	"Put":                    7,
	"Prewrite":               8,
	"AcquirePessimisticLock": 9,
	"Commit":                 10,
	"Rollback":               11,
}

func (x QueryKind) String() string {
	return proto.EnumName(QueryKind_name, int32(x))
}

func (QueryKind) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_78b27e6f04f44c6e, []int{5}
}

type WatchGlobalConfigRequest struct {
	ConfigPath           string   `protobuf:"bytes,1,opt,name=config_path,json=configPath,proto3" json:"config_path,omitempty"`
	Revision             int64    `protobuf:"varint,2,opt,name=revision,proto3" json:"revision,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *WatchGlobalConfigRequest) Reset()         { *m = WatchGlobalConfigRequest{} }
func (m *WatchGlobalConfigRequest) String() string { return proto.CompactTextString(m) }
func (*WatchGlobalConfigRequest) ProtoMessage()    {}
func (*WatchGlobalConfigRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_78b27e6f04f44c6e, []int{0}
}
func (m *WatchGlobalConfigRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *WatchGlobalConfigRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_WatchGlobalConfigRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *WatchGlobalConfigRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_WatchGlobalConfigRequest.Merge(m, src)
}
func (m *WatchGlobalConfigRequest) XXX_Size() int {
	return m.Size()
}
func (m *WatchGlobalConfigRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_WatchGlobalConfigRequest.DiscardUnknown(m)
}

var xxx_messageInfo_WatchGlobalConfigRequest proto.InternalMessageInfo

func (m *WatchGlobalConfigRequest) GetConfigPath() string {
	if m != nil {
		return m.ConfigPath
	}
	return ""
}

func (m *WatchGlobalConfigRequest) GetRevision() int64 {
	if m != nil {
		return m.Revision
	}
	return 0
}

type WatchGlobalConfigResponse struct {
	Changes              []*GlobalConfigItem `protobuf:"bytes,1,rep,name=changes,proto3" json:"changes,omitempty"`
	Revision             int64               `protobuf:"varint,2,opt,name=revision,proto3" json:"revision,omitempty"`
	Header               *ResponseHeader     `protobuf:"bytes,3,opt,name=header,proto3" json:"header,omitempty"`
	XXX_NoUnkeyedLiteral struct{}            `json:"-"`
	XXX_unrecognized     []byte              `json:"-"`
	XXX_sizecache        int32               `json:"-"`
}

func (m *WatchGlobalConfigResponse) Reset()         { *m = WatchGlobalConfigResponse{} }
func (m *WatchGlobalConfigResponse) String() string { return proto.CompactTextString(m) }
func (*WatchGlobalConfigResponse) ProtoMessage()    {}
func (*WatchGlobalConfigResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_78b27e6f04f44c6e, []int{1}
}
func (m *WatchGlobalConfigResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *WatchGlobalConfigResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_WatchGlobalConfigResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *WatchGlobalConfigResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_WatchGlobalConfigResponse.Merge(m, src)
}
func (m *WatchGlobalConfigResponse) XXX_Size() int {
	return m.Size()
}
func (m *WatchGlobalConfigResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_WatchGlobalConfigResponse.DiscardUnknown(m)
}

var xxx_messageInfo_WatchGlobalConfigResponse proto.InternalMessageInfo

func (m *WatchGlobalConfigResponse) GetChanges() []*GlobalConfigItem {
	if m != nil {
		return m.Changes
	}
	return nil
}

func (m *WatchGlobalConfigResponse) GetRevision() int64 {
	if m != nil {
		return m.Revision
	}
	return 0
}

func (m *WatchGlobalConfigResponse) GetHeader() *ResponseHeader {
	if m != nil {
		return m.Header
	}
	return nil
}

type StoreGlobalConfigRequest struct {
	Changes              []*GlobalConfigItem `protobuf:"bytes,1,rep,name=changes,proto3" json:"changes,omitempty"`
	ConfigPath           string              `protobuf:"bytes,2,opt,name=config_path,json=configPath,proto3" json:"config_path,omitempty"`
	XXX_NoUnkeyedLiteral struct{}            `json:"-"`
	XXX_unrecognized     []byte              `json:"-"`
	XXX_sizecache        int32               `json:"-"`
}

func (m *StoreGlobalConfigRequest) Reset()         { *m = StoreGlobalConfigRequest{} }
func (m *StoreGlobalConfigRequest) String() string { return proto.CompactTextString(m) }
func (*StoreGlobalConfigRequest) ProtoMessage()    {}
func (*StoreGlobalConfigRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_78b27e6f04f44c6e, []int{2}
}
func (m *StoreGlobalConfigRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *StoreGlobalConfigRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_StoreGlobalConfigRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *StoreGlobalConfigRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StoreGlobalConfigRequest.Merge(m, src)
}
func (m *StoreGlobalConfigRequest) XXX_Size() int {
	return m.Size()
}
func (m *StoreGlobalConfigRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_StoreGlobalConfigRequest.DiscardUnknown(m)
}

var xxx_messageInfo_StoreGlobalConfigRequest proto.InternalMessageInfo

func (m *StoreGlobalConfigRequest) GetChanges() []*GlobalConfigItem {
	if m != nil {
		return m.Changes
	}
	return nil
}

func (m *StoreGlobalConfigRequest) GetConfigPath() string {
	if m != nil {
		return m.ConfigPath
	}
	return ""
}

type StoreGlobalConfigResponse struct {
	Error                *Error   `protobuf:"bytes,1,opt,name=error,proto3" json:"error,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *StoreGlobalConfigResponse) Reset()         { *m = StoreGlobalConfigResponse{} }
func (m *StoreGlobalConfigResponse) String() string { return proto.CompactTextString(m) }
func (*StoreGlobalConfigResponse) ProtoMessage()    {}
func (*StoreGlobalConfigResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_78b27e6f04f44c6e, []int{3}
}
func (m *StoreGlobalConfigResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *StoreGlobalConfigResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_StoreGlobalConfigResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *StoreGlobalConfigResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StoreGlobalConfigResponse.Merge(m, src)
}
func (m *StoreGlobalConfigResponse) XXX_Size() int {
	return m.Size()
}
func (m *StoreGlobalConfigResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_StoreGlobalConfigResponse.DiscardUnknown(m)
}

var xxx_messageInfo_StoreGlobalConfigResponse proto.InternalMessageInfo

func (m *StoreGlobalConfigResponse) GetError() *Error {
	if m != nil {
		return m.Error
	}
	return nil
}

type LoadGlobalConfigRequest struct {
	Names                []string `protobuf:"bytes,1,rep,name=names,proto3" json:"names,omitempty"`
	ConfigPath           string   `protobuf:"bytes,2,opt,name=config_path,json=configPath,proto3" json:"config_path,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *LoadGlobalConfigRequest) Reset()         { *m = LoadGlobalConfigRequest{} }
func (m *LoadGlobalConfigRequest) String() string { return proto.CompactTextString(m) }
func (*LoadGlobalConfigRequest) ProtoMessage()    {}
func (*LoadGlobalConfigRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_78b27e6f04f44c6e, []int{4}
}
func (m *LoadGlobalConfigRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LoadGlobalConfigRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LoadGlobalConfigRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LoadGlobalConfigRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LoadGlobalConfigRequest.Merge(m, src)
}
func (m *LoadGlobalConfigRequest) XXX_Size() int {
	return m.Size()
}
func (m *LoadGlobalConfigRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_LoadGlobalConfigRequest.DiscardUnknown(m)
}

var xxx_messageInfo_LoadGlobalConfigRequest proto.InternalMessageInfo

func (m *LoadGlobalConfigRequest) GetNames() []string {
	if m != nil {
		return m.Names
	}
	return nil
}

func (m *LoadGlobalConfigRequest) GetConfigPath() string {
	if m != nil {
		return m.ConfigPath
	}
	return ""
}

type LoadGlobalConfigResponse struct {
	Items                []*GlobalConfigItem `protobuf:"bytes,1,rep,name=items,proto3" json:"items,omitempty"`
	Revision             int64               `protobuf:"varint,2,opt,name=revision,proto3" json:"revision,omitempty"`
	XXX_NoUnkeyedLiteral struct{}            `json:"-"`
	XXX_unrecognized     []byte              `json:"-"`
	XXX_sizecache        int32               `json:"-"`
}

func (m *LoadGlobalConfigResponse) Reset()         { *m = LoadGlobalConfigResponse{} }
func (m *LoadGlobalConfigResponse) String() string { return proto.CompactTextString(m) }
func (*LoadGlobalConfigResponse) ProtoMessage()    {}
func (*LoadGlobalConfigResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_78b27e6f04f44c6e, []int{5}
}
func (m *LoadGlobalConfigResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LoadGlobalConfigResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LoadGlobalConfigResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LoadGlobalConfigResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LoadGlobalConfigResponse.Merge(m, src)
}
func (m *LoadGlobalConfigResponse) XXX_Size() int {
	return m.Size()
}
func (m *LoadGlobalConfigResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_LoadGlobalConfigResponse.DiscardUnknown(m)
}

var xxx_messageInfo_LoadGlobalConfigResponse proto.InternalMessageInfo

func (m *LoadGlobalConfigResponse) GetItems() []*GlobalConfigItem {
	if m != nil {
		return m.Items
	}
	return nil
}

func (m *LoadGlobalConfigResponse) GetRevision() int64 {
	if m != nil {
		return m.Revision
	}
	return 0
}

type GlobalConfigItem struct {
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// this field 'value' is replaced by the field 'payload'.
	Value string    `protobuf:"bytes,2,opt,name=value,proto3" json:"value,omitempty"`
	Error *Error    `protobuf:"bytes,3,opt,name=error,proto3" json:"error,omitempty"`
	Kind  EventType `protobuf:"varint,4,opt,name=kind,proto3,enum=pdpb.EventType" json:"kind,omitempty"`
	// Since item value needs to support marshal of different struct types,
	// it should be set to bytes instead of string.
	Payload              []byte   `protobuf:"bytes,5,opt,name=payload,proto3" json:"payload,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *GlobalConfigItem) Reset()         { *m = GlobalConfigItem{} }
func (m *GlobalConfigItem) String() string { return proto.CompactTextString(m) }
func (*GlobalConfigItem) ProtoMessage()    {}
func (*GlobalConfigItem) Descriptor() ([]byte, []int) {
	return fileDescriptor_78b27e6f04f44c6e, []int{6}
}
func (m *GlobalConfigItem) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GlobalConfigItem) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GlobalConfigItem.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GlobalConfigItem) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GlobalConfigItem.Merge(m, src)
}
func (m *GlobalConfigItem) XXX_Size() int {
	return m.Size()
}
func (m *GlobalConfigItem) XXX_DiscardUnknown() {
	xxx_messageInfo_GlobalConfigItem.DiscardUnknown(m)
}

var xxx_messageInfo_GlobalConfigItem proto.InternalMessageInfo

func (m *GlobalConfigItem) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *GlobalConfigItem) GetValue() string {
	if m != nil {
		return m.Value
	}
	return ""
}

func (m *GlobalConfigItem) GetError() *Error {
	if m != nil {
		return m.Error
	}
	return nil
}

func (m *GlobalConfigItem) GetKind() EventType {
	if m != nil {
		return m.Kind
	}
	return EventType_PUT
}

func (m *GlobalConfigItem) GetPayload() []byte {
	if m != nil {
		return m.Payload
	}
	return nil
}

type RequestHeader struct {
	// cluster_id is the ID of the cluster which be sent to.
	ClusterId uint64 `protobuf:"varint,1,opt,name=cluster_id,json=clusterId,proto3" json:"cluster_id,omitempty"`
	// sender_id is the ID of the sender server, also member ID or etcd ID.
	SenderId             uint64   `protobuf:"varint,2,opt,name=sender_id,json=senderId,proto3" json:"sender_id,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *RequestHeader) Reset()         { *m = RequestHeader{} }
func (m *RequestHeader) String() string { return proto.CompactTextString(m) }
func (*RequestHeader) ProtoMessage()    {}
func (*RequestHeader) Descriptor() ([]byte, []int) {
	return fileDescriptor_78b27e6f04f44c6e, []int{7}
}
func (m *RequestHeader) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RequestHeader) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RequestHeader.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RequestHeader) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RequestHeader.Merge(m, src)
}
func (m *RequestHeader) XXX_Size() int {
	return m.Size()
}
func (m *RequestHeader) XXX_DiscardUnknown() {
	xxx_messageInfo_RequestHeader.DiscardUnknown(m)
}

var xxx_messageInfo_RequestHeader proto.InternalMessageInfo

func (m *RequestHeader) GetClusterId() uint64 {
	if m != nil {
		return m.ClusterId
	}
	return 0
}

func (m *RequestHeader) GetSenderId() uint64 {
	if m != nil {
		return m.SenderId
	}
	return 0
}

type ResponseHeader struct {
	// cluster_id is the ID of the cluster which sent the response.
	ClusterId            uint64   `protobuf:"varint,1,opt,name=cluster_id,json=clusterId,proto3" json:"cluster_id,omitempty"`
	Error                *Error   `protobuf:"bytes,2,opt,name=error,proto3" json:"error,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ResponseHeader) Reset()         { *m = ResponseHeader{} }
func (m *ResponseHeader) String() string { return proto.CompactTextString(m) }
func (*ResponseHeader) ProtoMessage()    {}
func (*ResponseHeader) Descriptor() ([]byte, []int) {
	return fileDescriptor_78b27e6f04f44c6e, []int{8}
}
func (m *ResponseHeader) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ResponseHeader) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ResponseHeader.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ResponseHeader) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ResponseHeader.Merge(m, src)
}
func (m *ResponseHeader) XXX_Size() int {
	return m.Size()
}
func (m *ResponseHeader) XXX_DiscardUnknown() {
	xxx_messageInfo_ResponseHeader.DiscardUnknown(m)
}

var xxx_messageInfo_ResponseHeader proto.InternalMessageInfo

func (m *ResponseHeader) GetClusterId() uint64 {
	if m != nil {
		return m.ClusterId
	}
	return 0
}

func (m *ResponseHeader) GetError() *Error {
	if m != nil {
		return m.Error
	}
	return nil
}

type Error struct {
	Type                 ErrorType `protobuf:"varint,1,opt,name=type,proto3,enum=pdpb.ErrorType" json:"type,omitempty"`
	Message              string    `protobuf:"bytes,2,opt,name=message,proto3" json:"message,omitempty"`
	XXX_NoUnkeyedLiteral struct{}  `json:"-"`
	XXX_unrecognized     []byte    `json:"-"`
	XXX_sizecache        int32     `json:"-"`
}

func (m *Error) Reset()         { *m = Error{} }
func (m *Error) String() string { return proto.CompactTextString(m) }
func (*Error) ProtoMessage()    {}
func (*Error) Descriptor() ([]byte, []int) {
	return fileDescriptor_78b27e6f04f44c6e, []int{9}
}
func (m *Error) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Error) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Error.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Error) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Error.Merge(m, src)
}
func (m *Error) XXX_Size() int {
	return m.Size()
}
func (m *Error) XXX_DiscardUnknown() {
	xxx_messageInfo_Error.DiscardUnknown(m)
}

var xxx_messageInfo_Error proto.InternalMessageInfo

func (m *Error) GetType() ErrorType {
	if m != nil {
		return m.Type
	}
	return ErrorType_OK
}

func (m *Error) GetMessage() string {
	if m != nil {
		return m.Message
	}
	return ""
}

type TsoRequest struct {
	Header               *RequestHeader `protobuf:"bytes,1,opt,name=header,proto3" json:"header,omitempty"`
	Count                uint32         `protobuf:"varint,2,opt,name=count,proto3" json:"count,omitempty"`
	DcLocation           string         `protobuf:"bytes,3,opt,name=dc_location,json=dcLocation,proto3" json:"dc_location,omitempty"`
	XXX_NoUnkeyedLiteral struct{}       `json:"-"`
	XXX_unrecognized     []byte         `json:"-"`
	XXX_sizecache        int32          `json:"-"`
}

func (m *TsoRequest) Reset()         { *m = TsoRequest{} }
func (m *TsoRequest) String() string { return proto.CompactTextString(m) }
func (*TsoRequest) ProtoMessage()    {}
func (*TsoRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_78b27e6f04f44c6e, []int{10}
}
func (m *TsoRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TsoRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TsoRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TsoRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TsoRequest.Merge(m, src)
}
func (m *TsoRequest) XXX_Size() int {
	return m.Size()
}
func (m *TsoRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_TsoRequest.DiscardUnknown(m)
}

var xxx_messageInfo_TsoRequest proto.InternalMessageInfo

func (m *TsoRequest) GetHeader() *RequestHeader {
	if m != nil {
		return m.Header
	}
	return nil
}

func (m *TsoRequest) GetCount() uint32 {
	if m != nil {
		return m.Count
	}
	return 0
}

func (m *TsoRequest) GetDcLocation() string {
	if m != nil {
		return m.DcLocation
	}
	return ""
}

type TaasRequest struct {
	Header               *RequestHeader `protobuf:"bytes,1,opt,name=header,proto3" json:"header,omitempty"`
	Stamp                bool           `protobuf:"varint,2,opt,name=stamp,proto3" json:"stamp,omitempty"`
	Count                uint32         `protobuf:"varint,3,opt,name=count,proto3" json:"count,omitempty"`
	DcLocation           string         `protobuf:"bytes,4,opt,name=dc_location,json=dcLocation,proto3" json:"dc_location,omitempty"`
	XXX_NoUnkeyedLiteral struct{}       `json:"-"`
	XXX_unrecognized     []byte         `json:"-"`
	XXX_sizecache        int32          `json:"-"`
}

func (m *TaasRequest) Reset()         { *m = TaasRequest{} }
func (m *TaasRequest) String() string { return proto.CompactTextString(m) }
func (*TaasRequest) ProtoMessage()    {}
func (*TaasRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_78b27e6f04f44c6e, []int{11}
}
func (m *TaasRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TaasRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TaasRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TaasRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TaasRequest.Merge(m, src)
}
func (m *TaasRequest) XXX_Size() int {
	return m.Size()
}
func (m *TaasRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_TaasRequest.DiscardUnknown(m)
}

var xxx_messageInfo_TaasRequest proto.InternalMessageInfo

func (m *TaasRequest) GetHeader() *RequestHeader {
	if m != nil {
		return m.Header
	}
	return nil
}

func (m *TaasRequest) GetStamp() bool {
	if m != nil {
		return m.Stamp
	}
	return false
}

func (m *TaasRequest) GetCount() uint32 {
	if m != nil {
		return m.Count
	}
	return 0
}

func (m *TaasRequest) GetDcLocation() string {
	if m != nil {
		return m.DcLocation
	}
	return ""
}

type Timestamp struct {
	Physical int64 `protobuf:"varint,1,opt,name=physical,proto3" json:"physical,omitempty"`
	Logical  int64 `protobuf:"varint,2,opt,name=logical,proto3" json:"logical,omitempty"`
	// Number of suffix bits used for global distinction,
	// PD client will use this to compute a TSO's logical part.
	SuffixBits           uint32   `protobuf:"varint,3,opt,name=suffix_bits,json=suffixBits,proto3" json:"suffix_bits,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Timestamp) Reset()         { *m = Timestamp{} }
func (m *Timestamp) String() string { return proto.CompactTextString(m) }
func (*Timestamp) ProtoMessage()    {}
func (*Timestamp) Descriptor() ([]byte, []int) {
	return fileDescriptor_78b27e6f04f44c6e, []int{12}
}
func (m *Timestamp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Timestamp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Timestamp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Timestamp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Timestamp.Merge(m, src)
}
func (m *Timestamp) XXX_Size() int {
	return m.Size()
}
func (m *Timestamp) XXX_DiscardUnknown() {
	xxx_messageInfo_Timestamp.DiscardUnknown(m)
}

var xxx_messageInfo_Timestamp proto.InternalMessageInfo

func (m *Timestamp) GetPhysical() int64 {
	if m != nil {
		return m.Physical
	}
	return 0
}

func (m *Timestamp) GetLogical() int64 {
	if m != nil {
		return m.Logical
	}
	return 0
}

func (m *Timestamp) GetSuffixBits() uint32 {
	if m != nil {
		return m.SuffixBits
	}
	return 0
}

type TsoResponse struct {
	Header               *ResponseHeader `protobuf:"bytes,1,opt,name=header,proto3" json:"header,omitempty"`
	Count                uint32          `protobuf:"varint,2,opt,name=count,proto3" json:"count,omitempty"`
	Timestamp            *Timestamp      `protobuf:"bytes,3,opt,name=timestamp,proto3" json:"timestamp,omitempty"`
	XXX_NoUnkeyedLiteral struct{}        `json:"-"`
	XXX_unrecognized     []byte          `json:"-"`
	XXX_sizecache        int32           `json:"-"`
}

func (m *TsoResponse) Reset()         { *m = TsoResponse{} }
func (m *TsoResponse) String() string { return proto.CompactTextString(m) }
func (*TsoResponse) ProtoMessage()    {}
func (*TsoResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_78b27e6f04f44c6e, []int{13}
}
func (m *TsoResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TsoResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TsoResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TsoResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TsoResponse.Merge(m, src)
}
func (m *TsoResponse) XXX_Size() int {
	return m.Size()
}
func (m *TsoResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_TsoResponse.DiscardUnknown(m)
}

var xxx_messageInfo_TsoResponse proto.InternalMessageInfo

func (m *TsoResponse) GetHeader() *ResponseHeader {
	if m != nil {
		return m.Header
	}
	return nil
}

func (m *TsoResponse) GetCount() uint32 {
	if m != nil {
		return m.Count
	}
	return 0
}

func (m *TsoResponse) GetTimestamp() *Timestamp {
	if m != nil {
		return m.Timestamp
	}
	return nil
}

type BootstrapRequest struct {
	Header               *RequestHeader `protobuf:"bytes,1,opt,name=header,proto3" json:"header,omitempty"`
	Store                *metapb.Store  `protobuf:"bytes,2,opt,name=store,proto3" json:"store,omitempty"`
	Region               *metapb.Region `protobuf:"bytes,3,opt,name=region,proto3" json:"region,omitempty"`
	XXX_NoUnkeyedLiteral struct{}       `json:"-"`
	XXX_unrecognized     []byte         `json:"-"`
	XXX_sizecache        int32          `json:"-"`
}

func (m *BootstrapRequest) Reset()         { *m = BootstrapRequest{} }
func (m *BootstrapRequest) String() string { return proto.CompactTextString(m) }
func (*BootstrapRequest) ProtoMessage()    {}
func (*BootstrapRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_78b27e6f04f44c6e, []int{14}
}
func (m *BootstrapRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BootstrapRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BootstrapRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BootstrapRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BootstrapRequest.Merge(m, src)
}
func (m *BootstrapRequest) XXX_Size() int {
	return m.Size()
}
func (m *BootstrapRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_BootstrapRequest.DiscardUnknown(m)
}

var xxx_messageInfo_BootstrapRequest proto.InternalMessageInfo

func (m *BootstrapRequest) GetHeader() *RequestHeader {
	if m != nil {
		return m.Header
	}
	return nil
}

func (m *BootstrapRequest) GetStore() *metapb.Store {
	if m != nil {
		return m.Store
	}
	return nil
}

func (m *BootstrapRequest) GetRegion() *metapb.Region {
	if m != nil {
		return m.Region
	}
	return nil
}

type BootstrapResponse struct {
	Header               *ResponseHeader                       `protobuf:"bytes,1,opt,name=header,proto3" json:"header,omitempty"`
	ReplicationStatus    *replication_modepb.ReplicationStatus `protobuf:"bytes,2,opt,name=replication_status,json=replicationStatus,proto3" json:"replication_status,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                              `json:"-"`
	XXX_unrecognized     []byte                                `json:"-"`
	XXX_sizecache        int32                                 `json:"-"`
}

func (m *BootstrapResponse) Reset()         { *m = BootstrapResponse{} }
func (m *BootstrapResponse) String() string { return proto.CompactTextString(m) }
func (*BootstrapResponse) ProtoMessage()    {}
func (*BootstrapResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_78b27e6f04f44c6e, []int{15}
}
func (m *BootstrapResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BootstrapResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BootstrapResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BootstrapResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BootstrapResponse.Merge(m, src)
}
func (m *BootstrapResponse) XXX_Size() int {
	return m.Size()
}
func (m *BootstrapResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_BootstrapResponse.DiscardUnknown(m)
}

var xxx_messageInfo_BootstrapResponse proto.InternalMessageInfo

func (m *BootstrapResponse) GetHeader() *ResponseHeader {
	if m != nil {
		return m.Header
	}
	return nil
}

func (m *BootstrapResponse) GetReplicationStatus() *replication_modepb.ReplicationStatus {
	if m != nil {
		return m.ReplicationStatus
	}
	return nil
}

type IsBootstrappedRequest struct {
	Header               *RequestHeader `protobuf:"bytes,1,opt,name=header,proto3" json:"header,omitempty"`
	XXX_NoUnkeyedLiteral struct{}       `json:"-"`
	XXX_unrecognized     []byte         `json:"-"`
	XXX_sizecache        int32          `json:"-"`
}

func (m *IsBootstrappedRequest) Reset()         { *m = IsBootstrappedRequest{} }
func (m *IsBootstrappedRequest) String() string { return proto.CompactTextString(m) }
func (*IsBootstrappedRequest) ProtoMessage()    {}
func (*IsBootstrappedRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_78b27e6f04f44c6e, []int{16}
}
func (m *IsBootstrappedRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *IsBootstrappedRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_IsBootstrappedRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *IsBootstrappedRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_IsBootstrappedRequest.Merge(m, src)
}
func (m *IsBootstrappedRequest) XXX_Size() int {
	return m.Size()
}
func (m *IsBootstrappedRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_IsBootstrappedRequest.DiscardUnknown(m)
}

var xxx_messageInfo_IsBootstrappedRequest proto.InternalMessageInfo

func (m *IsBootstrappedRequest) GetHeader() *RequestHeader {
	if m != nil {
		return m.Header
	}
	return nil
}

type IsBootstrappedResponse struct {
	Header               *ResponseHeader `protobuf:"bytes,1,opt,name=header,proto3" json:"header,omitempty"`
	Bootstrapped         bool            `protobuf:"varint,2,opt,name=bootstrapped,proto3" json:"bootstrapped,omitempty"`
	XXX_NoUnkeyedLiteral struct{}        `json:"-"`
	XXX_unrecognized     []byte          `json:"-"`
	XXX_sizecache        int32           `json:"-"`
}

func (m *IsBootstrappedResponse) Reset()         { *m = IsBootstrappedResponse{} }
func (m *IsBootstrappedResponse) String() string { return proto.CompactTextString(m) }
func (*IsBootstrappedResponse) ProtoMessage()    {}
func (*IsBootstrappedResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_78b27e6f04f44c6e, []int{17}
}
func (m *IsBootstrappedResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *IsBootstrappedResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_IsBootstrappedResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *IsBootstrappedResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_IsBootstrappedResponse.Merge(m, src)
}
func (m *IsBootstrappedResponse) XXX_Size() int {
	return m.Size()
}
func (m *IsBootstrappedResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_IsBootstrappedResponse.DiscardUnknown(m)
}

var xxx_messageInfo_IsBootstrappedResponse proto.InternalMessageInfo

func (m *IsBootstrappedResponse) GetHeader() *ResponseHeader {
	if m != nil {
		return m.Header
	}
	return nil
}

func (m *IsBootstrappedResponse) GetBootstrapped() bool {
	if m != nil {
		return m.Bootstrapped
	}
	return false
}

type AllocIDRequest struct {
	Header               *RequestHeader `protobuf:"bytes,1,opt,name=header,proto3" json:"header,omitempty"`
	XXX_NoUnkeyedLiteral struct{}       `json:"-"`
	XXX_unrecognized     []byte         `json:"-"`
	XXX_sizecache        int32          `json:"-"`
}

func (m *AllocIDRequest) Reset()         { *m = AllocIDRequest{} }
func (m *AllocIDRequest) String() string { return proto.CompactTextString(m) }
func (*AllocIDRequest) ProtoMessage()    {}
func (*AllocIDRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_78b27e6f04f44c6e, []int{18}
}
func (m *AllocIDRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AllocIDRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AllocIDRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AllocIDRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AllocIDRequest.Merge(m, src)
}
func (m *AllocIDRequest) XXX_Size() int {
	return m.Size()
}
func (m *AllocIDRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_AllocIDRequest.DiscardUnknown(m)
}

var xxx_messageInfo_AllocIDRequest proto.InternalMessageInfo

func (m *AllocIDRequest) GetHeader() *RequestHeader {
	if m != nil {
		return m.Header
	}
	return nil
}

type AllocIDResponse struct {
	Header               *ResponseHeader `protobuf:"bytes,1,opt,name=header,proto3" json:"header,omitempty"`
	Id                   uint64          `protobuf:"varint,2,opt,name=id,proto3" json:"id,omitempty"`
	XXX_NoUnkeyedLiteral struct{}        `json:"-"`
	XXX_unrecognized     []byte          `json:"-"`
	XXX_sizecache        int32           `json:"-"`
}

func (m *AllocIDResponse) Reset()         { *m = AllocIDResponse{} }
func (m *AllocIDResponse) String() string { return proto.CompactTextString(m) }
func (*AllocIDResponse) ProtoMessage()    {}
func (*AllocIDResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_78b27e6f04f44c6e, []int{19}
}
func (m *AllocIDResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AllocIDResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AllocIDResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AllocIDResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AllocIDResponse.Merge(m, src)
}
func (m *AllocIDResponse) XXX_Size() int {
	return m.Size()
}
func (m *AllocIDResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_AllocIDResponse.DiscardUnknown(m)
}

var xxx_messageInfo_AllocIDResponse proto.InternalMessageInfo

func (m *AllocIDResponse) GetHeader() *ResponseHeader {
	if m != nil {
		return m.Header
	}
	return nil
}

func (m *AllocIDResponse) GetId() uint64 {
	if m != nil {
		return m.Id
	}
	return 0
}

type IsSnapshotRecoveringRequest struct {
	Header               *RequestHeader `protobuf:"bytes,1,opt,name=header,proto3" json:"header,omitempty"`
	XXX_NoUnkeyedLiteral struct{}       `json:"-"`
	XXX_unrecognized     []byte         `json:"-"`
	XXX_sizecache        int32          `json:"-"`
}

func (m *IsSnapshotRecoveringRequest) Reset()         { *m = IsSnapshotRecoveringRequest{} }
func (m *IsSnapshotRecoveringRequest) String() string { return proto.CompactTextString(m) }
func (*IsSnapshotRecoveringRequest) ProtoMessage()    {}
func (*IsSnapshotRecoveringRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_78b27e6f04f44c6e, []int{20}
}
func (m *IsSnapshotRecoveringRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *IsSnapshotRecoveringRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_IsSnapshotRecoveringRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *IsSnapshotRecoveringRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_IsSnapshotRecoveringRequest.Merge(m, src)
}
func (m *IsSnapshotRecoveringRequest) XXX_Size() int {
	return m.Size()
}
func (m *IsSnapshotRecoveringRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_IsSnapshotRecoveringRequest.DiscardUnknown(m)
}

var xxx_messageInfo_IsSnapshotRecoveringRequest proto.InternalMessageInfo

func (m *IsSnapshotRecoveringRequest) GetHeader() *RequestHeader {
	if m != nil {
		return m.Header
	}
	return nil
}

type IsSnapshotRecoveringResponse struct {
	Header               *ResponseHeader `protobuf:"bytes,1,opt,name=header,proto3" json:"header,omitempty"`
	Marked               bool            `protobuf:"varint,2,opt,name=marked,proto3" json:"marked,omitempty"`
	XXX_NoUnkeyedLiteral struct{}        `json:"-"`
	XXX_unrecognized     []byte          `json:"-"`
	XXX_sizecache        int32           `json:"-"`
}

func (m *IsSnapshotRecoveringResponse) Reset()         { *m = IsSnapshotRecoveringResponse{} }
func (m *IsSnapshotRecoveringResponse) String() string { return proto.CompactTextString(m) }
func (*IsSnapshotRecoveringResponse) ProtoMessage()    {}
func (*IsSnapshotRecoveringResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_78b27e6f04f44c6e, []int{21}
}
func (m *IsSnapshotRecoveringResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *IsSnapshotRecoveringResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_IsSnapshotRecoveringResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *IsSnapshotRecoveringResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_IsSnapshotRecoveringResponse.Merge(m, src)
}
func (m *IsSnapshotRecoveringResponse) XXX_Size() int {
	return m.Size()
}
func (m *IsSnapshotRecoveringResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_IsSnapshotRecoveringResponse.DiscardUnknown(m)
}

var xxx_messageInfo_IsSnapshotRecoveringResponse proto.InternalMessageInfo

func (m *IsSnapshotRecoveringResponse) GetHeader() *ResponseHeader {
	if m != nil {
		return m.Header
	}
	return nil
}

func (m *IsSnapshotRecoveringResponse) GetMarked() bool {
	if m != nil {
		return m.Marked
	}
	return false
}

type GetStoreRequest struct {
	Header               *RequestHeader `protobuf:"bytes,1,opt,name=header,proto3" json:"header,omitempty"`
	StoreId              uint64         `protobuf:"varint,2,opt,name=store_id,json=storeId,proto3" json:"store_id,omitempty"`
	XXX_NoUnkeyedLiteral struct{}       `json:"-"`
	XXX_unrecognized     []byte         `json:"-"`
	XXX_sizecache        int32          `json:"-"`
}

func (m *GetStoreRequest) Reset()         { *m = GetStoreRequest{} }
func (m *GetStoreRequest) String() string { return proto.CompactTextString(m) }
func (*GetStoreRequest) ProtoMessage()    {}
func (*GetStoreRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_78b27e6f04f44c6e, []int{22}
}
func (m *GetStoreRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetStoreRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetStoreRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetStoreRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetStoreRequest.Merge(m, src)
}
func (m *GetStoreRequest) XXX_Size() int {
	return m.Size()
}
func (m *GetStoreRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_GetStoreRequest.DiscardUnknown(m)
}

var xxx_messageInfo_GetStoreRequest proto.InternalMessageInfo

func (m *GetStoreRequest) GetHeader() *RequestHeader {
	if m != nil {
		return m.Header
	}
	return nil
}

func (m *GetStoreRequest) GetStoreId() uint64 {
	if m != nil {
		return m.StoreId
	}
	return 0
}

type GetStoreResponse struct {
	Header               *ResponseHeader `protobuf:"bytes,1,opt,name=header,proto3" json:"header,omitempty"`
	Store                *metapb.Store   `protobuf:"bytes,2,opt,name=store,proto3" json:"store,omitempty"`
	Stats                *StoreStats     `protobuf:"bytes,3,opt,name=stats,proto3" json:"stats,omitempty"`
	XXX_NoUnkeyedLiteral struct{}        `json:"-"`
	XXX_unrecognized     []byte          `json:"-"`
	XXX_sizecache        int32           `json:"-"`
}

func (m *GetStoreResponse) Reset()         { *m = GetStoreResponse{} }
func (m *GetStoreResponse) String() string { return proto.CompactTextString(m) }
func (*GetStoreResponse) ProtoMessage()    {}
func (*GetStoreResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_78b27e6f04f44c6e, []int{23}
}
func (m *GetStoreResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetStoreResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetStoreResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetStoreResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetStoreResponse.Merge(m, src)
}
func (m *GetStoreResponse) XXX_Size() int {
	return m.Size()
}
func (m *GetStoreResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_GetStoreResponse.DiscardUnknown(m)
}

var xxx_messageInfo_GetStoreResponse proto.InternalMessageInfo

func (m *GetStoreResponse) GetHeader() *ResponseHeader {
	if m != nil {
		return m.Header
	}
	return nil
}

func (m *GetStoreResponse) GetStore() *metapb.Store {
	if m != nil {
		return m.Store
	}
	return nil
}

func (m *GetStoreResponse) GetStats() *StoreStats {
	if m != nil {
		return m.Stats
	}
	return nil
}

type PutStoreRequest struct {
	Header               *RequestHeader `protobuf:"bytes,1,opt,name=header,proto3" json:"header,omitempty"`
	Store                *metapb.Store  `protobuf:"bytes,2,opt,name=store,proto3" json:"store,omitempty"`
	XXX_NoUnkeyedLiteral struct{}       `json:"-"`
	XXX_unrecognized     []byte         `json:"-"`
	XXX_sizecache        int32          `json:"-"`
}

func (m *PutStoreRequest) Reset()         { *m = PutStoreRequest{} }
func (m *PutStoreRequest) String() string { return proto.CompactTextString(m) }
func (*PutStoreRequest) ProtoMessage()    {}
func (*PutStoreRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_78b27e6f04f44c6e, []int{24}
}
func (m *PutStoreRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PutStoreRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PutStoreRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PutStoreRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PutStoreRequest.Merge(m, src)
}
func (m *PutStoreRequest) XXX_Size() int {
	return m.Size()
}
func (m *PutStoreRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_PutStoreRequest.DiscardUnknown(m)
}

var xxx_messageInfo_PutStoreRequest proto.InternalMessageInfo

func (m *PutStoreRequest) GetHeader() *RequestHeader {
	if m != nil {
		return m.Header
	}
	return nil
}

func (m *PutStoreRequest) GetStore() *metapb.Store {
	if m != nil {
		return m.Store
	}
	return nil
}

type PutStoreResponse struct {
	Header               *ResponseHeader                       `protobuf:"bytes,1,opt,name=header,proto3" json:"header,omitempty"`
	ReplicationStatus    *replication_modepb.ReplicationStatus `protobuf:"bytes,2,opt,name=replication_status,json=replicationStatus,proto3" json:"replication_status,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                              `json:"-"`
	XXX_unrecognized     []byte                                `json:"-"`
	XXX_sizecache        int32                                 `json:"-"`
}

func (m *PutStoreResponse) Reset()         { *m = PutStoreResponse{} }
func (m *PutStoreResponse) String() string { return proto.CompactTextString(m) }
func (*PutStoreResponse) ProtoMessage()    {}
func (*PutStoreResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_78b27e6f04f44c6e, []int{25}
}
func (m *PutStoreResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PutStoreResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PutStoreResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PutStoreResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PutStoreResponse.Merge(m, src)
}
func (m *PutStoreResponse) XXX_Size() int {
	return m.Size()
}
func (m *PutStoreResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_PutStoreResponse.DiscardUnknown(m)
}

var xxx_messageInfo_PutStoreResponse proto.InternalMessageInfo

func (m *PutStoreResponse) GetHeader() *ResponseHeader {
	if m != nil {
		return m.Header
	}
	return nil
}

func (m *PutStoreResponse) GetReplicationStatus() *replication_modepb.ReplicationStatus {
	if m != nil {
		return m.ReplicationStatus
	}
	return nil
}

type GetAllStoresRequest struct {
	Header *RequestHeader `protobuf:"bytes,1,opt,name=header,proto3" json:"header,omitempty"`
	// Do NOT return tombstone stores if set to true.
	ExcludeTombstoneStores bool     `protobuf:"varint,2,opt,name=exclude_tombstone_stores,json=excludeTombstoneStores,proto3" json:"exclude_tombstone_stores,omitempty"`
	XXX_NoUnkeyedLiteral   struct{} `json:"-"`
	XXX_unrecognized       []byte   `json:"-"`
	XXX_sizecache          int32    `json:"-"`
}

func (m *GetAllStoresRequest) Reset()         { *m = GetAllStoresRequest{} }
func (m *GetAllStoresRequest) String() string { return proto.CompactTextString(m) }
func (*GetAllStoresRequest) ProtoMessage()    {}
func (*GetAllStoresRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_78b27e6f04f44c6e, []int{26}
}
func (m *GetAllStoresRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetAllStoresRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetAllStoresRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetAllStoresRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetAllStoresRequest.Merge(m, src)
}
func (m *GetAllStoresRequest) XXX_Size() int {
	return m.Size()
}
func (m *GetAllStoresRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_GetAllStoresRequest.DiscardUnknown(m)
}

var xxx_messageInfo_GetAllStoresRequest proto.InternalMessageInfo

func (m *GetAllStoresRequest) GetHeader() *RequestHeader {
	if m != nil {
		return m.Header
	}
	return nil
}

func (m *GetAllStoresRequest) GetExcludeTombstoneStores() bool {
	if m != nil {
		return m.ExcludeTombstoneStores
	}
	return false
}

type GetAllStoresResponse struct {
	Header               *ResponseHeader `protobuf:"bytes,1,opt,name=header,proto3" json:"header,omitempty"`
	Stores               []*metapb.Store `protobuf:"bytes,2,rep,name=stores,proto3" json:"stores,omitempty"`
	XXX_NoUnkeyedLiteral struct{}        `json:"-"`
	XXX_unrecognized     []byte          `json:"-"`
	XXX_sizecache        int32           `json:"-"`
}

func (m *GetAllStoresResponse) Reset()         { *m = GetAllStoresResponse{} }
func (m *GetAllStoresResponse) String() string { return proto.CompactTextString(m) }
func (*GetAllStoresResponse) ProtoMessage()    {}
func (*GetAllStoresResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_78b27e6f04f44c6e, []int{27}
}
func (m *GetAllStoresResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetAllStoresResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetAllStoresResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetAllStoresResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetAllStoresResponse.Merge(m, src)
}
func (m *GetAllStoresResponse) XXX_Size() int {
	return m.Size()
}
func (m *GetAllStoresResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_GetAllStoresResponse.DiscardUnknown(m)
}

var xxx_messageInfo_GetAllStoresResponse proto.InternalMessageInfo

func (m *GetAllStoresResponse) GetHeader() *ResponseHeader {
	if m != nil {
		return m.Header
	}
	return nil
}

func (m *GetAllStoresResponse) GetStores() []*metapb.Store {
	if m != nil {
		return m.Stores
	}
	return nil
}

type GetRegionRequest struct {
	Header               *RequestHeader `protobuf:"bytes,1,opt,name=header,proto3" json:"header,omitempty"`
	RegionKey            []byte         `protobuf:"bytes,2,opt,name=region_key,json=regionKey,proto3" json:"region_key,omitempty"`
	NeedBuckets          bool           `protobuf:"varint,3,opt,name=need_buckets,json=needBuckets,proto3" json:"need_buckets,omitempty"`
	XXX_NoUnkeyedLiteral struct{}       `json:"-"`
	XXX_unrecognized     []byte         `json:"-"`
	XXX_sizecache        int32          `json:"-"`
}

func (m *GetRegionRequest) Reset()         { *m = GetRegionRequest{} }
func (m *GetRegionRequest) String() string { return proto.CompactTextString(m) }
func (*GetRegionRequest) ProtoMessage()    {}
func (*GetRegionRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_78b27e6f04f44c6e, []int{28}
}
func (m *GetRegionRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetRegionRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetRegionRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetRegionRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetRegionRequest.Merge(m, src)
}
func (m *GetRegionRequest) XXX_Size() int {
	return m.Size()
}
func (m *GetRegionRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_GetRegionRequest.DiscardUnknown(m)
}

var xxx_messageInfo_GetRegionRequest proto.InternalMessageInfo

func (m *GetRegionRequest) GetHeader() *RequestHeader {
	if m != nil {
		return m.Header
	}
	return nil
}

func (m *GetRegionRequest) GetRegionKey() []byte {
	if m != nil {
		return m.RegionKey
	}
	return nil
}

func (m *GetRegionRequest) GetNeedBuckets() bool {
	if m != nil {
		return m.NeedBuckets
	}
	return false
}

type GetRegionResponse struct {
	Header *ResponseHeader `protobuf:"bytes,1,opt,name=header,proto3" json:"header,omitempty"`
	Region *metapb.Region  `protobuf:"bytes,2,opt,name=region,proto3" json:"region,omitempty"`
	Leader *metapb.Peer    `protobuf:"bytes,3,opt,name=leader,proto3" json:"leader,omitempty"`
	// Leader considers that these peers are down.
	DownPeers []*PeerStats `protobuf:"bytes,5,rep,name=down_peers,json=downPeers,proto3" json:"down_peers,omitempty"`
	// Pending peers are the peers that the leader can't consider as
	// working followers.
	PendingPeers []*metapb.Peer `protobuf:"bytes,6,rep,name=pending_peers,json=pendingPeers,proto3" json:"pending_peers,omitempty"`
	// buckets isn't nil if GetRegion.* requests set need_buckets.
	Buckets              *metapb.Buckets `protobuf:"bytes,7,opt,name=buckets,proto3" json:"buckets,omitempty"`
	XXX_NoUnkeyedLiteral struct{}        `json:"-"`
	XXX_unrecognized     []byte          `json:"-"`
	XXX_sizecache        int32           `json:"-"`
}

func (m *GetRegionResponse) Reset()         { *m = GetRegionResponse{} }
func (m *GetRegionResponse) String() string { return proto.CompactTextString(m) }
func (*GetRegionResponse) ProtoMessage()    {}
func (*GetRegionResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_78b27e6f04f44c6e, []int{29}
}
func (m *GetRegionResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetRegionResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetRegionResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetRegionResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetRegionResponse.Merge(m, src)
}
func (m *GetRegionResponse) XXX_Size() int {
	return m.Size()
}
func (m *GetRegionResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_GetRegionResponse.DiscardUnknown(m)
}

var xxx_messageInfo_GetRegionResponse proto.InternalMessageInfo

func (m *GetRegionResponse) GetHeader() *ResponseHeader {
	if m != nil {
		return m.Header
	}
	return nil
}

func (m *GetRegionResponse) GetRegion() *metapb.Region {
	if m != nil {
		return m.Region
	}
	return nil
}

func (m *GetRegionResponse) GetLeader() *metapb.Peer {
	if m != nil {
		return m.Leader
	}
	return nil
}

func (m *GetRegionResponse) GetDownPeers() []*PeerStats {
	if m != nil {
		return m.DownPeers
	}
	return nil
}

func (m *GetRegionResponse) GetPendingPeers() []*metapb.Peer {
	if m != nil {
		return m.PendingPeers
	}
	return nil
}

func (m *GetRegionResponse) GetBuckets() *metapb.Buckets {
	if m != nil {
		return m.Buckets
	}
	return nil
}

type GetRegionByIDRequest struct {
	Header               *RequestHeader `protobuf:"bytes,1,opt,name=header,proto3" json:"header,omitempty"`
	RegionId             uint64         `protobuf:"varint,2,opt,name=region_id,json=regionId,proto3" json:"region_id,omitempty"`
	NeedBuckets          bool           `protobuf:"varint,3,opt,name=need_buckets,json=needBuckets,proto3" json:"need_buckets,omitempty"`
	XXX_NoUnkeyedLiteral struct{}       `json:"-"`
	XXX_unrecognized     []byte         `json:"-"`
	XXX_sizecache        int32          `json:"-"`
}

func (m *GetRegionByIDRequest) Reset()         { *m = GetRegionByIDRequest{} }
func (m *GetRegionByIDRequest) String() string { return proto.CompactTextString(m) }
func (*GetRegionByIDRequest) ProtoMessage()    {}
func (*GetRegionByIDRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_78b27e6f04f44c6e, []int{30}
}
func (m *GetRegionByIDRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetRegionByIDRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetRegionByIDRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetRegionByIDRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetRegionByIDRequest.Merge(m, src)
}
func (m *GetRegionByIDRequest) XXX_Size() int {
	return m.Size()
}
func (m *GetRegionByIDRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_GetRegionByIDRequest.DiscardUnknown(m)
}

var xxx_messageInfo_GetRegionByIDRequest proto.InternalMessageInfo

func (m *GetRegionByIDRequest) GetHeader() *RequestHeader {
	if m != nil {
		return m.Header
	}
	return nil
}

func (m *GetRegionByIDRequest) GetRegionId() uint64 {
	if m != nil {
		return m.RegionId
	}
	return 0
}

func (m *GetRegionByIDRequest) GetNeedBuckets() bool {
	if m != nil {
		return m.NeedBuckets
	}
	return false
}

type ScanRegionsRequest struct {
	Header               *RequestHeader `protobuf:"bytes,1,opt,name=header,proto3" json:"header,omitempty"`
	StartKey             []byte         `protobuf:"bytes,2,opt,name=start_key,json=startKey,proto3" json:"start_key,omitempty"`
	Limit                int32          `protobuf:"varint,3,opt,name=limit,proto3" json:"limit,omitempty"`
	EndKey               []byte         `protobuf:"bytes,4,opt,name=end_key,json=endKey,proto3" json:"end_key,omitempty"`
	XXX_NoUnkeyedLiteral struct{}       `json:"-"`
	XXX_unrecognized     []byte         `json:"-"`
	XXX_sizecache        int32          `json:"-"`
}

func (m *ScanRegionsRequest) Reset()         { *m = ScanRegionsRequest{} }
func (m *ScanRegionsRequest) String() string { return proto.CompactTextString(m) }
func (*ScanRegionsRequest) ProtoMessage()    {}
func (*ScanRegionsRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_78b27e6f04f44c6e, []int{31}
}
func (m *ScanRegionsRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ScanRegionsRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ScanRegionsRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ScanRegionsRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ScanRegionsRequest.Merge(m, src)
}
func (m *ScanRegionsRequest) XXX_Size() int {
	return m.Size()
}
func (m *ScanRegionsRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ScanRegionsRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ScanRegionsRequest proto.InternalMessageInfo

func (m *ScanRegionsRequest) GetHeader() *RequestHeader {
	if m != nil {
		return m.Header
	}
	return nil
}

func (m *ScanRegionsRequest) GetStartKey() []byte {
	if m != nil {
		return m.StartKey
	}
	return nil
}

func (m *ScanRegionsRequest) GetLimit() int32 {
	if m != nil {
		return m.Limit
	}
	return 0
}

func (m *ScanRegionsRequest) GetEndKey() []byte {
	if m != nil {
		return m.EndKey
	}
	return nil
}

type Region struct {
	Region *metapb.Region `protobuf:"bytes,1,opt,name=region,proto3" json:"region,omitempty"`
	Leader *metapb.Peer   `protobuf:"bytes,2,opt,name=leader,proto3" json:"leader,omitempty"`
	// Leader considers that these peers are down.
	DownPeers []*PeerStats `protobuf:"bytes,3,rep,name=down_peers,json=downPeers,proto3" json:"down_peers,omitempty"`
	// Pending peers are the peers that the leader can't consider as
	// working followers.
	PendingPeers         []*metapb.Peer `protobuf:"bytes,4,rep,name=pending_peers,json=pendingPeers,proto3" json:"pending_peers,omitempty"`
	XXX_NoUnkeyedLiteral struct{}       `json:"-"`
	XXX_unrecognized     []byte         `json:"-"`
	XXX_sizecache        int32          `json:"-"`
}

func (m *Region) Reset()         { *m = Region{} }
func (m *Region) String() string { return proto.CompactTextString(m) }
func (*Region) ProtoMessage()    {}
func (*Region) Descriptor() ([]byte, []int) {
	return fileDescriptor_78b27e6f04f44c6e, []int{32}
}
func (m *Region) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Region) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Region.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Region) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Region.Merge(m, src)
}
func (m *Region) XXX_Size() int {
	return m.Size()
}
func (m *Region) XXX_DiscardUnknown() {
	xxx_messageInfo_Region.DiscardUnknown(m)
}

var xxx_messageInfo_Region proto.InternalMessageInfo

func (m *Region) GetRegion() *metapb.Region {
	if m != nil {
		return m.Region
	}
	return nil
}

func (m *Region) GetLeader() *metapb.Peer {
	if m != nil {
		return m.Leader
	}
	return nil
}

func (m *Region) GetDownPeers() []*PeerStats {
	if m != nil {
		return m.DownPeers
	}
	return nil
}

func (m *Region) GetPendingPeers() []*metapb.Peer {
	if m != nil {
		return m.PendingPeers
	}
	return nil
}

type ScanRegionsResponse struct {
	Header *ResponseHeader `protobuf:"bytes,1,opt,name=header,proto3" json:"header,omitempty"`
	// Keep for backword compatibability.
	RegionMetas []*metapb.Region `protobuf:"bytes,2,rep,name=region_metas,json=regionMetas,proto3" json:"region_metas,omitempty"`
	Leaders     []*metapb.Peer   `protobuf:"bytes,3,rep,name=leaders,proto3" json:"leaders,omitempty"`
	// Extended region info with down/pending peers.
	Regions              []*Region `protobuf:"bytes,4,rep,name=regions,proto3" json:"regions,omitempty"`
	XXX_NoUnkeyedLiteral struct{}  `json:"-"`
	XXX_unrecognized     []byte    `json:"-"`
	XXX_sizecache        int32     `json:"-"`
}

func (m *ScanRegionsResponse) Reset()         { *m = ScanRegionsResponse{} }
func (m *ScanRegionsResponse) String() string { return proto.CompactTextString(m) }
func (*ScanRegionsResponse) ProtoMessage()    {}
func (*ScanRegionsResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_78b27e6f04f44c6e, []int{33}
}
func (m *ScanRegionsResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ScanRegionsResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ScanRegionsResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ScanRegionsResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ScanRegionsResponse.Merge(m, src)
}
func (m *ScanRegionsResponse) XXX_Size() int {
	return m.Size()
}
func (m *ScanRegionsResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_ScanRegionsResponse.DiscardUnknown(m)
}

var xxx_messageInfo_ScanRegionsResponse proto.InternalMessageInfo

func (m *ScanRegionsResponse) GetHeader() *ResponseHeader {
	if m != nil {
		return m.Header
	}
	return nil
}

func (m *ScanRegionsResponse) GetRegionMetas() []*metapb.Region {
	if m != nil {
		return m.RegionMetas
	}
	return nil
}

func (m *ScanRegionsResponse) GetLeaders() []*metapb.Peer {
	if m != nil {
		return m.Leaders
	}
	return nil
}

func (m *ScanRegionsResponse) GetRegions() []*Region {
	if m != nil {
		return m.Regions
	}
	return nil
}

type GetClusterConfigRequest struct {
	Header               *RequestHeader `protobuf:"bytes,1,opt,name=header,proto3" json:"header,omitempty"`
	XXX_NoUnkeyedLiteral struct{}       `json:"-"`
	XXX_unrecognized     []byte         `json:"-"`
	XXX_sizecache        int32          `json:"-"`
}

func (m *GetClusterConfigRequest) Reset()         { *m = GetClusterConfigRequest{} }
func (m *GetClusterConfigRequest) String() string { return proto.CompactTextString(m) }
func (*GetClusterConfigRequest) ProtoMessage()    {}
func (*GetClusterConfigRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_78b27e6f04f44c6e, []int{34}
}
func (m *GetClusterConfigRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetClusterConfigRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetClusterConfigRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetClusterConfigRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetClusterConfigRequest.Merge(m, src)
}
func (m *GetClusterConfigRequest) XXX_Size() int {
	return m.Size()
}
func (m *GetClusterConfigRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_GetClusterConfigRequest.DiscardUnknown(m)
}

var xxx_messageInfo_GetClusterConfigRequest proto.InternalMessageInfo

func (m *GetClusterConfigRequest) GetHeader() *RequestHeader {
	if m != nil {
		return m.Header
	}
	return nil
}

type GetClusterConfigResponse struct {
	Header               *ResponseHeader `protobuf:"bytes,1,opt,name=header,proto3" json:"header,omitempty"`
	Cluster              *metapb.Cluster `protobuf:"bytes,2,opt,name=cluster,proto3" json:"cluster,omitempty"`
	XXX_NoUnkeyedLiteral struct{}        `json:"-"`
	XXX_unrecognized     []byte          `json:"-"`
	XXX_sizecache        int32           `json:"-"`
}

func (m *GetClusterConfigResponse) Reset()         { *m = GetClusterConfigResponse{} }
func (m *GetClusterConfigResponse) String() string { return proto.CompactTextString(m) }
func (*GetClusterConfigResponse) ProtoMessage()    {}
func (*GetClusterConfigResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_78b27e6f04f44c6e, []int{35}
}
func (m *GetClusterConfigResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetClusterConfigResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetClusterConfigResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetClusterConfigResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetClusterConfigResponse.Merge(m, src)
}
func (m *GetClusterConfigResponse) XXX_Size() int {
	return m.Size()
}
func (m *GetClusterConfigResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_GetClusterConfigResponse.DiscardUnknown(m)
}

var xxx_messageInfo_GetClusterConfigResponse proto.InternalMessageInfo

func (m *GetClusterConfigResponse) GetHeader() *ResponseHeader {
	if m != nil {
		return m.Header
	}
	return nil
}

func (m *GetClusterConfigResponse) GetCluster() *metapb.Cluster {
	if m != nil {
		return m.Cluster
	}
	return nil
}

type PutClusterConfigRequest struct {
	Header               *RequestHeader  `protobuf:"bytes,1,opt,name=header,proto3" json:"header,omitempty"`
	Cluster              *metapb.Cluster `protobuf:"bytes,2,opt,name=cluster,proto3" json:"cluster,omitempty"`
	XXX_NoUnkeyedLiteral struct{}        `json:"-"`
	XXX_unrecognized     []byte          `json:"-"`
	XXX_sizecache        int32           `json:"-"`
}

func (m *PutClusterConfigRequest) Reset()         { *m = PutClusterConfigRequest{} }
func (m *PutClusterConfigRequest) String() string { return proto.CompactTextString(m) }
func (*PutClusterConfigRequest) ProtoMessage()    {}
func (*PutClusterConfigRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_78b27e6f04f44c6e, []int{36}
}
func (m *PutClusterConfigRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PutClusterConfigRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PutClusterConfigRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PutClusterConfigRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PutClusterConfigRequest.Merge(m, src)
}
func (m *PutClusterConfigRequest) XXX_Size() int {
	return m.Size()
}
func (m *PutClusterConfigRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_PutClusterConfigRequest.DiscardUnknown(m)
}

var xxx_messageInfo_PutClusterConfigRequest proto.InternalMessageInfo

func (m *PutClusterConfigRequest) GetHeader() *RequestHeader {
	if m != nil {
		return m.Header
	}
	return nil
}

func (m *PutClusterConfigRequest) GetCluster() *metapb.Cluster {
	if m != nil {
		return m.Cluster
	}
	return nil
}

type PutClusterConfigResponse struct {
	Header               *ResponseHeader `protobuf:"bytes,1,opt,name=header,proto3" json:"header,omitempty"`
	XXX_NoUnkeyedLiteral struct{}        `json:"-"`
	XXX_unrecognized     []byte          `json:"-"`
	XXX_sizecache        int32           `json:"-"`
}

func (m *PutClusterConfigResponse) Reset()         { *m = PutClusterConfigResponse{} }
func (m *PutClusterConfigResponse) String() string { return proto.CompactTextString(m) }
func (*PutClusterConfigResponse) ProtoMessage()    {}
func (*PutClusterConfigResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_78b27e6f04f44c6e, []int{37}
}
func (m *PutClusterConfigResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PutClusterConfigResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PutClusterConfigResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PutClusterConfigResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PutClusterConfigResponse.Merge(m, src)
}
func (m *PutClusterConfigResponse) XXX_Size() int {
	return m.Size()
}
func (m *PutClusterConfigResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_PutClusterConfigResponse.DiscardUnknown(m)
}

var xxx_messageInfo_PutClusterConfigResponse proto.InternalMessageInfo

func (m *PutClusterConfigResponse) GetHeader() *ResponseHeader {
	if m != nil {
		return m.Header
	}
	return nil
}

type Member struct {
	// name is the name of the PD member.
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// member_id is the unique id of the PD member.
	MemberId             uint64   `protobuf:"varint,2,opt,name=member_id,json=memberId,proto3" json:"member_id,omitempty"`
	PeerUrls             []string `protobuf:"bytes,3,rep,name=peer_urls,json=peerUrls,proto3" json:"peer_urls,omitempty"`
	ClientUrls           []string `protobuf:"bytes,4,rep,name=client_urls,json=clientUrls,proto3" json:"client_urls,omitempty"`
	LeaderPriority       int32    `protobuf:"varint,5,opt,name=leader_priority,json=leaderPriority,proto3" json:"leader_priority,omitempty"`
	DeployPath           string   `protobuf:"bytes,6,opt,name=deploy_path,json=deployPath,proto3" json:"deploy_path,omitempty"`
	BinaryVersion        string   `protobuf:"bytes,7,opt,name=binary_version,json=binaryVersion,proto3" json:"binary_version,omitempty"`
	GitHash              string   `protobuf:"bytes,8,opt,name=git_hash,json=gitHash,proto3" json:"git_hash,omitempty"`
	DcLocation           string   `protobuf:"bytes,9,opt,name=dc_location,json=dcLocation,proto3" json:"dc_location,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Member) Reset()         { *m = Member{} }
func (m *Member) String() string { return proto.CompactTextString(m) }
func (*Member) ProtoMessage()    {}
func (*Member) Descriptor() ([]byte, []int) {
	return fileDescriptor_78b27e6f04f44c6e, []int{38}
}
func (m *Member) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Member) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Member.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Member) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Member.Merge(m, src)
}
func (m *Member) XXX_Size() int {
	return m.Size()
}
func (m *Member) XXX_DiscardUnknown() {
	xxx_messageInfo_Member.DiscardUnknown(m)
}

var xxx_messageInfo_Member proto.InternalMessageInfo

func (m *Member) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Member) GetMemberId() uint64 {
	if m != nil {
		return m.MemberId
	}
	return 0
}

func (m *Member) GetPeerUrls() []string {
	if m != nil {
		return m.PeerUrls
	}
	return nil
}

func (m *Member) GetClientUrls() []string {
	if m != nil {
		return m.ClientUrls
	}
	return nil
}

func (m *Member) GetLeaderPriority() int32 {
	if m != nil {
		return m.LeaderPriority
	}
	return 0
}

func (m *Member) GetDeployPath() string {
	if m != nil {
		return m.DeployPath
	}
	return ""
}

func (m *Member) GetBinaryVersion() string {
	if m != nil {
		return m.BinaryVersion
	}
	return ""
}

func (m *Member) GetGitHash() string {
	if m != nil {
		return m.GitHash
	}
	return ""
}

func (m *Member) GetDcLocation() string {
	if m != nil {
		return m.DcLocation
	}
	return ""
}

type GetMembersRequest struct {
	Header               *RequestHeader `protobuf:"bytes,1,opt,name=header,proto3" json:"header,omitempty"`
	XXX_NoUnkeyedLiteral struct{}       `json:"-"`
	XXX_unrecognized     []byte         `json:"-"`
	XXX_sizecache        int32          `json:"-"`
}

func (m *GetMembersRequest) Reset()         { *m = GetMembersRequest{} }
func (m *GetMembersRequest) String() string { return proto.CompactTextString(m) }
func (*GetMembersRequest) ProtoMessage()    {}
func (*GetMembersRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_78b27e6f04f44c6e, []int{39}
}
func (m *GetMembersRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetMembersRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetMembersRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetMembersRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetMembersRequest.Merge(m, src)
}
func (m *GetMembersRequest) XXX_Size() int {
	return m.Size()
}
func (m *GetMembersRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_GetMembersRequest.DiscardUnknown(m)
}

var xxx_messageInfo_GetMembersRequest proto.InternalMessageInfo

func (m *GetMembersRequest) GetHeader() *RequestHeader {
	if m != nil {
		return m.Header
	}
	return nil
}

type GetMembersResponse struct {
	Header               *ResponseHeader    `protobuf:"bytes,1,opt,name=header,proto3" json:"header,omitempty"`
	Members              []*Member          `protobuf:"bytes,2,rep,name=members,proto3" json:"members,omitempty"`
	Leader               *Member            `protobuf:"bytes,3,opt,name=leader,proto3" json:"leader,omitempty"`
	EtcdLeader           *Member            `protobuf:"bytes,4,opt,name=etcd_leader,json=etcdLeader,proto3" json:"etcd_leader,omitempty"`
	TsoAllocatorLeaders  map[string]*Member `protobuf:"bytes,5,rep,name=tso_allocator_leaders,json=tsoAllocatorLeaders,proto3" json:"tso_allocator_leaders,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	XXX_NoUnkeyedLiteral struct{}           `json:"-"`
	XXX_unrecognized     []byte             `json:"-"`
	XXX_sizecache        int32              `json:"-"`
}

func (m *GetMembersResponse) Reset()         { *m = GetMembersResponse{} }
func (m *GetMembersResponse) String() string { return proto.CompactTextString(m) }
func (*GetMembersResponse) ProtoMessage()    {}
func (*GetMembersResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_78b27e6f04f44c6e, []int{40}
}
func (m *GetMembersResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetMembersResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetMembersResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetMembersResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetMembersResponse.Merge(m, src)
}
func (m *GetMembersResponse) XXX_Size() int {
	return m.Size()
}
func (m *GetMembersResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_GetMembersResponse.DiscardUnknown(m)
}

var xxx_messageInfo_GetMembersResponse proto.InternalMessageInfo

func (m *GetMembersResponse) GetHeader() *ResponseHeader {
	if m != nil {
		return m.Header
	}
	return nil
}

func (m *GetMembersResponse) GetMembers() []*Member {
	if m != nil {
		return m.Members
	}
	return nil
}

func (m *GetMembersResponse) GetLeader() *Member {
	if m != nil {
		return m.Leader
	}
	return nil
}

func (m *GetMembersResponse) GetEtcdLeader() *Member {
	if m != nil {
		return m.EtcdLeader
	}
	return nil
}

func (m *GetMembersResponse) GetTsoAllocatorLeaders() map[string]*Member {
	if m != nil {
		return m.TsoAllocatorLeaders
	}
	return nil
}

type GetClusterInfoRequest struct {
	Header               *ResponseHeader `protobuf:"bytes,1,opt,name=header,proto3" json:"header,omitempty"`
	XXX_NoUnkeyedLiteral struct{}        `json:"-"`
	XXX_unrecognized     []byte          `json:"-"`
	XXX_sizecache        int32           `json:"-"`
}

func (m *GetClusterInfoRequest) Reset()         { *m = GetClusterInfoRequest{} }
func (m *GetClusterInfoRequest) String() string { return proto.CompactTextString(m) }
func (*GetClusterInfoRequest) ProtoMessage()    {}
func (*GetClusterInfoRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_78b27e6f04f44c6e, []int{41}
}
func (m *GetClusterInfoRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetClusterInfoRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetClusterInfoRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetClusterInfoRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetClusterInfoRequest.Merge(m, src)
}
func (m *GetClusterInfoRequest) XXX_Size() int {
	return m.Size()
}
func (m *GetClusterInfoRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_GetClusterInfoRequest.DiscardUnknown(m)
}

var xxx_messageInfo_GetClusterInfoRequest proto.InternalMessageInfo

func (m *GetClusterInfoRequest) GetHeader() *ResponseHeader {
	if m != nil {
		return m.Header
	}
	return nil
}

type GetClusterInfoResponse struct {
	Header               *ResponseHeader `protobuf:"bytes,1,opt,name=header,proto3" json:"header,omitempty"`
	ServiceModes         []ServiceMode   `protobuf:"varint,2,rep,packed,name=serviceModes,proto3,enum=pdpb.ServiceMode" json:"serviceModes,omitempty"`
	XXX_NoUnkeyedLiteral struct{}        `json:"-"`
	XXX_unrecognized     []byte          `json:"-"`
	XXX_sizecache        int32           `json:"-"`
}

func (m *GetClusterInfoResponse) Reset()         { *m = GetClusterInfoResponse{} }
func (m *GetClusterInfoResponse) String() string { return proto.CompactTextString(m) }
func (*GetClusterInfoResponse) ProtoMessage()    {}
func (*GetClusterInfoResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_78b27e6f04f44c6e, []int{42}
}
func (m *GetClusterInfoResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetClusterInfoResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetClusterInfoResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetClusterInfoResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetClusterInfoResponse.Merge(m, src)
}
func (m *GetClusterInfoResponse) XXX_Size() int {
	return m.Size()
}
func (m *GetClusterInfoResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_GetClusterInfoResponse.DiscardUnknown(m)
}

var xxx_messageInfo_GetClusterInfoResponse proto.InternalMessageInfo

func (m *GetClusterInfoResponse) GetHeader() *ResponseHeader {
	if m != nil {
		return m.Header
	}
	return nil
}

func (m *GetClusterInfoResponse) GetServiceModes() []ServiceMode {
	if m != nil {
		return m.ServiceModes
	}
	return nil
}

type PeerStats struct {
	Peer                 *metapb.Peer `protobuf:"bytes,1,opt,name=peer,proto3" json:"peer,omitempty"`
	DownSeconds          uint64       `protobuf:"varint,2,opt,name=down_seconds,json=downSeconds,proto3" json:"down_seconds,omitempty"`
	XXX_NoUnkeyedLiteral struct{}     `json:"-"`
	XXX_unrecognized     []byte       `json:"-"`
	XXX_sizecache        int32        `json:"-"`
}

func (m *PeerStats) Reset()         { *m = PeerStats{} }
func (m *PeerStats) String() string { return proto.CompactTextString(m) }
func (*PeerStats) ProtoMessage()    {}
func (*PeerStats) Descriptor() ([]byte, []int) {
	return fileDescriptor_78b27e6f04f44c6e, []int{43}
}
func (m *PeerStats) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PeerStats) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PeerStats.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PeerStats) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PeerStats.Merge(m, src)
}
func (m *PeerStats) XXX_Size() int {
	return m.Size()
}
func (m *PeerStats) XXX_DiscardUnknown() {
	xxx_messageInfo_PeerStats.DiscardUnknown(m)
}

var xxx_messageInfo_PeerStats proto.InternalMessageInfo

func (m *PeerStats) GetPeer() *metapb.Peer {
	if m != nil {
		return m.Peer
	}
	return nil
}

func (m *PeerStats) GetDownSeconds() uint64 {
	if m != nil {
		return m.DownSeconds
	}
	return 0
}

type RegionHeartbeatRequest struct {
	Header *RequestHeader `protobuf:"bytes,1,opt,name=header,proto3" json:"header,omitempty"`
	Region *metapb.Region `protobuf:"bytes,2,opt,name=region,proto3" json:"region,omitempty"`
	// Leader Peer sending the heartbeat.
	Leader *metapb.Peer `protobuf:"bytes,3,opt,name=leader,proto3" json:"leader,omitempty"`
	// Leader considers that these peers are down.
	DownPeers []*PeerStats `protobuf:"bytes,4,rep,name=down_peers,json=downPeers,proto3" json:"down_peers,omitempty"`
	// Pending peers are the peers that the leader can't consider as
	// working followers.
	PendingPeers []*metapb.Peer `protobuf:"bytes,5,rep,name=pending_peers,json=pendingPeers,proto3" json:"pending_peers,omitempty"`
	// Bytes read/written during this period.
	BytesWritten uint64 `protobuf:"varint,6,opt,name=bytes_written,json=bytesWritten,proto3" json:"bytes_written,omitempty"`
	BytesRead    uint64 `protobuf:"varint,7,opt,name=bytes_read,json=bytesRead,proto3" json:"bytes_read,omitempty"`
	// Keys read/written during this period.
	KeysWritten uint64 `protobuf:"varint,8,opt,name=keys_written,json=keysWritten,proto3" json:"keys_written,omitempty"`
	KeysRead    uint64 `protobuf:"varint,9,opt,name=keys_read,json=keysRead,proto3" json:"keys_read,omitempty"`
	// Approximate region size.
	ApproximateSize uint64 `protobuf:"varint,10,opt,name=approximate_size,json=approximateSize,proto3" json:"approximate_size,omitempty"`
	// Actually reported time interval
	Interval *TimeInterval `protobuf:"bytes,12,opt,name=interval,proto3" json:"interval,omitempty"`
	// Approximate number of keys.
	ApproximateKeys uint64 `protobuf:"varint,13,opt,name=approximate_keys,json=approximateKeys,proto3" json:"approximate_keys,omitempty"`
	// Term is the term of raft group.
	Term              uint64                                      `protobuf:"varint,14,opt,name=term,proto3" json:"term,omitempty"`
	ReplicationStatus *replication_modepb.RegionReplicationStatus `protobuf:"bytes,15,opt,name=replication_status,json=replicationStatus,proto3" json:"replication_status,omitempty"`
	// QueryStats reported write query stats, and there are read query stats in store heartbeat
	QueryStats *QueryStats `protobuf:"bytes,16,opt,name=query_stats,json=queryStats,proto3" json:"query_stats,omitempty"`
	// cpu_usage is the CPU time usage of the leader region since the last heartbeat,
	// which is calculated by cpu_time_delta/heartbeat_reported_interval.
	CpuUsage uint64 `protobuf:"varint,17,opt,name=cpu_usage,json=cpuUsage,proto3" json:"cpu_usage,omitempty"`
	// (Serverless) Approximate size of key-value pairs for billing.
	// It's counted on size of user key & value (excluding metadata fields), before compression, and latest versions only.
	ApproximateKvSize    uint64   `protobuf:"varint,18,opt,name=approximate_kv_size,json=approximateKvSize,proto3" json:"approximate_kv_size,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *RegionHeartbeatRequest) Reset()         { *m = RegionHeartbeatRequest{} }
func (m *RegionHeartbeatRequest) String() string { return proto.CompactTextString(m) }
func (*RegionHeartbeatRequest) ProtoMessage()    {}
func (*RegionHeartbeatRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_78b27e6f04f44c6e, []int{44}
}
func (m *RegionHeartbeatRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RegionHeartbeatRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RegionHeartbeatRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RegionHeartbeatRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RegionHeartbeatRequest.Merge(m, src)
}
func (m *RegionHeartbeatRequest) XXX_Size() int {
	return m.Size()
}
func (m *RegionHeartbeatRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_RegionHeartbeatRequest.DiscardUnknown(m)
}

var xxx_messageInfo_RegionHeartbeatRequest proto.InternalMessageInfo

func (m *RegionHeartbeatRequest) GetHeader() *RequestHeader {
	if m != nil {
		return m.Header
	}
	return nil
}

func (m *RegionHeartbeatRequest) GetRegion() *metapb.Region {
	if m != nil {
		return m.Region
	}
	return nil
}

func (m *RegionHeartbeatRequest) GetLeader() *metapb.Peer {
	if m != nil {
		return m.Leader
	}
	return nil
}

func (m *RegionHeartbeatRequest) GetDownPeers() []*PeerStats {
	if m != nil {
		return m.DownPeers
	}
	return nil
}

func (m *RegionHeartbeatRequest) GetPendingPeers() []*metapb.Peer {
	if m != nil {
		return m.PendingPeers
	}
	return nil
}

func (m *RegionHeartbeatRequest) GetBytesWritten() uint64 {
	if m != nil {
		return m.BytesWritten
	}
	return 0
}

func (m *RegionHeartbeatRequest) GetBytesRead() uint64 {
	if m != nil {
		return m.BytesRead
	}
	return 0
}

func (m *RegionHeartbeatRequest) GetKeysWritten() uint64 {
	if m != nil {
		return m.KeysWritten
	}
	return 0
}

func (m *RegionHeartbeatRequest) GetKeysRead() uint64 {
	if m != nil {
		return m.KeysRead
	}
	return 0
}

func (m *RegionHeartbeatRequest) GetApproximateSize() uint64 {
	if m != nil {
		return m.ApproximateSize
	}
	return 0
}

func (m *RegionHeartbeatRequest) GetInterval() *TimeInterval {
	if m != nil {
		return m.Interval
	}
	return nil
}

func (m *RegionHeartbeatRequest) GetApproximateKeys() uint64 {
	if m != nil {
		return m.ApproximateKeys
	}
	return 0
}

func (m *RegionHeartbeatRequest) GetTerm() uint64 {
	if m != nil {
		return m.Term
	}
	return 0
}

func (m *RegionHeartbeatRequest) GetReplicationStatus() *replication_modepb.RegionReplicationStatus {
	if m != nil {
		return m.ReplicationStatus
	}
	return nil
}

func (m *RegionHeartbeatRequest) GetQueryStats() *QueryStats {
	if m != nil {
		return m.QueryStats
	}
	return nil
}

func (m *RegionHeartbeatRequest) GetCpuUsage() uint64 {
	if m != nil {
		return m.CpuUsage
	}
	return 0
}

func (m *RegionHeartbeatRequest) GetApproximateKvSize() uint64 {
	if m != nil {
		return m.ApproximateKvSize
	}
	return 0
}

type ChangePeer struct {
	Peer                 *metapb.Peer           `protobuf:"bytes,1,opt,name=peer,proto3" json:"peer,omitempty"`
	ChangeType           eraftpb.ConfChangeType `protobuf:"varint,2,opt,name=change_type,json=changeType,proto3,enum=eraftpb.ConfChangeType" json:"change_type,omitempty"`
	XXX_NoUnkeyedLiteral struct{}               `json:"-"`
	XXX_unrecognized     []byte                 `json:"-"`
	XXX_sizecache        int32                  `json:"-"`
}

func (m *ChangePeer) Reset()         { *m = ChangePeer{} }
func (m *ChangePeer) String() string { return proto.CompactTextString(m) }
func (*ChangePeer) ProtoMessage()    {}
func (*ChangePeer) Descriptor() ([]byte, []int) {
	return fileDescriptor_78b27e6f04f44c6e, []int{45}
}
func (m *ChangePeer) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ChangePeer) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ChangePeer.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ChangePeer) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ChangePeer.Merge(m, src)
}
func (m *ChangePeer) XXX_Size() int {
	return m.Size()
}
func (m *ChangePeer) XXX_DiscardUnknown() {
	xxx_messageInfo_ChangePeer.DiscardUnknown(m)
}

var xxx_messageInfo_ChangePeer proto.InternalMessageInfo

func (m *ChangePeer) GetPeer() *metapb.Peer {
	if m != nil {
		return m.Peer
	}
	return nil
}

func (m *ChangePeer) GetChangeType() eraftpb.ConfChangeType {
	if m != nil {
		return m.ChangeType
	}
	return eraftpb.ConfChangeType_AddNode
}

type ChangePeerV2 struct {
	// If changes is empty, it means that to exit joint state.
	Changes              []*ChangePeer `protobuf:"bytes,1,rep,name=changes,proto3" json:"changes,omitempty"`
	XXX_NoUnkeyedLiteral struct{}      `json:"-"`
	XXX_unrecognized     []byte        `json:"-"`
	XXX_sizecache        int32         `json:"-"`
}

func (m *ChangePeerV2) Reset()         { *m = ChangePeerV2{} }
func (m *ChangePeerV2) String() string { return proto.CompactTextString(m) }
func (*ChangePeerV2) ProtoMessage()    {}
func (*ChangePeerV2) Descriptor() ([]byte, []int) {
	return fileDescriptor_78b27e6f04f44c6e, []int{46}
}
func (m *ChangePeerV2) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ChangePeerV2) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ChangePeerV2.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ChangePeerV2) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ChangePeerV2.Merge(m, src)
}
func (m *ChangePeerV2) XXX_Size() int {
	return m.Size()
}
func (m *ChangePeerV2) XXX_DiscardUnknown() {
	xxx_messageInfo_ChangePeerV2.DiscardUnknown(m)
}

var xxx_messageInfo_ChangePeerV2 proto.InternalMessageInfo

func (m *ChangePeerV2) GetChanges() []*ChangePeer {
	if m != nil {
		return m.Changes
	}
	return nil
}

type TransferLeader struct {
	Peer                 *metapb.Peer   `protobuf:"bytes,1,opt,name=peer,proto3" json:"peer,omitempty"`
	Peers                []*metapb.Peer `protobuf:"bytes,2,rep,name=peers,proto3" json:"peers,omitempty"`
	XXX_NoUnkeyedLiteral struct{}       `json:"-"`
	XXX_unrecognized     []byte         `json:"-"`
	XXX_sizecache        int32          `json:"-"`
}

func (m *TransferLeader) Reset()         { *m = TransferLeader{} }
func (m *TransferLeader) String() string { return proto.CompactTextString(m) }
func (*TransferLeader) ProtoMessage()    {}
func (*TransferLeader) Descriptor() ([]byte, []int) {
	return fileDescriptor_78b27e6f04f44c6e, []int{47}
}
func (m *TransferLeader) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TransferLeader) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TransferLeader.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TransferLeader) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TransferLeader.Merge(m, src)
}
func (m *TransferLeader) XXX_Size() int {
	return m.Size()
}
func (m *TransferLeader) XXX_DiscardUnknown() {
	xxx_messageInfo_TransferLeader.DiscardUnknown(m)
}

var xxx_messageInfo_TransferLeader proto.InternalMessageInfo

func (m *TransferLeader) GetPeer() *metapb.Peer {
	if m != nil {
		return m.Peer
	}
	return nil
}

func (m *TransferLeader) GetPeers() []*metapb.Peer {
	if m != nil {
		return m.Peers
	}
	return nil
}

type Merge struct {
	Target               *metapb.Region `protobuf:"bytes,1,opt,name=target,proto3" json:"target,omitempty"`
	XXX_NoUnkeyedLiteral struct{}       `json:"-"`
	XXX_unrecognized     []byte         `json:"-"`
	XXX_sizecache        int32          `json:"-"`
}

func (m *Merge) Reset()         { *m = Merge{} }
func (m *Merge) String() string { return proto.CompactTextString(m) }
func (*Merge) ProtoMessage()    {}
func (*Merge) Descriptor() ([]byte, []int) {
	return fileDescriptor_78b27e6f04f44c6e, []int{48}
}
func (m *Merge) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Merge) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Merge.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Merge) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Merge.Merge(m, src)
}
func (m *Merge) XXX_Size() int {
	return m.Size()
}
func (m *Merge) XXX_DiscardUnknown() {
	xxx_messageInfo_Merge.DiscardUnknown(m)
}

var xxx_messageInfo_Merge proto.InternalMessageInfo

func (m *Merge) GetTarget() *metapb.Region {
	if m != nil {
		return m.Target
	}
	return nil
}

type SplitRegion struct {
	Policy               CheckPolicy `protobuf:"varint,1,opt,name=policy,proto3,enum=pdpb.CheckPolicy" json:"policy,omitempty"`
	Keys                 [][]byte    `protobuf:"bytes,2,rep,name=keys,proto3" json:"keys,omitempty"`
	XXX_NoUnkeyedLiteral struct{}    `json:"-"`
	XXX_unrecognized     []byte      `json:"-"`
	XXX_sizecache        int32       `json:"-"`
}

func (m *SplitRegion) Reset()         { *m = SplitRegion{} }
func (m *SplitRegion) String() string { return proto.CompactTextString(m) }
func (*SplitRegion) ProtoMessage()    {}
func (*SplitRegion) Descriptor() ([]byte, []int) {
	return fileDescriptor_78b27e6f04f44c6e, []int{49}
}
func (m *SplitRegion) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SplitRegion) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SplitRegion.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SplitRegion) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SplitRegion.Merge(m, src)
}
func (m *SplitRegion) XXX_Size() int {
	return m.Size()
}
func (m *SplitRegion) XXX_DiscardUnknown() {
	xxx_messageInfo_SplitRegion.DiscardUnknown(m)
}

var xxx_messageInfo_SplitRegion proto.InternalMessageInfo

func (m *SplitRegion) GetPolicy() CheckPolicy {
	if m != nil {
		return m.Policy
	}
	return CheckPolicy_SCAN
}

func (m *SplitRegion) GetKeys() [][]byte {
	if m != nil {
		return m.Keys
	}
	return nil
}

type SwitchWitness struct {
	PeerId               uint64   `protobuf:"varint,1,opt,name=peer_id,json=peerId,proto3" json:"peer_id,omitempty"`
	IsWitness            bool     `protobuf:"varint,2,opt,name=is_witness,json=isWitness,proto3" json:"is_witness,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *SwitchWitness) Reset()         { *m = SwitchWitness{} }
func (m *SwitchWitness) String() string { return proto.CompactTextString(m) }
func (*SwitchWitness) ProtoMessage()    {}
func (*SwitchWitness) Descriptor() ([]byte, []int) {
	return fileDescriptor_78b27e6f04f44c6e, []int{50}
}
func (m *SwitchWitness) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SwitchWitness) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SwitchWitness.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SwitchWitness) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SwitchWitness.Merge(m, src)
}
func (m *SwitchWitness) XXX_Size() int {
	return m.Size()
}
func (m *SwitchWitness) XXX_DiscardUnknown() {
	xxx_messageInfo_SwitchWitness.DiscardUnknown(m)
}

var xxx_messageInfo_SwitchWitness proto.InternalMessageInfo

func (m *SwitchWitness) GetPeerId() uint64 {
	if m != nil {
		return m.PeerId
	}
	return 0
}

func (m *SwitchWitness) GetIsWitness() bool {
	if m != nil {
		return m.IsWitness
	}
	return false
}

type BatchSwitchWitness struct {
	SwitchWitnesses      []*SwitchWitness `protobuf:"bytes,1,rep,name=switch_witnesses,json=switchWitnesses,proto3" json:"switch_witnesses,omitempty"`
	XXX_NoUnkeyedLiteral struct{}         `json:"-"`
	XXX_unrecognized     []byte           `json:"-"`
	XXX_sizecache        int32            `json:"-"`
}

func (m *BatchSwitchWitness) Reset()         { *m = BatchSwitchWitness{} }
func (m *BatchSwitchWitness) String() string { return proto.CompactTextString(m) }
func (*BatchSwitchWitness) ProtoMessage()    {}
func (*BatchSwitchWitness) Descriptor() ([]byte, []int) {
	return fileDescriptor_78b27e6f04f44c6e, []int{51}
}
func (m *BatchSwitchWitness) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BatchSwitchWitness) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BatchSwitchWitness.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BatchSwitchWitness) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BatchSwitchWitness.Merge(m, src)
}
func (m *BatchSwitchWitness) XXX_Size() int {
	return m.Size()
}
func (m *BatchSwitchWitness) XXX_DiscardUnknown() {
	xxx_messageInfo_BatchSwitchWitness.DiscardUnknown(m)
}

var xxx_messageInfo_BatchSwitchWitness proto.InternalMessageInfo

func (m *BatchSwitchWitness) GetSwitchWitnesses() []*SwitchWitness {
	if m != nil {
		return m.SwitchWitnesses
	}
	return nil
}

type RegionHeartbeatResponse struct {
	Header *ResponseHeader `protobuf:"bytes,1,opt,name=header,proto3" json:"header,omitempty"`
	// Notice, Pd only allows handling reported epoch >= current pd's.
	// Leader peer reports region status with RegionHeartbeatRequest
	// to pd regularly, pd will determine whether this region
	// should do ChangePeer or not.
	// E,g, max peer number is 3, region A, first only peer 1 in A.
	// 1. Pd region state -> Peers (1), ConfVer (1).
	// 2. Leader peer 1 reports region state to pd, pd finds the
	// peer number is < 3, so first changes its current region
	// state -> Peers (1, 2), ConfVer (1), and returns ChangePeer Adding 2.
	// 3. Leader does ChangePeer, then reports Peers (1, 2), ConfVer (2),
	// pd updates its state -> Peers (1, 2), ConfVer (2).
	// 4. Leader may report old Peers (1), ConfVer (1) to pd before ConfChange
	// finished, pd stills responses ChangePeer Adding 2, of course, we must
	// guarantee the second ChangePeer can't be applied in TiKV.
	ChangePeer *ChangePeer `protobuf:"bytes,2,opt,name=change_peer,json=changePeer,proto3" json:"change_peer,omitempty"`
	// Pd can return transfer_leader to let TiKV does leader transfer itself.
	TransferLeader *TransferLeader `protobuf:"bytes,3,opt,name=transfer_leader,json=transferLeader,proto3" json:"transfer_leader,omitempty"`
	// ID of the region
	RegionId    uint64              `protobuf:"varint,4,opt,name=region_id,json=regionId,proto3" json:"region_id,omitempty"`
	RegionEpoch *metapb.RegionEpoch `protobuf:"bytes,5,opt,name=region_epoch,json=regionEpoch,proto3" json:"region_epoch,omitempty"`
	// Leader of the region at the moment of the corresponding request was made.
	TargetPeer *metapb.Peer `protobuf:"bytes,6,opt,name=target_peer,json=targetPeer,proto3" json:"target_peer,omitempty"`
	Merge      *Merge       `protobuf:"bytes,7,opt,name=merge,proto3" json:"merge,omitempty"`
	// PD sends split_region to let TiKV split a region into two regions.
	SplitRegion *SplitRegion `protobuf:"bytes,8,opt,name=split_region,json=splitRegion,proto3" json:"split_region,omitempty"`
	// Multiple change peer operations atomically.
	// Note: PD can use both ChangePeer and ChangePeerV2 at the same time
	//       (not in the same RegionHeartbeatResponse).
	//       Now, PD use ChangePeerV2 in following scenarios:
	//       1. replacing peers
	//       2. demoting voter directly
	ChangePeerV2         *ChangePeerV2       `protobuf:"bytes,9,opt,name=change_peer_v2,json=changePeerV2,proto3" json:"change_peer_v2,omitempty"`
	SwitchWitnesses      *BatchSwitchWitness `protobuf:"bytes,10,opt,name=switch_witnesses,json=switchWitnesses,proto3" json:"switch_witnesses,omitempty"`
	XXX_NoUnkeyedLiteral struct{}            `json:"-"`
	XXX_unrecognized     []byte              `json:"-"`
	XXX_sizecache        int32               `json:"-"`
}

func (m *RegionHeartbeatResponse) Reset()         { *m = RegionHeartbeatResponse{} }
func (m *RegionHeartbeatResponse) String() string { return proto.CompactTextString(m) }
func (*RegionHeartbeatResponse) ProtoMessage()    {}
func (*RegionHeartbeatResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_78b27e6f04f44c6e, []int{52}
}
func (m *RegionHeartbeatResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RegionHeartbeatResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RegionHeartbeatResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RegionHeartbeatResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RegionHeartbeatResponse.Merge(m, src)
}
func (m *RegionHeartbeatResponse) XXX_Size() int {
	return m.Size()
}
func (m *RegionHeartbeatResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_RegionHeartbeatResponse.DiscardUnknown(m)
}

var xxx_messageInfo_RegionHeartbeatResponse proto.InternalMessageInfo

func (m *RegionHeartbeatResponse) GetHeader() *ResponseHeader {
	if m != nil {
		return m.Header
	}
	return nil
}

func (m *RegionHeartbeatResponse) GetChangePeer() *ChangePeer {
	if m != nil {
		return m.ChangePeer
	}
	return nil
}

func (m *RegionHeartbeatResponse) GetTransferLeader() *TransferLeader {
	if m != nil {
		return m.TransferLeader
	}
	return nil
}

func (m *RegionHeartbeatResponse) GetRegionId() uint64 {
	if m != nil {
		return m.RegionId
	}
	return 0
}

func (m *RegionHeartbeatResponse) GetRegionEpoch() *metapb.RegionEpoch {
	if m != nil {
		return m.RegionEpoch
	}
	return nil
}

func (m *RegionHeartbeatResponse) GetTargetPeer() *metapb.Peer {
	if m != nil {
		return m.TargetPeer
	}
	return nil
}

func (m *RegionHeartbeatResponse) GetMerge() *Merge {
	if m != nil {
		return m.Merge
	}
	return nil
}

func (m *RegionHeartbeatResponse) GetSplitRegion() *SplitRegion {
	if m != nil {
		return m.SplitRegion
	}
	return nil
}

func (m *RegionHeartbeatResponse) GetChangePeerV2() *ChangePeerV2 {
	if m != nil {
		return m.ChangePeerV2
	}
	return nil
}

func (m *RegionHeartbeatResponse) GetSwitchWitnesses() *BatchSwitchWitness {
	if m != nil {
		return m.SwitchWitnesses
	}
	return nil
}

type AskSplitRequest struct {
	Header               *RequestHeader `protobuf:"bytes,1,opt,name=header,proto3" json:"header,omitempty"`
	Region               *metapb.Region `protobuf:"bytes,2,opt,name=region,proto3" json:"region,omitempty"`
	XXX_NoUnkeyedLiteral struct{}       `json:"-"`
	XXX_unrecognized     []byte         `json:"-"`
	XXX_sizecache        int32          `json:"-"`
}

func (m *AskSplitRequest) Reset()         { *m = AskSplitRequest{} }
func (m *AskSplitRequest) String() string { return proto.CompactTextString(m) }
func (*AskSplitRequest) ProtoMessage()    {}
func (*AskSplitRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_78b27e6f04f44c6e, []int{53}
}
func (m *AskSplitRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AskSplitRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AskSplitRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AskSplitRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AskSplitRequest.Merge(m, src)
}
func (m *AskSplitRequest) XXX_Size() int {
	return m.Size()
}
func (m *AskSplitRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_AskSplitRequest.DiscardUnknown(m)
}

var xxx_messageInfo_AskSplitRequest proto.InternalMessageInfo

func (m *AskSplitRequest) GetHeader() *RequestHeader {
	if m != nil {
		return m.Header
	}
	return nil
}

func (m *AskSplitRequest) GetRegion() *metapb.Region {
	if m != nil {
		return m.Region
	}
	return nil
}

type AskSplitResponse struct {
	Header *ResponseHeader `protobuf:"bytes,1,opt,name=header,proto3" json:"header,omitempty"`
	// We split the region into two, first uses the origin
	// parent region id, and the second uses the new_region_id.
	// We must guarantee that the new_region_id is global unique.
	NewRegionId uint64 `protobuf:"varint,2,opt,name=new_region_id,json=newRegionId,proto3" json:"new_region_id,omitempty"`
	// The peer ids for the new split region.
	NewPeerIds           []uint64 `protobuf:"varint,3,rep,packed,name=new_peer_ids,json=newPeerIds,proto3" json:"new_peer_ids,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *AskSplitResponse) Reset()         { *m = AskSplitResponse{} }
func (m *AskSplitResponse) String() string { return proto.CompactTextString(m) }
func (*AskSplitResponse) ProtoMessage()    {}
func (*AskSplitResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_78b27e6f04f44c6e, []int{54}
}
func (m *AskSplitResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AskSplitResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AskSplitResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AskSplitResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AskSplitResponse.Merge(m, src)
}
func (m *AskSplitResponse) XXX_Size() int {
	return m.Size()
}
func (m *AskSplitResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_AskSplitResponse.DiscardUnknown(m)
}

var xxx_messageInfo_AskSplitResponse proto.InternalMessageInfo

func (m *AskSplitResponse) GetHeader() *ResponseHeader {
	if m != nil {
		return m.Header
	}
	return nil
}

func (m *AskSplitResponse) GetNewRegionId() uint64 {
	if m != nil {
		return m.NewRegionId
	}
	return 0
}

func (m *AskSplitResponse) GetNewPeerIds() []uint64 {
	if m != nil {
		return m.NewPeerIds
	}
	return nil
}

type ReportSplitRequest struct {
	Header               *RequestHeader `protobuf:"bytes,1,opt,name=header,proto3" json:"header,omitempty"`
	Left                 *metapb.Region `protobuf:"bytes,2,opt,name=left,proto3" json:"left,omitempty"`
	Right                *metapb.Region `protobuf:"bytes,3,opt,name=right,proto3" json:"right,omitempty"`
	XXX_NoUnkeyedLiteral struct{}       `json:"-"`
	XXX_unrecognized     []byte         `json:"-"`
	XXX_sizecache        int32          `json:"-"`
}

func (m *ReportSplitRequest) Reset()         { *m = ReportSplitRequest{} }
func (m *ReportSplitRequest) String() string { return proto.CompactTextString(m) }
func (*ReportSplitRequest) ProtoMessage()    {}
func (*ReportSplitRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_78b27e6f04f44c6e, []int{55}
}
func (m *ReportSplitRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ReportSplitRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ReportSplitRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ReportSplitRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ReportSplitRequest.Merge(m, src)
}
func (m *ReportSplitRequest) XXX_Size() int {
	return m.Size()
}
func (m *ReportSplitRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ReportSplitRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ReportSplitRequest proto.InternalMessageInfo

func (m *ReportSplitRequest) GetHeader() *RequestHeader {
	if m != nil {
		return m.Header
	}
	return nil
}

func (m *ReportSplitRequest) GetLeft() *metapb.Region {
	if m != nil {
		return m.Left
	}
	return nil
}

func (m *ReportSplitRequest) GetRight() *metapb.Region {
	if m != nil {
		return m.Right
	}
	return nil
}

type ReportSplitResponse struct {
	Header               *ResponseHeader `protobuf:"bytes,1,opt,name=header,proto3" json:"header,omitempty"`
	XXX_NoUnkeyedLiteral struct{}        `json:"-"`
	XXX_unrecognized     []byte          `json:"-"`
	XXX_sizecache        int32           `json:"-"`
}

func (m *ReportSplitResponse) Reset()         { *m = ReportSplitResponse{} }
func (m *ReportSplitResponse) String() string { return proto.CompactTextString(m) }
func (*ReportSplitResponse) ProtoMessage()    {}
func (*ReportSplitResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_78b27e6f04f44c6e, []int{56}
}
func (m *ReportSplitResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ReportSplitResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ReportSplitResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ReportSplitResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ReportSplitResponse.Merge(m, src)
}
func (m *ReportSplitResponse) XXX_Size() int {
	return m.Size()
}
func (m *ReportSplitResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_ReportSplitResponse.DiscardUnknown(m)
}

var xxx_messageInfo_ReportSplitResponse proto.InternalMessageInfo

func (m *ReportSplitResponse) GetHeader() *ResponseHeader {
	if m != nil {
		return m.Header
	}
	return nil
}

type AskBatchSplitRequest struct {
	Header               *RequestHeader `protobuf:"bytes,1,opt,name=header,proto3" json:"header,omitempty"`
	Region               *metapb.Region `protobuf:"bytes,2,opt,name=region,proto3" json:"region,omitempty"`
	SplitCount           uint32         `protobuf:"varint,3,opt,name=split_count,json=splitCount,proto3" json:"split_count,omitempty"`
	XXX_NoUnkeyedLiteral struct{}       `json:"-"`
	XXX_unrecognized     []byte         `json:"-"`
	XXX_sizecache        int32          `json:"-"`
}

func (m *AskBatchSplitRequest) Reset()         { *m = AskBatchSplitRequest{} }
func (m *AskBatchSplitRequest) String() string { return proto.CompactTextString(m) }
func (*AskBatchSplitRequest) ProtoMessage()    {}
func (*AskBatchSplitRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_78b27e6f04f44c6e, []int{57}
}
func (m *AskBatchSplitRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AskBatchSplitRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AskBatchSplitRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AskBatchSplitRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AskBatchSplitRequest.Merge(m, src)
}
func (m *AskBatchSplitRequest) XXX_Size() int {
	return m.Size()
}
func (m *AskBatchSplitRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_AskBatchSplitRequest.DiscardUnknown(m)
}

var xxx_messageInfo_AskBatchSplitRequest proto.InternalMessageInfo

func (m *AskBatchSplitRequest) GetHeader() *RequestHeader {
	if m != nil {
		return m.Header
	}
	return nil
}

func (m *AskBatchSplitRequest) GetRegion() *metapb.Region {
	if m != nil {
		return m.Region
	}
	return nil
}

func (m *AskBatchSplitRequest) GetSplitCount() uint32 {
	if m != nil {
		return m.SplitCount
	}
	return 0
}

type SplitID struct {
	NewRegionId          uint64   `protobuf:"varint,1,opt,name=new_region_id,json=newRegionId,proto3" json:"new_region_id,omitempty"`
	NewPeerIds           []uint64 `protobuf:"varint,2,rep,packed,name=new_peer_ids,json=newPeerIds,proto3" json:"new_peer_ids,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *SplitID) Reset()         { *m = SplitID{} }
func (m *SplitID) String() string { return proto.CompactTextString(m) }
func (*SplitID) ProtoMessage()    {}
func (*SplitID) Descriptor() ([]byte, []int) {
	return fileDescriptor_78b27e6f04f44c6e, []int{58}
}
func (m *SplitID) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SplitID) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SplitID.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SplitID) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SplitID.Merge(m, src)
}
func (m *SplitID) XXX_Size() int {
	return m.Size()
}
func (m *SplitID) XXX_DiscardUnknown() {
	xxx_messageInfo_SplitID.DiscardUnknown(m)
}

var xxx_messageInfo_SplitID proto.InternalMessageInfo

func (m *SplitID) GetNewRegionId() uint64 {
	if m != nil {
		return m.NewRegionId
	}
	return 0
}

func (m *SplitID) GetNewPeerIds() []uint64 {
	if m != nil {
		return m.NewPeerIds
	}
	return nil
}

type AskBatchSplitResponse struct {
	Header               *ResponseHeader `protobuf:"bytes,1,opt,name=header,proto3" json:"header,omitempty"`
	Ids                  []*SplitID      `protobuf:"bytes,2,rep,name=ids,proto3" json:"ids,omitempty"`
	XXX_NoUnkeyedLiteral struct{}        `json:"-"`
	XXX_unrecognized     []byte          `json:"-"`
	XXX_sizecache        int32           `json:"-"`
}

func (m *AskBatchSplitResponse) Reset()         { *m = AskBatchSplitResponse{} }
func (m *AskBatchSplitResponse) String() string { return proto.CompactTextString(m) }
func (*AskBatchSplitResponse) ProtoMessage()    {}
func (*AskBatchSplitResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_78b27e6f04f44c6e, []int{59}
}
func (m *AskBatchSplitResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AskBatchSplitResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AskBatchSplitResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AskBatchSplitResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AskBatchSplitResponse.Merge(m, src)
}
func (m *AskBatchSplitResponse) XXX_Size() int {
	return m.Size()
}
func (m *AskBatchSplitResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_AskBatchSplitResponse.DiscardUnknown(m)
}

var xxx_messageInfo_AskBatchSplitResponse proto.InternalMessageInfo

func (m *AskBatchSplitResponse) GetHeader() *ResponseHeader {
	if m != nil {
		return m.Header
	}
	return nil
}

func (m *AskBatchSplitResponse) GetIds() []*SplitID {
	if m != nil {
		return m.Ids
	}
	return nil
}

type ReportBatchSplitRequest struct {
	Header               *RequestHeader   `protobuf:"bytes,1,opt,name=header,proto3" json:"header,omitempty"`
	Regions              []*metapb.Region `protobuf:"bytes,2,rep,name=regions,proto3" json:"regions,omitempty"`
	XXX_NoUnkeyedLiteral struct{}         `json:"-"`
	XXX_unrecognized     []byte           `json:"-"`
	XXX_sizecache        int32            `json:"-"`
}

func (m *ReportBatchSplitRequest) Reset()         { *m = ReportBatchSplitRequest{} }
func (m *ReportBatchSplitRequest) String() string { return proto.CompactTextString(m) }
func (*ReportBatchSplitRequest) ProtoMessage()    {}
func (*ReportBatchSplitRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_78b27e6f04f44c6e, []int{60}
}
func (m *ReportBatchSplitRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ReportBatchSplitRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ReportBatchSplitRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ReportBatchSplitRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ReportBatchSplitRequest.Merge(m, src)
}
func (m *ReportBatchSplitRequest) XXX_Size() int {
	return m.Size()
}
func (m *ReportBatchSplitRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ReportBatchSplitRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ReportBatchSplitRequest proto.InternalMessageInfo

func (m *ReportBatchSplitRequest) GetHeader() *RequestHeader {
	if m != nil {
		return m.Header
	}
	return nil
}

func (m *ReportBatchSplitRequest) GetRegions() []*metapb.Region {
	if m != nil {
		return m.Regions
	}
	return nil
}

type ReportBatchSplitResponse struct {
	Header               *ResponseHeader `protobuf:"bytes,1,opt,name=header,proto3" json:"header,omitempty"`
	XXX_NoUnkeyedLiteral struct{}        `json:"-"`
	XXX_unrecognized     []byte          `json:"-"`
	XXX_sizecache        int32           `json:"-"`
}

func (m *ReportBatchSplitResponse) Reset()         { *m = ReportBatchSplitResponse{} }
func (m *ReportBatchSplitResponse) String() string { return proto.CompactTextString(m) }
func (*ReportBatchSplitResponse) ProtoMessage()    {}
func (*ReportBatchSplitResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_78b27e6f04f44c6e, []int{61}
}
func (m *ReportBatchSplitResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ReportBatchSplitResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ReportBatchSplitResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ReportBatchSplitResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ReportBatchSplitResponse.Merge(m, src)
}
func (m *ReportBatchSplitResponse) XXX_Size() int {
	return m.Size()
}
func (m *ReportBatchSplitResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_ReportBatchSplitResponse.DiscardUnknown(m)
}

var xxx_messageInfo_ReportBatchSplitResponse proto.InternalMessageInfo

func (m *ReportBatchSplitResponse) GetHeader() *ResponseHeader {
	if m != nil {
		return m.Header
	}
	return nil
}

type TimeInterval struct {
	// The unix timestamp in seconds of the start of this period.
	StartTimestamp uint64 `protobuf:"varint,1,opt,name=start_timestamp,json=startTimestamp,proto3" json:"start_timestamp,omitempty"`
	// The unix timestamp in seconds of the end of this period.
	EndTimestamp         uint64   `protobuf:"varint,2,opt,name=end_timestamp,json=endTimestamp,proto3" json:"end_timestamp,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *TimeInterval) Reset()         { *m = TimeInterval{} }
func (m *TimeInterval) String() string { return proto.CompactTextString(m) }
func (*TimeInterval) ProtoMessage()    {}
func (*TimeInterval) Descriptor() ([]byte, []int) {
	return fileDescriptor_78b27e6f04f44c6e, []int{62}
}
func (m *TimeInterval) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TimeInterval) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TimeInterval.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TimeInterval) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TimeInterval.Merge(m, src)
}
func (m *TimeInterval) XXX_Size() int {
	return m.Size()
}
func (m *TimeInterval) XXX_DiscardUnknown() {
	xxx_messageInfo_TimeInterval.DiscardUnknown(m)
}

var xxx_messageInfo_TimeInterval proto.InternalMessageInfo

func (m *TimeInterval) GetStartTimestamp() uint64 {
	if m != nil {
		return m.StartTimestamp
	}
	return 0
}

func (m *TimeInterval) GetEndTimestamp() uint64 {
	if m != nil {
		return m.EndTimestamp
	}
	return 0
}

type RecordPair struct {
	Key                  string   `protobuf:"bytes,1,opt,name=key,proto3" json:"key,omitempty"`
	Value                uint64   `protobuf:"varint,2,opt,name=value,proto3" json:"value,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *RecordPair) Reset()         { *m = RecordPair{} }
func (m *RecordPair) String() string { return proto.CompactTextString(m) }
func (*RecordPair) ProtoMessage()    {}
func (*RecordPair) Descriptor() ([]byte, []int) {
	return fileDescriptor_78b27e6f04f44c6e, []int{63}
}
func (m *RecordPair) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RecordPair) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RecordPair.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RecordPair) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RecordPair.Merge(m, src)
}
func (m *RecordPair) XXX_Size() int {
	return m.Size()
}
func (m *RecordPair) XXX_DiscardUnknown() {
	xxx_messageInfo_RecordPair.DiscardUnknown(m)
}

var xxx_messageInfo_RecordPair proto.InternalMessageInfo

func (m *RecordPair) GetKey() string {
	if m != nil {
		return m.Key
	}
	return ""
}

func (m *RecordPair) GetValue() uint64 {
	if m != nil {
		return m.Value
	}
	return 0
}

type PeerStat struct {
	RegionId             uint64      `protobuf:"varint,1,opt,name=region_id,json=regionId,proto3" json:"region_id,omitempty"`
	ReadKeys             uint64      `protobuf:"varint,2,opt,name=read_keys,json=readKeys,proto3" json:"read_keys,omitempty"`
	ReadBytes            uint64      `protobuf:"varint,3,opt,name=read_bytes,json=readBytes,proto3" json:"read_bytes,omitempty"`
	QueryStats           *QueryStats `protobuf:"bytes,4,opt,name=query_stats,json=queryStats,proto3" json:"query_stats,omitempty"`
	WrittenKeys          uint64      `protobuf:"varint,5,opt,name=written_keys,json=writtenKeys,proto3" json:"written_keys,omitempty"`
	WrittenBytes         uint64      `protobuf:"varint,6,opt,name=written_bytes,json=writtenBytes,proto3" json:"written_bytes,omitempty"`
	XXX_NoUnkeyedLiteral struct{}    `json:"-"`
	XXX_unrecognized     []byte      `json:"-"`
	XXX_sizecache        int32       `json:"-"`
}

func (m *PeerStat) Reset()         { *m = PeerStat{} }
func (m *PeerStat) String() string { return proto.CompactTextString(m) }
func (*PeerStat) ProtoMessage()    {}
func (*PeerStat) Descriptor() ([]byte, []int) {
	return fileDescriptor_78b27e6f04f44c6e, []int{64}
}
func (m *PeerStat) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PeerStat) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PeerStat.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PeerStat) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PeerStat.Merge(m, src)
}
func (m *PeerStat) XXX_Size() int {
	return m.Size()
}
func (m *PeerStat) XXX_DiscardUnknown() {
	xxx_messageInfo_PeerStat.DiscardUnknown(m)
}

var xxx_messageInfo_PeerStat proto.InternalMessageInfo

func (m *PeerStat) GetRegionId() uint64 {
	if m != nil {
		return m.RegionId
	}
	return 0
}

func (m *PeerStat) GetReadKeys() uint64 {
	if m != nil {
		return m.ReadKeys
	}
	return 0
}

func (m *PeerStat) GetReadBytes() uint64 {
	if m != nil {
		return m.ReadBytes
	}
	return 0
}

func (m *PeerStat) GetQueryStats() *QueryStats {
	if m != nil {
		return m.QueryStats
	}
	return nil
}

func (m *PeerStat) GetWrittenKeys() uint64 {
	if m != nil {
		return m.WrittenKeys
	}
	return 0
}

func (m *PeerStat) GetWrittenBytes() uint64 {
	if m != nil {
		return m.WrittenBytes
	}
	return 0
}

type StoreStats struct {
	StoreId uint64 `protobuf:"varint,1,opt,name=store_id,json=storeId,proto3" json:"store_id,omitempty"`
	// Capacity for the store.
	Capacity uint64 `protobuf:"varint,2,opt,name=capacity,proto3" json:"capacity,omitempty"`
	// Available size for the store.
	Available uint64 `protobuf:"varint,3,opt,name=available,proto3" json:"available,omitempty"`
	// Total region count in this store.
	RegionCount uint32 `protobuf:"varint,4,opt,name=region_count,json=regionCount,proto3" json:"region_count,omitempty"`
	// Current sending snapshot count.
	SendingSnapCount uint32 `protobuf:"varint,5,opt,name=sending_snap_count,json=sendingSnapCount,proto3" json:"sending_snap_count,omitempty"`
	// Current receiving snapshot count.
	ReceivingSnapCount uint32 `protobuf:"varint,6,opt,name=receiving_snap_count,json=receivingSnapCount,proto3" json:"receiving_snap_count,omitempty"`
	// When the store is started (unix timestamp in seconds).
	StartTime uint32 `protobuf:"varint,7,opt,name=start_time,json=startTime,proto3" json:"start_time,omitempty"`
	// How many region is applying snapshot.
	ApplyingSnapCount uint32 `protobuf:"varint,8,opt,name=applying_snap_count,json=applyingSnapCount,proto3" json:"applying_snap_count,omitempty"`
	// If the store is busy
	IsBusy bool `protobuf:"varint,9,opt,name=is_busy,json=isBusy,proto3" json:"is_busy,omitempty"`
	// Actually used space by db
	UsedSize uint64 `protobuf:"varint,10,opt,name=used_size,json=usedSize,proto3" json:"used_size,omitempty"`
	// Bytes written for the store during this period.
	BytesWritten uint64 `protobuf:"varint,11,opt,name=bytes_written,json=bytesWritten,proto3" json:"bytes_written,omitempty"`
	// Keys written for the store during this period.
	KeysWritten uint64 `protobuf:"varint,12,opt,name=keys_written,json=keysWritten,proto3" json:"keys_written,omitempty"`
	// Bytes read for the store during this period.
	BytesRead uint64 `protobuf:"varint,13,opt,name=bytes_read,json=bytesRead,proto3" json:"bytes_read,omitempty"`
	// Keys read for the store during this period.
	KeysRead uint64 `protobuf:"varint,14,opt,name=keys_read,json=keysRead,proto3" json:"keys_read,omitempty"`
	// Actually reported time interval
	Interval *TimeInterval `protobuf:"bytes,15,opt,name=interval,proto3" json:"interval,omitempty"`
	// Threads' CPU usages in the store
	CpuUsages []*RecordPair `protobuf:"bytes,16,rep,name=cpu_usages,json=cpuUsages,proto3" json:"cpu_usages,omitempty"`
	// Threads' read disk I/O rates in the store
	ReadIoRates []*RecordPair `protobuf:"bytes,17,rep,name=read_io_rates,json=readIoRates,proto3" json:"read_io_rates,omitempty"`
	// Threads' write disk I/O rates in the store
	WriteIoRates []*RecordPair `protobuf:"bytes,18,rep,name=write_io_rates,json=writeIoRates,proto3" json:"write_io_rates,omitempty"`
	// Operations' latencies in the store
	OpLatencies []*RecordPair `protobuf:"bytes,19,rep,name=op_latencies,json=opLatencies,proto3" json:"op_latencies,omitempty"`
	// Hot peer stat in the store
	PeerStats []*PeerStat `protobuf:"bytes,20,rep,name=peer_stats,json=peerStats,proto3" json:"peer_stats,omitempty"`
	// Store query stats
	QueryStats *QueryStats `protobuf:"bytes,21,opt,name=query_stats,json=queryStats,proto3" json:"query_stats,omitempty"`
	// Score that represents the speed of the store, ranges in [1, 100], lower is better.
	SlowScore uint64 `protobuf:"varint,22,opt,name=slow_score,json=slowScore,proto3" json:"slow_score,omitempty"`
	// Damaged regions on the store that need to be removed by PD.
	DamagedRegionsId []uint64 `protobuf:"varint,23,rep,packed,name=damaged_regions_id,json=damagedRegionsId,proto3" json:"damaged_regions_id,omitempty"`
	// If the apply worker is busy, namely high apply wait duration
	IsApplyBusy bool `protobuf:"varint,24,opt,name=is_apply_busy,json=isApplyBusy,proto3" json:"is_apply_busy,omitempty"`
	// Snapshot stats in the store
	SnapshotStats        []*SnapshotStat `protobuf:"bytes,25,rep,name=snapshot_stats,json=snapshotStats,proto3" json:"snapshot_stats,omitempty"`
	SlowTrend            *SlowTrend      `protobuf:"bytes,26,opt,name=slow_trend,json=slowTrend,proto3" json:"slow_trend,omitempty"`
	XXX_NoUnkeyedLiteral struct{}        `json:"-"`
	XXX_unrecognized     []byte          `json:"-"`
	XXX_sizecache        int32           `json:"-"`
}

func (m *StoreStats) Reset()         { *m = StoreStats{} }
func (m *StoreStats) String() string { return proto.CompactTextString(m) }
func (*StoreStats) ProtoMessage()    {}
func (*StoreStats) Descriptor() ([]byte, []int) {
	return fileDescriptor_78b27e6f04f44c6e, []int{65}
}
func (m *StoreStats) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *StoreStats) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_StoreStats.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *StoreStats) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StoreStats.Merge(m, src)
}
func (m *StoreStats) XXX_Size() int {
	return m.Size()
}
func (m *StoreStats) XXX_DiscardUnknown() {
	xxx_messageInfo_StoreStats.DiscardUnknown(m)
}

var xxx_messageInfo_StoreStats proto.InternalMessageInfo

func (m *StoreStats) GetStoreId() uint64 {
	if m != nil {
		return m.StoreId
	}
	return 0
}

func (m *StoreStats) GetCapacity() uint64 {
	if m != nil {
		return m.Capacity
	}
	return 0
}

func (m *StoreStats) GetAvailable() uint64 {
	if m != nil {
		return m.Available
	}
	return 0
}

func (m *StoreStats) GetRegionCount() uint32 {
	if m != nil {
		return m.RegionCount
	}
	return 0
}

func (m *StoreStats) GetSendingSnapCount() uint32 {
	if m != nil {
		return m.SendingSnapCount
	}
	return 0
}

func (m *StoreStats) GetReceivingSnapCount() uint32 {
	if m != nil {
		return m.ReceivingSnapCount
	}
	return 0
}

func (m *StoreStats) GetStartTime() uint32 {
	if m != nil {
		return m.StartTime
	}
	return 0
}

func (m *StoreStats) GetApplyingSnapCount() uint32 {
	if m != nil {
		return m.ApplyingSnapCount
	}
	return 0
}

func (m *StoreStats) GetIsBusy() bool {
	if m != nil {
		return m.IsBusy
	}
	return false
}

func (m *StoreStats) GetUsedSize() uint64 {
	if m != nil {
		return m.UsedSize
	}
	return 0
}

func (m *StoreStats) GetBytesWritten() uint64 {
	if m != nil {
		return m.BytesWritten
	}
	return 0
}

func (m *StoreStats) GetKeysWritten() uint64 {
	if m != nil {
		return m.KeysWritten
	}
	return 0
}

func (m *StoreStats) GetBytesRead() uint64 {
	if m != nil {
		return m.BytesRead
	}
	return 0
}

func (m *StoreStats) GetKeysRead() uint64 {
	if m != nil {
		return m.KeysRead
	}
	return 0
}

func (m *StoreStats) GetInterval() *TimeInterval {
	if m != nil {
		return m.Interval
	}
	return nil
}

func (m *StoreStats) GetCpuUsages() []*RecordPair {
	if m != nil {
		return m.CpuUsages
	}
	return nil
}

func (m *StoreStats) GetReadIoRates() []*RecordPair {
	if m != nil {
		return m.ReadIoRates
	}
	return nil
}

func (m *StoreStats) GetWriteIoRates() []*RecordPair {
	if m != nil {
		return m.WriteIoRates
	}
	return nil
}

func (m *StoreStats) GetOpLatencies() []*RecordPair {
	if m != nil {
		return m.OpLatencies
	}
	return nil
}

func (m *StoreStats) GetPeerStats() []*PeerStat {
	if m != nil {
		return m.PeerStats
	}
	return nil
}

func (m *StoreStats) GetQueryStats() *QueryStats {
	if m != nil {
		return m.QueryStats
	}
	return nil
}

func (m *StoreStats) GetSlowScore() uint64 {
	if m != nil {
		return m.SlowScore
	}
	return 0
}

func (m *StoreStats) GetDamagedRegionsId() []uint64 {
	if m != nil {
		return m.DamagedRegionsId
	}
	return nil
}

func (m *StoreStats) GetIsApplyBusy() bool {
	if m != nil {
		return m.IsApplyBusy
	}
	return false
}

func (m *StoreStats) GetSnapshotStats() []*SnapshotStat {
	if m != nil {
		return m.SnapshotStats
	}
	return nil
}

func (m *StoreStats) GetSlowTrend() *SlowTrend {
	if m != nil {
		return m.SlowTrend
	}
	return nil
}

type SlowTrend struct {
	CauseValue           float64  `protobuf:"fixed64,1,opt,name=cause_value,json=causeValue,proto3" json:"cause_value,omitempty"`
	CauseRate            float64  `protobuf:"fixed64,2,opt,name=cause_rate,json=causeRate,proto3" json:"cause_rate,omitempty"`
	ResultValue          float64  `protobuf:"fixed64,3,opt,name=result_value,json=resultValue,proto3" json:"result_value,omitempty"`
	ResultRate           float64  `protobuf:"fixed64,4,opt,name=result_rate,json=resultRate,proto3" json:"result_rate,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *SlowTrend) Reset()         { *m = SlowTrend{} }
func (m *SlowTrend) String() string { return proto.CompactTextString(m) }
func (*SlowTrend) ProtoMessage()    {}
func (*SlowTrend) Descriptor() ([]byte, []int) {
	return fileDescriptor_78b27e6f04f44c6e, []int{66}
}
func (m *SlowTrend) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SlowTrend) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SlowTrend.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SlowTrend) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SlowTrend.Merge(m, src)
}
func (m *SlowTrend) XXX_Size() int {
	return m.Size()
}
func (m *SlowTrend) XXX_DiscardUnknown() {
	xxx_messageInfo_SlowTrend.DiscardUnknown(m)
}

var xxx_messageInfo_SlowTrend proto.InternalMessageInfo

func (m *SlowTrend) GetCauseValue() float64 {
	if m != nil {
		return m.CauseValue
	}
	return 0
}

func (m *SlowTrend) GetCauseRate() float64 {
	if m != nil {
		return m.CauseRate
	}
	return 0
}

func (m *SlowTrend) GetResultValue() float64 {
	if m != nil {
		return m.ResultValue
	}
	return 0
}

func (m *SlowTrend) GetResultRate() float64 {
	if m != nil {
		return m.ResultRate
	}
	return 0
}

type SnapshotStat struct {
	RegionId uint64 `protobuf:"varint,1,opt,name=region_id,json=regionId,proto3" json:"region_id,omitempty"`
	// Generate snapshot duration
	GenerateDurationSec uint64 `protobuf:"varint,2,opt,name=generate_duration_sec,json=generateDurationSec,proto3" json:"generate_duration_sec,omitempty"`
	// Send snapshot duration
	SendDurationSec uint64 `protobuf:"varint,3,opt,name=send_duration_sec,json=sendDurationSec,proto3" json:"send_duration_sec,omitempty"`
	// |-- waiting --|-- generate ---- send --|
	// |-----------total duration---------------|
	// Total duration include waiting and executing duration
	TotalDurationSec uint64 `protobuf:"varint,4,opt,name=total_duration_sec,json=totalDurationSec,proto3" json:"total_duration_sec,omitempty"`
	// Size is the transport data size
	TransportSize        uint64   `protobuf:"varint,5,opt,name=transport_size,json=transportSize,proto3" json:"transport_size,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *SnapshotStat) Reset()         { *m = SnapshotStat{} }
func (m *SnapshotStat) String() string { return proto.CompactTextString(m) }
func (*SnapshotStat) ProtoMessage()    {}
func (*SnapshotStat) Descriptor() ([]byte, []int) {
	return fileDescriptor_78b27e6f04f44c6e, []int{67}
}
func (m *SnapshotStat) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SnapshotStat) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SnapshotStat.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SnapshotStat) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SnapshotStat.Merge(m, src)
}
func (m *SnapshotStat) XXX_Size() int {
	return m.Size()
}
func (m *SnapshotStat) XXX_DiscardUnknown() {
	xxx_messageInfo_SnapshotStat.DiscardUnknown(m)
}

var xxx_messageInfo_SnapshotStat proto.InternalMessageInfo

func (m *SnapshotStat) GetRegionId() uint64 {
	if m != nil {
		return m.RegionId
	}
	return 0
}

func (m *SnapshotStat) GetGenerateDurationSec() uint64 {
	if m != nil {
		return m.GenerateDurationSec
	}
	return 0
}

func (m *SnapshotStat) GetSendDurationSec() uint64 {
	if m != nil {
		return m.SendDurationSec
	}
	return 0
}

func (m *SnapshotStat) GetTotalDurationSec() uint64 {
	if m != nil {
		return m.TotalDurationSec
	}
	return 0
}

func (m *SnapshotStat) GetTransportSize() uint64 {
	if m != nil {
		return m.TransportSize
	}
	return 0
}

type PeerReport struct {
	RaftState     *raft_serverpb.RaftLocalState   `protobuf:"bytes,1,opt,name=raft_state,json=raftState,proto3" json:"raft_state,omitempty"`
	RegionState   *raft_serverpb.RegionLocalState `protobuf:"bytes,2,opt,name=region_state,json=regionState,proto3" json:"region_state,omitempty"`
	IsForceLeader bool                            `protobuf:"varint,3,opt,name=is_force_leader,json=isForceLeader,proto3" json:"is_force_leader,omitempty"`
	// The peer has proposed but uncommitted commit merge.
	HasCommitMerge       bool     `protobuf:"varint,4,opt,name=has_commit_merge,json=hasCommitMerge,proto3" json:"has_commit_merge,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *PeerReport) Reset()         { *m = PeerReport{} }
func (m *PeerReport) String() string { return proto.CompactTextString(m) }
func (*PeerReport) ProtoMessage()    {}
func (*PeerReport) Descriptor() ([]byte, []int) {
	return fileDescriptor_78b27e6f04f44c6e, []int{68}
}
func (m *PeerReport) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PeerReport) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PeerReport.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PeerReport) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PeerReport.Merge(m, src)
}
func (m *PeerReport) XXX_Size() int {
	return m.Size()
}
func (m *PeerReport) XXX_DiscardUnknown() {
	xxx_messageInfo_PeerReport.DiscardUnknown(m)
}

var xxx_messageInfo_PeerReport proto.InternalMessageInfo

func (m *PeerReport) GetRaftState() *raft_serverpb.RaftLocalState {
	if m != nil {
		return m.RaftState
	}
	return nil
}

func (m *PeerReport) GetRegionState() *raft_serverpb.RegionLocalState {
	if m != nil {
		return m.RegionState
	}
	return nil
}

func (m *PeerReport) GetIsForceLeader() bool {
	if m != nil {
		return m.IsForceLeader
	}
	return false
}

func (m *PeerReport) GetHasCommitMerge() bool {
	if m != nil {
		return m.HasCommitMerge
	}
	return false
}

type StoreReport struct {
	PeerReports          []*PeerReport `protobuf:"bytes,1,rep,name=peer_reports,json=peerReports,proto3" json:"peer_reports,omitempty"`
	Step                 uint64        `protobuf:"varint,2,opt,name=step,proto3" json:"step,omitempty"`
	XXX_NoUnkeyedLiteral struct{}      `json:"-"`
	XXX_unrecognized     []byte        `json:"-"`
	XXX_sizecache        int32         `json:"-"`
}

func (m *StoreReport) Reset()         { *m = StoreReport{} }
func (m *StoreReport) String() string { return proto.CompactTextString(m) }
func (*StoreReport) ProtoMessage()    {}
func (*StoreReport) Descriptor() ([]byte, []int) {
	return fileDescriptor_78b27e6f04f44c6e, []int{69}
}
func (m *StoreReport) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *StoreReport) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_StoreReport.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *StoreReport) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StoreReport.Merge(m, src)
}
func (m *StoreReport) XXX_Size() int {
	return m.Size()
}
func (m *StoreReport) XXX_DiscardUnknown() {
	xxx_messageInfo_StoreReport.DiscardUnknown(m)
}

var xxx_messageInfo_StoreReport proto.InternalMessageInfo

func (m *StoreReport) GetPeerReports() []*PeerReport {
	if m != nil {
		return m.PeerReports
	}
	return nil
}

func (m *StoreReport) GetStep() uint64 {
	if m != nil {
		return m.Step
	}
	return 0
}

type StoreHeartbeatRequest struct {
	Header *RequestHeader `protobuf:"bytes,1,opt,name=header,proto3" json:"header,omitempty"`
	Stats  *StoreStats    `protobuf:"bytes,2,opt,name=stats,proto3" json:"stats,omitempty"`
	// Detailed store report that is only filled up on PD's demand for online unsafe recovery.
	StoreReport          *StoreReport                              `protobuf:"bytes,3,opt,name=store_report,json=storeReport,proto3" json:"store_report,omitempty"`
	DrAutosyncStatus     *replication_modepb.StoreDRAutoSyncStatus `protobuf:"bytes,4,opt,name=dr_autosync_status,json=drAutosyncStatus,proto3" json:"dr_autosync_status,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                                  `json:"-"`
	XXX_unrecognized     []byte                                    `json:"-"`
	XXX_sizecache        int32                                     `json:"-"`
}

func (m *StoreHeartbeatRequest) Reset()         { *m = StoreHeartbeatRequest{} }
func (m *StoreHeartbeatRequest) String() string { return proto.CompactTextString(m) }
func (*StoreHeartbeatRequest) ProtoMessage()    {}
func (*StoreHeartbeatRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_78b27e6f04f44c6e, []int{70}
}
func (m *StoreHeartbeatRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *StoreHeartbeatRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_StoreHeartbeatRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *StoreHeartbeatRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StoreHeartbeatRequest.Merge(m, src)
}
func (m *StoreHeartbeatRequest) XXX_Size() int {
	return m.Size()
}
func (m *StoreHeartbeatRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_StoreHeartbeatRequest.DiscardUnknown(m)
}

var xxx_messageInfo_StoreHeartbeatRequest proto.InternalMessageInfo

func (m *StoreHeartbeatRequest) GetHeader() *RequestHeader {
	if m != nil {
		return m.Header
	}
	return nil
}

func (m *StoreHeartbeatRequest) GetStats() *StoreStats {
	if m != nil {
		return m.Stats
	}
	return nil
}

func (m *StoreHeartbeatRequest) GetStoreReport() *StoreReport {
	if m != nil {
		return m.StoreReport
	}
	return nil
}

func (m *StoreHeartbeatRequest) GetDrAutosyncStatus() *replication_modepb.StoreDRAutoSyncStatus {
	if m != nil {
		return m.DrAutosyncStatus
	}
	return nil
}

type DemoteFailedVoters struct {
	RegionId             uint64         `protobuf:"varint,1,opt,name=region_id,json=regionId,proto3" json:"region_id,omitempty"`
	FailedVoters         []*metapb.Peer `protobuf:"bytes,2,rep,name=failed_voters,json=failedVoters,proto3" json:"failed_voters,omitempty"`
	XXX_NoUnkeyedLiteral struct{}       `json:"-"`
	XXX_unrecognized     []byte         `json:"-"`
	XXX_sizecache        int32          `json:"-"`
}

func (m *DemoteFailedVoters) Reset()         { *m = DemoteFailedVoters{} }
func (m *DemoteFailedVoters) String() string { return proto.CompactTextString(m) }
func (*DemoteFailedVoters) ProtoMessage()    {}
func (*DemoteFailedVoters) Descriptor() ([]byte, []int) {
	return fileDescriptor_78b27e6f04f44c6e, []int{71}
}
func (m *DemoteFailedVoters) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DemoteFailedVoters) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DemoteFailedVoters.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DemoteFailedVoters) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DemoteFailedVoters.Merge(m, src)
}
func (m *DemoteFailedVoters) XXX_Size() int {
	return m.Size()
}
func (m *DemoteFailedVoters) XXX_DiscardUnknown() {
	xxx_messageInfo_DemoteFailedVoters.DiscardUnknown(m)
}

var xxx_messageInfo_DemoteFailedVoters proto.InternalMessageInfo

func (m *DemoteFailedVoters) GetRegionId() uint64 {
	if m != nil {
		return m.RegionId
	}
	return 0
}

func (m *DemoteFailedVoters) GetFailedVoters() []*metapb.Peer {
	if m != nil {
		return m.FailedVoters
	}
	return nil
}

type ForceLeader struct {
	// The store ids of the failed stores, TiKV uses it to decide if a peer is alive.
	FailedStores []uint64 `protobuf:"varint,1,rep,packed,name=failed_stores,json=failedStores,proto3" json:"failed_stores,omitempty"`
	// The region ids of the peer which is to be force leader.
	EnterForceLeaders    []uint64 `protobuf:"varint,2,rep,packed,name=enter_force_leaders,json=enterForceLeaders,proto3" json:"enter_force_leaders,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ForceLeader) Reset()         { *m = ForceLeader{} }
func (m *ForceLeader) String() string { return proto.CompactTextString(m) }
func (*ForceLeader) ProtoMessage()    {}
func (*ForceLeader) Descriptor() ([]byte, []int) {
	return fileDescriptor_78b27e6f04f44c6e, []int{72}
}
func (m *ForceLeader) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ForceLeader) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ForceLeader.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ForceLeader) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ForceLeader.Merge(m, src)
}
func (m *ForceLeader) XXX_Size() int {
	return m.Size()
}
func (m *ForceLeader) XXX_DiscardUnknown() {
	xxx_messageInfo_ForceLeader.DiscardUnknown(m)
}

var xxx_messageInfo_ForceLeader proto.InternalMessageInfo

func (m *ForceLeader) GetFailedStores() []uint64 {
	if m != nil {
		return m.FailedStores
	}
	return nil
}

func (m *ForceLeader) GetEnterForceLeaders() []uint64 {
	if m != nil {
		return m.EnterForceLeaders
	}
	return nil
}

type RecoveryPlan struct {
	// Create empty regions to fill the key range hole.
	Creates []*metapb.Region `protobuf:"bytes,1,rep,name=creates,proto3" json:"creates,omitempty"`
	// Update the meta of the regions, including peer lists, epoch and key range.
	Updates []*metapb.Region `protobuf:"bytes,2,rep,name=updates,proto3" json:"updates,omitempty"` // Deprecated: Do not use.
	// Tombstone the peers on the store locally.
	Tombstones []uint64 `protobuf:"varint,3,rep,packed,name=tombstones,proto3" json:"tombstones,omitempty"`
	// Issue conf change that demote voters on failed stores to learners on the regions.
	Demotes []*DemoteFailedVoters `protobuf:"bytes,4,rep,name=demotes,proto3" json:"demotes,omitempty"`
	// Make the peers to be force leaders.
	ForceLeader *ForceLeader `protobuf:"bytes,5,opt,name=force_leader,json=forceLeader,proto3" json:"force_leader,omitempty"`
	// Step is an increasing number to note the round of recovery,
	// It should be filled in the corresponding store report.
	Step                 uint64   `protobuf:"varint,6,opt,name=step,proto3" json:"step,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *RecoveryPlan) Reset()         { *m = RecoveryPlan{} }
func (m *RecoveryPlan) String() string { return proto.CompactTextString(m) }
func (*RecoveryPlan) ProtoMessage()    {}
func (*RecoveryPlan) Descriptor() ([]byte, []int) {
	return fileDescriptor_78b27e6f04f44c6e, []int{73}
}
func (m *RecoveryPlan) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RecoveryPlan) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RecoveryPlan.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RecoveryPlan) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RecoveryPlan.Merge(m, src)
}
func (m *RecoveryPlan) XXX_Size() int {
	return m.Size()
}
func (m *RecoveryPlan) XXX_DiscardUnknown() {
	xxx_messageInfo_RecoveryPlan.DiscardUnknown(m)
}

var xxx_messageInfo_RecoveryPlan proto.InternalMessageInfo

func (m *RecoveryPlan) GetCreates() []*metapb.Region {
	if m != nil {
		return m.Creates
	}
	return nil
}

// Deprecated: Do not use.
func (m *RecoveryPlan) GetUpdates() []*metapb.Region {
	if m != nil {
		return m.Updates
	}
	return nil
}

func (m *RecoveryPlan) GetTombstones() []uint64 {
	if m != nil {
		return m.Tombstones
	}
	return nil
}

func (m *RecoveryPlan) GetDemotes() []*DemoteFailedVoters {
	if m != nil {
		return m.Demotes
	}
	return nil
}

func (m *RecoveryPlan) GetForceLeader() *ForceLeader {
	if m != nil {
		return m.ForceLeader
	}
	return nil
}

func (m *RecoveryPlan) GetStep() uint64 {
	if m != nil {
		return m.Step
	}
	return 0
}

type AwakenRegions struct {
	// Awake all regions if abnormal_stores is empty.
	AbnormalStores       []uint64 `protobuf:"varint,1,rep,packed,name=abnormal_stores,json=abnormalStores,proto3" json:"abnormal_stores,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *AwakenRegions) Reset()         { *m = AwakenRegions{} }
func (m *AwakenRegions) String() string { return proto.CompactTextString(m) }
func (*AwakenRegions) ProtoMessage()    {}
func (*AwakenRegions) Descriptor() ([]byte, []int) {
	return fileDescriptor_78b27e6f04f44c6e, []int{74}
}
func (m *AwakenRegions) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AwakenRegions) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AwakenRegions.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AwakenRegions) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AwakenRegions.Merge(m, src)
}
func (m *AwakenRegions) XXX_Size() int {
	return m.Size()
}
func (m *AwakenRegions) XXX_DiscardUnknown() {
	xxx_messageInfo_AwakenRegions.DiscardUnknown(m)
}

var xxx_messageInfo_AwakenRegions proto.InternalMessageInfo

func (m *AwakenRegions) GetAbnormalStores() []uint64 {
	if m != nil {
		return m.AbnormalStores
	}
	return nil
}

type StoreHeartbeatResponse struct {
	Header            *ResponseHeader                       `protobuf:"bytes,1,opt,name=header,proto3" json:"header,omitempty"`
	ReplicationStatus *replication_modepb.ReplicationStatus `protobuf:"bytes,2,opt,name=replication_status,json=replicationStatus,proto3" json:"replication_status,omitempty"`
	ClusterVersion    string                                `protobuf:"bytes,3,opt,name=cluster_version,json=clusterVersion,proto3" json:"cluster_version,omitempty"`
	// Used by online unsafe recovery to request store report.
	// Now it's substituted by reusing recovery_plan field. PD will send a empty
	// recovery plan instead to request store report.
	RequireDetailedReport bool `protobuf:"varint,4,opt,name=require_detailed_report,json=requireDetailedReport,proto3" json:"require_detailed_report,omitempty"` // Deprecated: Do not use.
	// Operations of recovery. After the plan is executed, TiKV should attach the
	// store report in store heartbeat.
	RecoveryPlan *RecoveryPlan `protobuf:"bytes,5,opt,name=recovery_plan,json=recoveryPlan,proto3" json:"recovery_plan,omitempty"`
	// Pd can return awaken_regions to let TiKV awaken hibernated regions itself.
	AwakenRegions        *AwakenRegions `protobuf:"bytes,6,opt,name=awaken_regions,json=awakenRegions,proto3" json:"awaken_regions,omitempty"`
	XXX_NoUnkeyedLiteral struct{}       `json:"-"`
	XXX_unrecognized     []byte         `json:"-"`
	XXX_sizecache        int32          `json:"-"`
}

func (m *StoreHeartbeatResponse) Reset()         { *m = StoreHeartbeatResponse{} }
func (m *StoreHeartbeatResponse) String() string { return proto.CompactTextString(m) }
func (*StoreHeartbeatResponse) ProtoMessage()    {}
func (*StoreHeartbeatResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_78b27e6f04f44c6e, []int{75}
}
func (m *StoreHeartbeatResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *StoreHeartbeatResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_StoreHeartbeatResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *StoreHeartbeatResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StoreHeartbeatResponse.Merge(m, src)
}
func (m *StoreHeartbeatResponse) XXX_Size() int {
	return m.Size()
}
func (m *StoreHeartbeatResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_StoreHeartbeatResponse.DiscardUnknown(m)
}

var xxx_messageInfo_StoreHeartbeatResponse proto.InternalMessageInfo

func (m *StoreHeartbeatResponse) GetHeader() *ResponseHeader {
	if m != nil {
		return m.Header
	}
	return nil
}

func (m *StoreHeartbeatResponse) GetReplicationStatus() *replication_modepb.ReplicationStatus {
	if m != nil {
		return m.ReplicationStatus
	}
	return nil
}

func (m *StoreHeartbeatResponse) GetClusterVersion() string {
	if m != nil {
		return m.ClusterVersion
	}
	return ""
}

// Deprecated: Do not use.
func (m *StoreHeartbeatResponse) GetRequireDetailedReport() bool {
	if m != nil {
		return m.RequireDetailedReport
	}
	return false
}

func (m *StoreHeartbeatResponse) GetRecoveryPlan() *RecoveryPlan {
	if m != nil {
		return m.RecoveryPlan
	}
	return nil
}

func (m *StoreHeartbeatResponse) GetAwakenRegions() *AwakenRegions {
	if m != nil {
		return m.AwakenRegions
	}
	return nil
}

type ScatterRegionRequest struct {
	Header   *RequestHeader `protobuf:"bytes,1,opt,name=header,proto3" json:"header,omitempty"`
	RegionId uint64         `protobuf:"varint,2,opt,name=region_id,json=regionId,proto3" json:"region_id,omitempty"` // Deprecated: Do not use.
	// PD will use these region information if it can't find the region.
	// For example, the region is just split and hasn't report to PD yet.
	Region *metapb.Region `protobuf:"bytes,3,opt,name=region,proto3" json:"region,omitempty"`
	Leader *metapb.Peer   `protobuf:"bytes,4,opt,name=leader,proto3" json:"leader,omitempty"`
	// If group is defined, the regions with the same group would be scattered as a whole group.
	// If not defined, the regions would be scattered in a cluster level.
	Group string `protobuf:"bytes,5,opt,name=group,proto3" json:"group,omitempty"`
	// If regions_id is defined, the region_id would be ignored.
	RegionsId            []uint64 `protobuf:"varint,6,rep,packed,name=regions_id,json=regionsId,proto3" json:"regions_id,omitempty"`
	RetryLimit           uint64   `protobuf:"varint,7,opt,name=retry_limit,json=retryLimit,proto3" json:"retry_limit,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ScatterRegionRequest) Reset()         { *m = ScatterRegionRequest{} }
func (m *ScatterRegionRequest) String() string { return proto.CompactTextString(m) }
func (*ScatterRegionRequest) ProtoMessage()    {}
func (*ScatterRegionRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_78b27e6f04f44c6e, []int{76}
}
func (m *ScatterRegionRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ScatterRegionRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ScatterRegionRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ScatterRegionRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ScatterRegionRequest.Merge(m, src)
}
func (m *ScatterRegionRequest) XXX_Size() int {
	return m.Size()
}
func (m *ScatterRegionRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ScatterRegionRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ScatterRegionRequest proto.InternalMessageInfo

func (m *ScatterRegionRequest) GetHeader() *RequestHeader {
	if m != nil {
		return m.Header
	}
	return nil
}

// Deprecated: Do not use.
func (m *ScatterRegionRequest) GetRegionId() uint64 {
	if m != nil {
		return m.RegionId
	}
	return 0
}

func (m *ScatterRegionRequest) GetRegion() *metapb.Region {
	if m != nil {
		return m.Region
	}
	return nil
}

func (m *ScatterRegionRequest) GetLeader() *metapb.Peer {
	if m != nil {
		return m.Leader
	}
	return nil
}

func (m *ScatterRegionRequest) GetGroup() string {
	if m != nil {
		return m.Group
	}
	return ""
}

func (m *ScatterRegionRequest) GetRegionsId() []uint64 {
	if m != nil {
		return m.RegionsId
	}
	return nil
}

func (m *ScatterRegionRequest) GetRetryLimit() uint64 {
	if m != nil {
		return m.RetryLimit
	}
	return 0
}

type ScatterRegionResponse struct {
	Header               *ResponseHeader `protobuf:"bytes,1,opt,name=header,proto3" json:"header,omitempty"`
	FinishedPercentage   uint64          `protobuf:"varint,2,opt,name=finished_percentage,json=finishedPercentage,proto3" json:"finished_percentage,omitempty"`
	XXX_NoUnkeyedLiteral struct{}        `json:"-"`
	XXX_unrecognized     []byte          `json:"-"`
	XXX_sizecache        int32           `json:"-"`
}

func (m *ScatterRegionResponse) Reset()         { *m = ScatterRegionResponse{} }
func (m *ScatterRegionResponse) String() string { return proto.CompactTextString(m) }
func (*ScatterRegionResponse) ProtoMessage()    {}
func (*ScatterRegionResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_78b27e6f04f44c6e, []int{77}
}
func (m *ScatterRegionResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ScatterRegionResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ScatterRegionResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ScatterRegionResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ScatterRegionResponse.Merge(m, src)
}
func (m *ScatterRegionResponse) XXX_Size() int {
	return m.Size()
}
func (m *ScatterRegionResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_ScatterRegionResponse.DiscardUnknown(m)
}

var xxx_messageInfo_ScatterRegionResponse proto.InternalMessageInfo

func (m *ScatterRegionResponse) GetHeader() *ResponseHeader {
	if m != nil {
		return m.Header
	}
	return nil
}

func (m *ScatterRegionResponse) GetFinishedPercentage() uint64 {
	if m != nil {
		return m.FinishedPercentage
	}
	return 0
}

type GetGCSafePointRequest struct {
	Header               *RequestHeader `protobuf:"bytes,1,opt,name=header,proto3" json:"header,omitempty"`
	XXX_NoUnkeyedLiteral struct{}       `json:"-"`
	XXX_unrecognized     []byte         `json:"-"`
	XXX_sizecache        int32          `json:"-"`
}

func (m *GetGCSafePointRequest) Reset()         { *m = GetGCSafePointRequest{} }
func (m *GetGCSafePointRequest) String() string { return proto.CompactTextString(m) }
func (*GetGCSafePointRequest) ProtoMessage()    {}
func (*GetGCSafePointRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_78b27e6f04f44c6e, []int{78}
}
func (m *GetGCSafePointRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetGCSafePointRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetGCSafePointRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetGCSafePointRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetGCSafePointRequest.Merge(m, src)
}
func (m *GetGCSafePointRequest) XXX_Size() int {
	return m.Size()
}
func (m *GetGCSafePointRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_GetGCSafePointRequest.DiscardUnknown(m)
}

var xxx_messageInfo_GetGCSafePointRequest proto.InternalMessageInfo

func (m *GetGCSafePointRequest) GetHeader() *RequestHeader {
	if m != nil {
		return m.Header
	}
	return nil
}

type GetGCSafePointResponse struct {
	Header               *ResponseHeader `protobuf:"bytes,1,opt,name=header,proto3" json:"header,omitempty"`
	SafePoint            uint64          `protobuf:"varint,2,opt,name=safe_point,json=safePoint,proto3" json:"safe_point,omitempty"`
	XXX_NoUnkeyedLiteral struct{}        `json:"-"`
	XXX_unrecognized     []byte          `json:"-"`
	XXX_sizecache        int32           `json:"-"`
}

func (m *GetGCSafePointResponse) Reset()         { *m = GetGCSafePointResponse{} }
func (m *GetGCSafePointResponse) String() string { return proto.CompactTextString(m) }
func (*GetGCSafePointResponse) ProtoMessage()    {}
func (*GetGCSafePointResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_78b27e6f04f44c6e, []int{79}
}
func (m *GetGCSafePointResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetGCSafePointResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetGCSafePointResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetGCSafePointResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetGCSafePointResponse.Merge(m, src)
}
func (m *GetGCSafePointResponse) XXX_Size() int {
	return m.Size()
}
func (m *GetGCSafePointResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_GetGCSafePointResponse.DiscardUnknown(m)
}

var xxx_messageInfo_GetGCSafePointResponse proto.InternalMessageInfo

func (m *GetGCSafePointResponse) GetHeader() *ResponseHeader {
	if m != nil {
		return m.Header
	}
	return nil
}

func (m *GetGCSafePointResponse) GetSafePoint() uint64 {
	if m != nil {
		return m.SafePoint
	}
	return 0
}

type UpdateGCSafePointRequest struct {
	Header               *RequestHeader `protobuf:"bytes,1,opt,name=header,proto3" json:"header,omitempty"`
	SafePoint            uint64         `protobuf:"varint,2,opt,name=safe_point,json=safePoint,proto3" json:"safe_point,omitempty"`
	XXX_NoUnkeyedLiteral struct{}       `json:"-"`
	XXX_unrecognized     []byte         `json:"-"`
	XXX_sizecache        int32          `json:"-"`
}

func (m *UpdateGCSafePointRequest) Reset()         { *m = UpdateGCSafePointRequest{} }
func (m *UpdateGCSafePointRequest) String() string { return proto.CompactTextString(m) }
func (*UpdateGCSafePointRequest) ProtoMessage()    {}
func (*UpdateGCSafePointRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_78b27e6f04f44c6e, []int{80}
}
func (m *UpdateGCSafePointRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UpdateGCSafePointRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UpdateGCSafePointRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UpdateGCSafePointRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UpdateGCSafePointRequest.Merge(m, src)
}
func (m *UpdateGCSafePointRequest) XXX_Size() int {
	return m.Size()
}
func (m *UpdateGCSafePointRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_UpdateGCSafePointRequest.DiscardUnknown(m)
}

var xxx_messageInfo_UpdateGCSafePointRequest proto.InternalMessageInfo

func (m *UpdateGCSafePointRequest) GetHeader() *RequestHeader {
	if m != nil {
		return m.Header
	}
	return nil
}

func (m *UpdateGCSafePointRequest) GetSafePoint() uint64 {
	if m != nil {
		return m.SafePoint
	}
	return 0
}

type UpdateGCSafePointResponse struct {
	Header               *ResponseHeader `protobuf:"bytes,1,opt,name=header,proto3" json:"header,omitempty"`
	NewSafePoint         uint64          `protobuf:"varint,2,opt,name=new_safe_point,json=newSafePoint,proto3" json:"new_safe_point,omitempty"`
	XXX_NoUnkeyedLiteral struct{}        `json:"-"`
	XXX_unrecognized     []byte          `json:"-"`
	XXX_sizecache        int32           `json:"-"`
}

func (m *UpdateGCSafePointResponse) Reset()         { *m = UpdateGCSafePointResponse{} }
func (m *UpdateGCSafePointResponse) String() string { return proto.CompactTextString(m) }
func (*UpdateGCSafePointResponse) ProtoMessage()    {}
func (*UpdateGCSafePointResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_78b27e6f04f44c6e, []int{81}
}
func (m *UpdateGCSafePointResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UpdateGCSafePointResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UpdateGCSafePointResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UpdateGCSafePointResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UpdateGCSafePointResponse.Merge(m, src)
}
func (m *UpdateGCSafePointResponse) XXX_Size() int {
	return m.Size()
}
func (m *UpdateGCSafePointResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_UpdateGCSafePointResponse.DiscardUnknown(m)
}

var xxx_messageInfo_UpdateGCSafePointResponse proto.InternalMessageInfo

func (m *UpdateGCSafePointResponse) GetHeader() *ResponseHeader {
	if m != nil {
		return m.Header
	}
	return nil
}

func (m *UpdateGCSafePointResponse) GetNewSafePoint() uint64 {
	if m != nil {
		return m.NewSafePoint
	}
	return 0
}

type UpdateServiceGCSafePointRequest struct {
	Header               *RequestHeader `protobuf:"bytes,1,opt,name=header,proto3" json:"header,omitempty"`
	ServiceId            []byte         `protobuf:"bytes,2,opt,name=service_id,json=serviceId,proto3" json:"service_id,omitempty"`
	TTL                  int64          `protobuf:"varint,3,opt,name=TTL,proto3" json:"TTL,omitempty"`
	SafePoint            uint64         `protobuf:"varint,4,opt,name=safe_point,json=safePoint,proto3" json:"safe_point,omitempty"`
	XXX_NoUnkeyedLiteral struct{}       `json:"-"`
	XXX_unrecognized     []byte         `json:"-"`
	XXX_sizecache        int32          `json:"-"`
}

func (m *UpdateServiceGCSafePointRequest) Reset()         { *m = UpdateServiceGCSafePointRequest{} }
func (m *UpdateServiceGCSafePointRequest) String() string { return proto.CompactTextString(m) }
func (*UpdateServiceGCSafePointRequest) ProtoMessage()    {}
func (*UpdateServiceGCSafePointRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_78b27e6f04f44c6e, []int{82}
}
func (m *UpdateServiceGCSafePointRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UpdateServiceGCSafePointRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UpdateServiceGCSafePointRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UpdateServiceGCSafePointRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UpdateServiceGCSafePointRequest.Merge(m, src)
}
func (m *UpdateServiceGCSafePointRequest) XXX_Size() int {
	return m.Size()
}
func (m *UpdateServiceGCSafePointRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_UpdateServiceGCSafePointRequest.DiscardUnknown(m)
}

var xxx_messageInfo_UpdateServiceGCSafePointRequest proto.InternalMessageInfo

func (m *UpdateServiceGCSafePointRequest) GetHeader() *RequestHeader {
	if m != nil {
		return m.Header
	}
	return nil
}

func (m *UpdateServiceGCSafePointRequest) GetServiceId() []byte {
	if m != nil {
		return m.ServiceId
	}
	return nil
}

func (m *UpdateServiceGCSafePointRequest) GetTTL() int64 {
	if m != nil {
		return m.TTL
	}
	return 0
}

func (m *UpdateServiceGCSafePointRequest) GetSafePoint() uint64 {
	if m != nil {
		return m.SafePoint
	}
	return 0
}

type UpdateServiceGCSafePointResponse struct {
	Header               *ResponseHeader `protobuf:"bytes,1,opt,name=header,proto3" json:"header,omitempty"`
	ServiceId            []byte          `protobuf:"bytes,2,opt,name=service_id,json=serviceId,proto3" json:"service_id,omitempty"`
	TTL                  int64           `protobuf:"varint,3,opt,name=TTL,proto3" json:"TTL,omitempty"`
	MinSafePoint         uint64          `protobuf:"varint,4,opt,name=min_safe_point,json=minSafePoint,proto3" json:"min_safe_point,omitempty"`
	XXX_NoUnkeyedLiteral struct{}        `json:"-"`
	XXX_unrecognized     []byte          `json:"-"`
	XXX_sizecache        int32           `json:"-"`
}

func (m *UpdateServiceGCSafePointResponse) Reset()         { *m = UpdateServiceGCSafePointResponse{} }
func (m *UpdateServiceGCSafePointResponse) String() string { return proto.CompactTextString(m) }
func (*UpdateServiceGCSafePointResponse) ProtoMessage()    {}
func (*UpdateServiceGCSafePointResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_78b27e6f04f44c6e, []int{83}
}
func (m *UpdateServiceGCSafePointResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UpdateServiceGCSafePointResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UpdateServiceGCSafePointResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UpdateServiceGCSafePointResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UpdateServiceGCSafePointResponse.Merge(m, src)
}
func (m *UpdateServiceGCSafePointResponse) XXX_Size() int {
	return m.Size()
}
func (m *UpdateServiceGCSafePointResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_UpdateServiceGCSafePointResponse.DiscardUnknown(m)
}

var xxx_messageInfo_UpdateServiceGCSafePointResponse proto.InternalMessageInfo

func (m *UpdateServiceGCSafePointResponse) GetHeader() *ResponseHeader {
	if m != nil {
		return m.Header
	}
	return nil
}

func (m *UpdateServiceGCSafePointResponse) GetServiceId() []byte {
	if m != nil {
		return m.ServiceId
	}
	return nil
}

func (m *UpdateServiceGCSafePointResponse) GetTTL() int64 {
	if m != nil {
		return m.TTL
	}
	return 0
}

func (m *UpdateServiceGCSafePointResponse) GetMinSafePoint() uint64 {
	if m != nil {
		return m.MinSafePoint
	}
	return 0
}

type RegionStat struct {
	// Bytes read/written during this period.
	BytesWritten uint64 `protobuf:"varint,1,opt,name=bytes_written,json=bytesWritten,proto3" json:"bytes_written,omitempty"`
	BytesRead    uint64 `protobuf:"varint,2,opt,name=bytes_read,json=bytesRead,proto3" json:"bytes_read,omitempty"`
	// Keys read/written during this period.
	KeysWritten          uint64   `protobuf:"varint,3,opt,name=keys_written,json=keysWritten,proto3" json:"keys_written,omitempty"`
	KeysRead             uint64   `protobuf:"varint,4,opt,name=keys_read,json=keysRead,proto3" json:"keys_read,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *RegionStat) Reset()         { *m = RegionStat{} }
func (m *RegionStat) String() string { return proto.CompactTextString(m) }
func (*RegionStat) ProtoMessage()    {}
func (*RegionStat) Descriptor() ([]byte, []int) {
	return fileDescriptor_78b27e6f04f44c6e, []int{84}
}
func (m *RegionStat) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RegionStat) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RegionStat.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RegionStat) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RegionStat.Merge(m, src)
}
func (m *RegionStat) XXX_Size() int {
	return m.Size()
}
func (m *RegionStat) XXX_DiscardUnknown() {
	xxx_messageInfo_RegionStat.DiscardUnknown(m)
}

var xxx_messageInfo_RegionStat proto.InternalMessageInfo

func (m *RegionStat) GetBytesWritten() uint64 {
	if m != nil {
		return m.BytesWritten
	}
	return 0
}

func (m *RegionStat) GetBytesRead() uint64 {
	if m != nil {
		return m.BytesRead
	}
	return 0
}

func (m *RegionStat) GetKeysWritten() uint64 {
	if m != nil {
		return m.KeysWritten
	}
	return 0
}

func (m *RegionStat) GetKeysRead() uint64 {
	if m != nil {
		return m.KeysRead
	}
	return 0
}

type SyncRegionRequest struct {
	Header *RequestHeader `protobuf:"bytes,1,opt,name=header,proto3" json:"header,omitempty"`
	Member *Member        `protobuf:"bytes,2,opt,name=member,proto3" json:"member,omitempty"`
	// the follower PD will use the start index to locate historical changes
	// that require synchronization.
	StartIndex           uint64   `protobuf:"varint,3,opt,name=start_index,json=startIndex,proto3" json:"start_index,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *SyncRegionRequest) Reset()         { *m = SyncRegionRequest{} }
func (m *SyncRegionRequest) String() string { return proto.CompactTextString(m) }
func (*SyncRegionRequest) ProtoMessage()    {}
func (*SyncRegionRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_78b27e6f04f44c6e, []int{85}
}
func (m *SyncRegionRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SyncRegionRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SyncRegionRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SyncRegionRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SyncRegionRequest.Merge(m, src)
}
func (m *SyncRegionRequest) XXX_Size() int {
	return m.Size()
}
func (m *SyncRegionRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_SyncRegionRequest.DiscardUnknown(m)
}

var xxx_messageInfo_SyncRegionRequest proto.InternalMessageInfo

func (m *SyncRegionRequest) GetHeader() *RequestHeader {
	if m != nil {
		return m.Header
	}
	return nil
}

func (m *SyncRegionRequest) GetMember() *Member {
	if m != nil {
		return m.Member
	}
	return nil
}

func (m *SyncRegionRequest) GetStartIndex() uint64 {
	if m != nil {
		return m.StartIndex
	}
	return 0
}

type SyncRegionResponse struct {
	Header *ResponseHeader `protobuf:"bytes,1,opt,name=header,proto3" json:"header,omitempty"`
	// the leader PD will send the repsonds include
	// changed regions records and the index of the first record.
	Regions       []*metapb.Region `protobuf:"bytes,2,rep,name=regions,proto3" json:"regions,omitempty"`
	StartIndex    uint64           `protobuf:"varint,3,opt,name=start_index,json=startIndex,proto3" json:"start_index,omitempty"`
	RegionStats   []*RegionStat    `protobuf:"bytes,4,rep,name=region_stats,json=regionStats,proto3" json:"region_stats,omitempty"`
	RegionLeaders []*metapb.Peer   `protobuf:"bytes,5,rep,name=region_leaders,json=regionLeaders,proto3" json:"region_leaders,omitempty"`
	// the buckets informations without stats.
	Buckets              []*metapb.Buckets `protobuf:"bytes,6,rep,name=buckets,proto3" json:"buckets,omitempty"`
	XXX_NoUnkeyedLiteral struct{}          `json:"-"`
	XXX_unrecognized     []byte            `json:"-"`
	XXX_sizecache        int32             `json:"-"`
}

func (m *SyncRegionResponse) Reset()         { *m = SyncRegionResponse{} }
func (m *SyncRegionResponse) String() string { return proto.CompactTextString(m) }
func (*SyncRegionResponse) ProtoMessage()    {}
func (*SyncRegionResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_78b27e6f04f44c6e, []int{86}
}
func (m *SyncRegionResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SyncRegionResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SyncRegionResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SyncRegionResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SyncRegionResponse.Merge(m, src)
}
func (m *SyncRegionResponse) XXX_Size() int {
	return m.Size()
}
func (m *SyncRegionResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_SyncRegionResponse.DiscardUnknown(m)
}

var xxx_messageInfo_SyncRegionResponse proto.InternalMessageInfo

func (m *SyncRegionResponse) GetHeader() *ResponseHeader {
	if m != nil {
		return m.Header
	}
	return nil
}

func (m *SyncRegionResponse) GetRegions() []*metapb.Region {
	if m != nil {
		return m.Regions
	}
	return nil
}

func (m *SyncRegionResponse) GetStartIndex() uint64 {
	if m != nil {
		return m.StartIndex
	}
	return 0
}

func (m *SyncRegionResponse) GetRegionStats() []*RegionStat {
	if m != nil {
		return m.RegionStats
	}
	return nil
}

func (m *SyncRegionResponse) GetRegionLeaders() []*metapb.Peer {
	if m != nil {
		return m.RegionLeaders
	}
	return nil
}

func (m *SyncRegionResponse) GetBuckets() []*metapb.Buckets {
	if m != nil {
		return m.Buckets
	}
	return nil
}

type GetOperatorRequest struct {
	Header               *RequestHeader `protobuf:"bytes,1,opt,name=header,proto3" json:"header,omitempty"`
	RegionId             uint64         `protobuf:"varint,2,opt,name=region_id,json=regionId,proto3" json:"region_id,omitempty"`
	XXX_NoUnkeyedLiteral struct{}       `json:"-"`
	XXX_unrecognized     []byte         `json:"-"`
	XXX_sizecache        int32          `json:"-"`
}

func (m *GetOperatorRequest) Reset()         { *m = GetOperatorRequest{} }
func (m *GetOperatorRequest) String() string { return proto.CompactTextString(m) }
func (*GetOperatorRequest) ProtoMessage()    {}
func (*GetOperatorRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_78b27e6f04f44c6e, []int{87}
}
func (m *GetOperatorRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetOperatorRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetOperatorRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetOperatorRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetOperatorRequest.Merge(m, src)
}
func (m *GetOperatorRequest) XXX_Size() int {
	return m.Size()
}
func (m *GetOperatorRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_GetOperatorRequest.DiscardUnknown(m)
}

var xxx_messageInfo_GetOperatorRequest proto.InternalMessageInfo

func (m *GetOperatorRequest) GetHeader() *RequestHeader {
	if m != nil {
		return m.Header
	}
	return nil
}

func (m *GetOperatorRequest) GetRegionId() uint64 {
	if m != nil {
		return m.RegionId
	}
	return 0
}

type GetOperatorResponse struct {
	Header               *ResponseHeader `protobuf:"bytes,1,opt,name=header,proto3" json:"header,omitempty"`
	RegionId             uint64          `protobuf:"varint,2,opt,name=region_id,json=regionId,proto3" json:"region_id,omitempty"`
	Desc                 []byte          `protobuf:"bytes,3,opt,name=desc,proto3" json:"desc,omitempty"`
	Status               OperatorStatus  `protobuf:"varint,4,opt,name=status,proto3,enum=pdpb.OperatorStatus" json:"status,omitempty"`
	Kind                 []byte          `protobuf:"bytes,5,opt,name=kind,proto3" json:"kind,omitempty"`
	XXX_NoUnkeyedLiteral struct{}        `json:"-"`
	XXX_unrecognized     []byte          `json:"-"`
	XXX_sizecache        int32           `json:"-"`
}

func (m *GetOperatorResponse) Reset()         { *m = GetOperatorResponse{} }
func (m *GetOperatorResponse) String() string { return proto.CompactTextString(m) }
func (*GetOperatorResponse) ProtoMessage()    {}
func (*GetOperatorResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_78b27e6f04f44c6e, []int{88}
}
func (m *GetOperatorResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetOperatorResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetOperatorResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetOperatorResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetOperatorResponse.Merge(m, src)
}
func (m *GetOperatorResponse) XXX_Size() int {
	return m.Size()
}
func (m *GetOperatorResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_GetOperatorResponse.DiscardUnknown(m)
}

var xxx_messageInfo_GetOperatorResponse proto.InternalMessageInfo

func (m *GetOperatorResponse) GetHeader() *ResponseHeader {
	if m != nil {
		return m.Header
	}
	return nil
}

func (m *GetOperatorResponse) GetRegionId() uint64 {
	if m != nil {
		return m.RegionId
	}
	return 0
}

func (m *GetOperatorResponse) GetDesc() []byte {
	if m != nil {
		return m.Desc
	}
	return nil
}

func (m *GetOperatorResponse) GetStatus() OperatorStatus {
	if m != nil {
		return m.Status
	}
	return OperatorStatus_SUCCESS
}

func (m *GetOperatorResponse) GetKind() []byte {
	if m != nil {
		return m.Kind
	}
	return nil
}

type SyncMaxTSRequest struct {
	Header *RequestHeader `protobuf:"bytes,1,opt,name=header,proto3" json:"header,omitempty"`
	MaxTs  *Timestamp     `protobuf:"bytes,2,opt,name=max_ts,json=maxTs,proto3" json:"max_ts,omitempty"`
	// If skip_check is true, the sync will try to write the max_ts without checking whether it's bigger.
	SkipCheck            bool     `protobuf:"varint,3,opt,name=skip_check,json=skipCheck,proto3" json:"skip_check,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *SyncMaxTSRequest) Reset()         { *m = SyncMaxTSRequest{} }
func (m *SyncMaxTSRequest) String() string { return proto.CompactTextString(m) }
func (*SyncMaxTSRequest) ProtoMessage()    {}
func (*SyncMaxTSRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_78b27e6f04f44c6e, []int{89}
}
func (m *SyncMaxTSRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SyncMaxTSRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SyncMaxTSRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SyncMaxTSRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SyncMaxTSRequest.Merge(m, src)
}
func (m *SyncMaxTSRequest) XXX_Size() int {
	return m.Size()
}
func (m *SyncMaxTSRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_SyncMaxTSRequest.DiscardUnknown(m)
}

var xxx_messageInfo_SyncMaxTSRequest proto.InternalMessageInfo

func (m *SyncMaxTSRequest) GetHeader() *RequestHeader {
	if m != nil {
		return m.Header
	}
	return nil
}

func (m *SyncMaxTSRequest) GetMaxTs() *Timestamp {
	if m != nil {
		return m.MaxTs
	}
	return nil
}

func (m *SyncMaxTSRequest) GetSkipCheck() bool {
	if m != nil {
		return m.SkipCheck
	}
	return false
}

type SyncMaxTSResponse struct {
	Header               *ResponseHeader `protobuf:"bytes,1,opt,name=header,proto3" json:"header,omitempty"`
	MaxLocalTs           *Timestamp      `protobuf:"bytes,2,opt,name=max_local_ts,json=maxLocalTs,proto3" json:"max_local_ts,omitempty"`
	SyncedDcs            []string        `protobuf:"bytes,3,rep,name=synced_dcs,json=syncedDcs,proto3" json:"synced_dcs,omitempty"`
	XXX_NoUnkeyedLiteral struct{}        `json:"-"`
	XXX_unrecognized     []byte          `json:"-"`
	XXX_sizecache        int32           `json:"-"`
}

func (m *SyncMaxTSResponse) Reset()         { *m = SyncMaxTSResponse{} }
func (m *SyncMaxTSResponse) String() string { return proto.CompactTextString(m) }
func (*SyncMaxTSResponse) ProtoMessage()    {}
func (*SyncMaxTSResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_78b27e6f04f44c6e, []int{90}
}
func (m *SyncMaxTSResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SyncMaxTSResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SyncMaxTSResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SyncMaxTSResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SyncMaxTSResponse.Merge(m, src)
}
func (m *SyncMaxTSResponse) XXX_Size() int {
	return m.Size()
}
func (m *SyncMaxTSResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_SyncMaxTSResponse.DiscardUnknown(m)
}

var xxx_messageInfo_SyncMaxTSResponse proto.InternalMessageInfo

func (m *SyncMaxTSResponse) GetHeader() *ResponseHeader {
	if m != nil {
		return m.Header
	}
	return nil
}

func (m *SyncMaxTSResponse) GetMaxLocalTs() *Timestamp {
	if m != nil {
		return m.MaxLocalTs
	}
	return nil
}

func (m *SyncMaxTSResponse) GetSyncedDcs() []string {
	if m != nil {
		return m.SyncedDcs
	}
	return nil
}

type SplitRegionsRequest struct {
	Header               *RequestHeader `protobuf:"bytes,1,opt,name=header,proto3" json:"header,omitempty"`
	SplitKeys            [][]byte       `protobuf:"bytes,2,rep,name=split_keys,json=splitKeys,proto3" json:"split_keys,omitempty"`
	RetryLimit           uint64         `protobuf:"varint,3,opt,name=retry_limit,json=retryLimit,proto3" json:"retry_limit,omitempty"`
	XXX_NoUnkeyedLiteral struct{}       `json:"-"`
	XXX_unrecognized     []byte         `json:"-"`
	XXX_sizecache        int32          `json:"-"`
}

func (m *SplitRegionsRequest) Reset()         { *m = SplitRegionsRequest{} }
func (m *SplitRegionsRequest) String() string { return proto.CompactTextString(m) }
func (*SplitRegionsRequest) ProtoMessage()    {}
func (*SplitRegionsRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_78b27e6f04f44c6e, []int{91}
}
func (m *SplitRegionsRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SplitRegionsRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SplitRegionsRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SplitRegionsRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SplitRegionsRequest.Merge(m, src)
}
func (m *SplitRegionsRequest) XXX_Size() int {
	return m.Size()
}
func (m *SplitRegionsRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_SplitRegionsRequest.DiscardUnknown(m)
}

var xxx_messageInfo_SplitRegionsRequest proto.InternalMessageInfo

func (m *SplitRegionsRequest) GetHeader() *RequestHeader {
	if m != nil {
		return m.Header
	}
	return nil
}

func (m *SplitRegionsRequest) GetSplitKeys() [][]byte {
	if m != nil {
		return m.SplitKeys
	}
	return nil
}

func (m *SplitRegionsRequest) GetRetryLimit() uint64 {
	if m != nil {
		return m.RetryLimit
	}
	return 0
}

type SplitRegionsResponse struct {
	Header               *ResponseHeader `protobuf:"bytes,1,opt,name=header,proto3" json:"header,omitempty"`
	FinishedPercentage   uint64          `protobuf:"varint,2,opt,name=finished_percentage,json=finishedPercentage,proto3" json:"finished_percentage,omitempty"`
	RegionsId            []uint64        `protobuf:"varint,3,rep,packed,name=regions_id,json=regionsId,proto3" json:"regions_id,omitempty"`
	XXX_NoUnkeyedLiteral struct{}        `json:"-"`
	XXX_unrecognized     []byte          `json:"-"`
	XXX_sizecache        int32           `json:"-"`
}

func (m *SplitRegionsResponse) Reset()         { *m = SplitRegionsResponse{} }
func (m *SplitRegionsResponse) String() string { return proto.CompactTextString(m) }
func (*SplitRegionsResponse) ProtoMessage()    {}
func (*SplitRegionsResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_78b27e6f04f44c6e, []int{92}
}
func (m *SplitRegionsResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SplitRegionsResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SplitRegionsResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SplitRegionsResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SplitRegionsResponse.Merge(m, src)
}
func (m *SplitRegionsResponse) XXX_Size() int {
	return m.Size()
}
func (m *SplitRegionsResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_SplitRegionsResponse.DiscardUnknown(m)
}

var xxx_messageInfo_SplitRegionsResponse proto.InternalMessageInfo

func (m *SplitRegionsResponse) GetHeader() *ResponseHeader {
	if m != nil {
		return m.Header
	}
	return nil
}

func (m *SplitRegionsResponse) GetFinishedPercentage() uint64 {
	if m != nil {
		return m.FinishedPercentage
	}
	return 0
}

func (m *SplitRegionsResponse) GetRegionsId() []uint64 {
	if m != nil {
		return m.RegionsId
	}
	return nil
}

type SplitAndScatterRegionsRequest struct {
	Header               *RequestHeader `protobuf:"bytes,1,opt,name=header,proto3" json:"header,omitempty"`
	SplitKeys            [][]byte       `protobuf:"bytes,2,rep,name=split_keys,json=splitKeys,proto3" json:"split_keys,omitempty"`
	Group                string         `protobuf:"bytes,3,opt,name=group,proto3" json:"group,omitempty"`
	RetryLimit           uint64         `protobuf:"varint,4,opt,name=retry_limit,json=retryLimit,proto3" json:"retry_limit,omitempty"`
	XXX_NoUnkeyedLiteral struct{}       `json:"-"`
	XXX_unrecognized     []byte         `json:"-"`
	XXX_sizecache        int32          `json:"-"`
}

func (m *SplitAndScatterRegionsRequest) Reset()         { *m = SplitAndScatterRegionsRequest{} }
func (m *SplitAndScatterRegionsRequest) String() string { return proto.CompactTextString(m) }
func (*SplitAndScatterRegionsRequest) ProtoMessage()    {}
func (*SplitAndScatterRegionsRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_78b27e6f04f44c6e, []int{93}
}
func (m *SplitAndScatterRegionsRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SplitAndScatterRegionsRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SplitAndScatterRegionsRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SplitAndScatterRegionsRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SplitAndScatterRegionsRequest.Merge(m, src)
}
func (m *SplitAndScatterRegionsRequest) XXX_Size() int {
	return m.Size()
}
func (m *SplitAndScatterRegionsRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_SplitAndScatterRegionsRequest.DiscardUnknown(m)
}

var xxx_messageInfo_SplitAndScatterRegionsRequest proto.InternalMessageInfo

func (m *SplitAndScatterRegionsRequest) GetHeader() *RequestHeader {
	if m != nil {
		return m.Header
	}
	return nil
}

func (m *SplitAndScatterRegionsRequest) GetSplitKeys() [][]byte {
	if m != nil {
		return m.SplitKeys
	}
	return nil
}

func (m *SplitAndScatterRegionsRequest) GetGroup() string {
	if m != nil {
		return m.Group
	}
	return ""
}

func (m *SplitAndScatterRegionsRequest) GetRetryLimit() uint64 {
	if m != nil {
		return m.RetryLimit
	}
	return 0
}

type SplitAndScatterRegionsResponse struct {
	Header                    *ResponseHeader `protobuf:"bytes,1,opt,name=header,proto3" json:"header,omitempty"`
	SplitFinishedPercentage   uint64          `protobuf:"varint,2,opt,name=split_finished_percentage,json=splitFinishedPercentage,proto3" json:"split_finished_percentage,omitempty"`
	ScatterFinishedPercentage uint64          `protobuf:"varint,3,opt,name=scatter_finished_percentage,json=scatterFinishedPercentage,proto3" json:"scatter_finished_percentage,omitempty"`
	RegionsId                 []uint64        `protobuf:"varint,4,rep,packed,name=regions_id,json=regionsId,proto3" json:"regions_id,omitempty"`
	XXX_NoUnkeyedLiteral      struct{}        `json:"-"`
	XXX_unrecognized          []byte          `json:"-"`
	XXX_sizecache             int32           `json:"-"`
}

func (m *SplitAndScatterRegionsResponse) Reset()         { *m = SplitAndScatterRegionsResponse{} }
func (m *SplitAndScatterRegionsResponse) String() string { return proto.CompactTextString(m) }
func (*SplitAndScatterRegionsResponse) ProtoMessage()    {}
func (*SplitAndScatterRegionsResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_78b27e6f04f44c6e, []int{94}
}
func (m *SplitAndScatterRegionsResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SplitAndScatterRegionsResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SplitAndScatterRegionsResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SplitAndScatterRegionsResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SplitAndScatterRegionsResponse.Merge(m, src)
}
func (m *SplitAndScatterRegionsResponse) XXX_Size() int {
	return m.Size()
}
func (m *SplitAndScatterRegionsResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_SplitAndScatterRegionsResponse.DiscardUnknown(m)
}

var xxx_messageInfo_SplitAndScatterRegionsResponse proto.InternalMessageInfo

func (m *SplitAndScatterRegionsResponse) GetHeader() *ResponseHeader {
	if m != nil {
		return m.Header
	}
	return nil
}

func (m *SplitAndScatterRegionsResponse) GetSplitFinishedPercentage() uint64 {
	if m != nil {
		return m.SplitFinishedPercentage
	}
	return 0
}

func (m *SplitAndScatterRegionsResponse) GetScatterFinishedPercentage() uint64 {
	if m != nil {
		return m.ScatterFinishedPercentage
	}
	return 0
}

func (m *SplitAndScatterRegionsResponse) GetRegionsId() []uint64 {
	if m != nil {
		return m.RegionsId
	}
	return nil
}

type GetDCLocationInfoRequest struct {
	Header               *RequestHeader `protobuf:"bytes,1,opt,name=header,proto3" json:"header,omitempty"`
	DcLocation           string         `protobuf:"bytes,2,opt,name=dc_location,json=dcLocation,proto3" json:"dc_location,omitempty"`
	XXX_NoUnkeyedLiteral struct{}       `json:"-"`
	XXX_unrecognized     []byte         `json:"-"`
	XXX_sizecache        int32          `json:"-"`
}

func (m *GetDCLocationInfoRequest) Reset()         { *m = GetDCLocationInfoRequest{} }
func (m *GetDCLocationInfoRequest) String() string { return proto.CompactTextString(m) }
func (*GetDCLocationInfoRequest) ProtoMessage()    {}
func (*GetDCLocationInfoRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_78b27e6f04f44c6e, []int{95}
}
func (m *GetDCLocationInfoRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetDCLocationInfoRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetDCLocationInfoRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetDCLocationInfoRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetDCLocationInfoRequest.Merge(m, src)
}
func (m *GetDCLocationInfoRequest) XXX_Size() int {
	return m.Size()
}
func (m *GetDCLocationInfoRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_GetDCLocationInfoRequest.DiscardUnknown(m)
}

var xxx_messageInfo_GetDCLocationInfoRequest proto.InternalMessageInfo

func (m *GetDCLocationInfoRequest) GetHeader() *RequestHeader {
	if m != nil {
		return m.Header
	}
	return nil
}

func (m *GetDCLocationInfoRequest) GetDcLocation() string {
	if m != nil {
		return m.DcLocation
	}
	return ""
}

type GetDCLocationInfoResponse struct {
	Header *ResponseHeader `protobuf:"bytes,1,opt,name=header,proto3" json:"header,omitempty"`
	// suffix sign
	Suffix int32 `protobuf:"varint,2,opt,name=suffix,proto3" json:"suffix,omitempty"`
	// max_ts will be included into this response if PD leader think the receiver needs,
	// which it's set when the number of the max suffix bits changes.
	MaxTs                *Timestamp `protobuf:"bytes,3,opt,name=max_ts,json=maxTs,proto3" json:"max_ts,omitempty"`
	XXX_NoUnkeyedLiteral struct{}   `json:"-"`
	XXX_unrecognized     []byte     `json:"-"`
	XXX_sizecache        int32      `json:"-"`
}

func (m *GetDCLocationInfoResponse) Reset()         { *m = GetDCLocationInfoResponse{} }
func (m *GetDCLocationInfoResponse) String() string { return proto.CompactTextString(m) }
func (*GetDCLocationInfoResponse) ProtoMessage()    {}
func (*GetDCLocationInfoResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_78b27e6f04f44c6e, []int{96}
}
func (m *GetDCLocationInfoResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetDCLocationInfoResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetDCLocationInfoResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetDCLocationInfoResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetDCLocationInfoResponse.Merge(m, src)
}
func (m *GetDCLocationInfoResponse) XXX_Size() int {
	return m.Size()
}
func (m *GetDCLocationInfoResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_GetDCLocationInfoResponse.DiscardUnknown(m)
}

var xxx_messageInfo_GetDCLocationInfoResponse proto.InternalMessageInfo

func (m *GetDCLocationInfoResponse) GetHeader() *ResponseHeader {
	if m != nil {
		return m.Header
	}
	return nil
}

func (m *GetDCLocationInfoResponse) GetSuffix() int32 {
	if m != nil {
		return m.Suffix
	}
	return 0
}

func (m *GetDCLocationInfoResponse) GetMaxTs() *Timestamp {
	if m != nil {
		return m.MaxTs
	}
	return nil
}

type QueryStats struct {
	GC                     uint64   `protobuf:"varint,1,opt,name=GC,proto3" json:"GC,omitempty"`
	Get                    uint64   `protobuf:"varint,2,opt,name=Get,proto3" json:"Get,omitempty"`
	Scan                   uint64   `protobuf:"varint,3,opt,name=Scan,proto3" json:"Scan,omitempty"`
	Coprocessor            uint64   `protobuf:"varint,4,opt,name=Coprocessor,proto3" json:"Coprocessor,omitempty"`
	Delete                 uint64   `protobuf:"varint,5,opt,name=Delete,proto3" json:"Delete,omitempty"`
	DeleteRange            uint64   `protobuf:"varint,6,opt,name=DeleteRange,proto3" json:"DeleteRange,omitempty"`
	Put                    uint64   `protobuf:"varint,7,opt,name=Put,proto3" json:"Put,omitempty"`
	Prewrite               uint64   `protobuf:"varint,8,opt,name=Prewrite,proto3" json:"Prewrite,omitempty"`
	AcquirePessimisticLock uint64   `protobuf:"varint,9,opt,name=AcquirePessimisticLock,proto3" json:"AcquirePessimisticLock,omitempty"`
	Commit                 uint64   `protobuf:"varint,10,opt,name=Commit,proto3" json:"Commit,omitempty"`
	Rollback               uint64   `protobuf:"varint,11,opt,name=Rollback,proto3" json:"Rollback,omitempty"`
	XXX_NoUnkeyedLiteral   struct{} `json:"-"`
	XXX_unrecognized       []byte   `json:"-"`
	XXX_sizecache          int32    `json:"-"`
}

func (m *QueryStats) Reset()         { *m = QueryStats{} }
func (m *QueryStats) String() string { return proto.CompactTextString(m) }
func (*QueryStats) ProtoMessage()    {}
func (*QueryStats) Descriptor() ([]byte, []int) {
	return fileDescriptor_78b27e6f04f44c6e, []int{97}
}
func (m *QueryStats) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QueryStats) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QueryStats.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QueryStats) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueryStats.Merge(m, src)
}
func (m *QueryStats) XXX_Size() int {
	return m.Size()
}
func (m *QueryStats) XXX_DiscardUnknown() {
	xxx_messageInfo_QueryStats.DiscardUnknown(m)
}

var xxx_messageInfo_QueryStats proto.InternalMessageInfo

func (m *QueryStats) GetGC() uint64 {
	if m != nil {
		return m.GC
	}
	return 0
}

func (m *QueryStats) GetGet() uint64 {
	if m != nil {
		return m.Get
	}
	return 0
}

func (m *QueryStats) GetScan() uint64 {
	if m != nil {
		return m.Scan
	}
	return 0
}

func (m *QueryStats) GetCoprocessor() uint64 {
	if m != nil {
		return m.Coprocessor
	}
	return 0
}

func (m *QueryStats) GetDelete() uint64 {
	if m != nil {
		return m.Delete
	}
	return 0
}

func (m *QueryStats) GetDeleteRange() uint64 {
	if m != nil {
		return m.DeleteRange
	}
	return 0
}

func (m *QueryStats) GetPut() uint64 {
	if m != nil {
		return m.Put
	}
	return 0
}

func (m *QueryStats) GetPrewrite() uint64 {
	if m != nil {
		return m.Prewrite
	}
	return 0
}

func (m *QueryStats) GetAcquirePessimisticLock() uint64 {
	if m != nil {
		return m.AcquirePessimisticLock
	}
	return 0
}

func (m *QueryStats) GetCommit() uint64 {
	if m != nil {
		return m.Commit
	}
	return 0
}

func (m *QueryStats) GetRollback() uint64 {
	if m != nil {
		return m.Rollback
	}
	return 0
}

type ReportBucketsRequest struct {
	Header               *RequestHeader      `protobuf:"bytes,1,opt,name=header,proto3" json:"header,omitempty"`
	RegionEpoch          *metapb.RegionEpoch `protobuf:"bytes,2,opt,name=region_epoch,json=regionEpoch,proto3" json:"region_epoch,omitempty"`
	Buckets              *metapb.Buckets     `protobuf:"bytes,3,opt,name=buckets,proto3" json:"buckets,omitempty"`
	XXX_NoUnkeyedLiteral struct{}            `json:"-"`
	XXX_unrecognized     []byte              `json:"-"`
	XXX_sizecache        int32               `json:"-"`
}

func (m *ReportBucketsRequest) Reset()         { *m = ReportBucketsRequest{} }
func (m *ReportBucketsRequest) String() string { return proto.CompactTextString(m) }
func (*ReportBucketsRequest) ProtoMessage()    {}
func (*ReportBucketsRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_78b27e6f04f44c6e, []int{98}
}
func (m *ReportBucketsRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ReportBucketsRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ReportBucketsRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ReportBucketsRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ReportBucketsRequest.Merge(m, src)
}
func (m *ReportBucketsRequest) XXX_Size() int {
	return m.Size()
}
func (m *ReportBucketsRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ReportBucketsRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ReportBucketsRequest proto.InternalMessageInfo

func (m *ReportBucketsRequest) GetHeader() *RequestHeader {
	if m != nil {
		return m.Header
	}
	return nil
}

func (m *ReportBucketsRequest) GetRegionEpoch() *metapb.RegionEpoch {
	if m != nil {
		return m.RegionEpoch
	}
	return nil
}

func (m *ReportBucketsRequest) GetBuckets() *metapb.Buckets {
	if m != nil {
		return m.Buckets
	}
	return nil
}

type ReportBucketsResponse struct {
	Header               *ResponseHeader `protobuf:"bytes,1,opt,name=header,proto3" json:"header,omitempty"`
	XXX_NoUnkeyedLiteral struct{}        `json:"-"`
	XXX_unrecognized     []byte          `json:"-"`
	XXX_sizecache        int32           `json:"-"`
}

func (m *ReportBucketsResponse) Reset()         { *m = ReportBucketsResponse{} }
func (m *ReportBucketsResponse) String() string { return proto.CompactTextString(m) }
func (*ReportBucketsResponse) ProtoMessage()    {}
func (*ReportBucketsResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_78b27e6f04f44c6e, []int{99}
}
func (m *ReportBucketsResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ReportBucketsResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ReportBucketsResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ReportBucketsResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ReportBucketsResponse.Merge(m, src)
}
func (m *ReportBucketsResponse) XXX_Size() int {
	return m.Size()
}
func (m *ReportBucketsResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_ReportBucketsResponse.DiscardUnknown(m)
}

var xxx_messageInfo_ReportBucketsResponse proto.InternalMessageInfo

func (m *ReportBucketsResponse) GetHeader() *ResponseHeader {
	if m != nil {
		return m.Header
	}
	return nil
}

type ReportMinResolvedTsRequest struct {
	Header               *RequestHeader `protobuf:"bytes,1,opt,name=header,proto3" json:"header,omitempty"`
	StoreId              uint64         `protobuf:"varint,2,opt,name=store_id,json=storeId,proto3" json:"store_id,omitempty"`
	MinResolvedTs        uint64         `protobuf:"varint,3,opt,name=min_resolved_ts,json=minResolvedTs,proto3" json:"min_resolved_ts,omitempty"`
	XXX_NoUnkeyedLiteral struct{}       `json:"-"`
	XXX_unrecognized     []byte         `json:"-"`
	XXX_sizecache        int32          `json:"-"`
}

func (m *ReportMinResolvedTsRequest) Reset()         { *m = ReportMinResolvedTsRequest{} }
func (m *ReportMinResolvedTsRequest) String() string { return proto.CompactTextString(m) }
func (*ReportMinResolvedTsRequest) ProtoMessage()    {}
func (*ReportMinResolvedTsRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_78b27e6f04f44c6e, []int{100}
}
func (m *ReportMinResolvedTsRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ReportMinResolvedTsRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ReportMinResolvedTsRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ReportMinResolvedTsRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ReportMinResolvedTsRequest.Merge(m, src)
}
func (m *ReportMinResolvedTsRequest) XXX_Size() int {
	return m.Size()
}
func (m *ReportMinResolvedTsRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ReportMinResolvedTsRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ReportMinResolvedTsRequest proto.InternalMessageInfo

func (m *ReportMinResolvedTsRequest) GetHeader() *RequestHeader {
	if m != nil {
		return m.Header
	}
	return nil
}

func (m *ReportMinResolvedTsRequest) GetStoreId() uint64 {
	if m != nil {
		return m.StoreId
	}
	return 0
}

func (m *ReportMinResolvedTsRequest) GetMinResolvedTs() uint64 {
	if m != nil {
		return m.MinResolvedTs
	}
	return 0
}

type ReportMinResolvedTsResponse struct {
	Header               *ResponseHeader `protobuf:"bytes,1,opt,name=header,proto3" json:"header,omitempty"`
	XXX_NoUnkeyedLiteral struct{}        `json:"-"`
	XXX_unrecognized     []byte          `json:"-"`
	XXX_sizecache        int32           `json:"-"`
}

func (m *ReportMinResolvedTsResponse) Reset()         { *m = ReportMinResolvedTsResponse{} }
func (m *ReportMinResolvedTsResponse) String() string { return proto.CompactTextString(m) }
func (*ReportMinResolvedTsResponse) ProtoMessage()    {}
func (*ReportMinResolvedTsResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_78b27e6f04f44c6e, []int{101}
}
func (m *ReportMinResolvedTsResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ReportMinResolvedTsResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ReportMinResolvedTsResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ReportMinResolvedTsResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ReportMinResolvedTsResponse.Merge(m, src)
}
func (m *ReportMinResolvedTsResponse) XXX_Size() int {
	return m.Size()
}
func (m *ReportMinResolvedTsResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_ReportMinResolvedTsResponse.DiscardUnknown(m)
}

var xxx_messageInfo_ReportMinResolvedTsResponse proto.InternalMessageInfo

func (m *ReportMinResolvedTsResponse) GetHeader() *ResponseHeader {
	if m != nil {
		return m.Header
	}
	return nil
}

type SetExternalTimestampRequest struct {
	Header               *RequestHeader `protobuf:"bytes,1,opt,name=header,proto3" json:"header,omitempty"`
	Timestamp            uint64         `protobuf:"varint,2,opt,name=timestamp,proto3" json:"timestamp,omitempty"`
	XXX_NoUnkeyedLiteral struct{}       `json:"-"`
	XXX_unrecognized     []byte         `json:"-"`
	XXX_sizecache        int32          `json:"-"`
}

func (m *SetExternalTimestampRequest) Reset()         { *m = SetExternalTimestampRequest{} }
func (m *SetExternalTimestampRequest) String() string { return proto.CompactTextString(m) }
func (*SetExternalTimestampRequest) ProtoMessage()    {}
func (*SetExternalTimestampRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_78b27e6f04f44c6e, []int{102}
}
func (m *SetExternalTimestampRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SetExternalTimestampRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SetExternalTimestampRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SetExternalTimestampRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SetExternalTimestampRequest.Merge(m, src)
}
func (m *SetExternalTimestampRequest) XXX_Size() int {
	return m.Size()
}
func (m *SetExternalTimestampRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_SetExternalTimestampRequest.DiscardUnknown(m)
}

var xxx_messageInfo_SetExternalTimestampRequest proto.InternalMessageInfo

func (m *SetExternalTimestampRequest) GetHeader() *RequestHeader {
	if m != nil {
		return m.Header
	}
	return nil
}

func (m *SetExternalTimestampRequest) GetTimestamp() uint64 {
	if m != nil {
		return m.Timestamp
	}
	return 0
}

type SetExternalTimestampResponse struct {
	Header               *ResponseHeader `protobuf:"bytes,1,opt,name=header,proto3" json:"header,omitempty"`
	XXX_NoUnkeyedLiteral struct{}        `json:"-"`
	XXX_unrecognized     []byte          `json:"-"`
	XXX_sizecache        int32           `json:"-"`
}

func (m *SetExternalTimestampResponse) Reset()         { *m = SetExternalTimestampResponse{} }
func (m *SetExternalTimestampResponse) String() string { return proto.CompactTextString(m) }
func (*SetExternalTimestampResponse) ProtoMessage()    {}
func (*SetExternalTimestampResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_78b27e6f04f44c6e, []int{103}
}
func (m *SetExternalTimestampResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SetExternalTimestampResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SetExternalTimestampResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SetExternalTimestampResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SetExternalTimestampResponse.Merge(m, src)
}
func (m *SetExternalTimestampResponse) XXX_Size() int {
	return m.Size()
}
func (m *SetExternalTimestampResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_SetExternalTimestampResponse.DiscardUnknown(m)
}

var xxx_messageInfo_SetExternalTimestampResponse proto.InternalMessageInfo

func (m *SetExternalTimestampResponse) GetHeader() *ResponseHeader {
	if m != nil {
		return m.Header
	}
	return nil
}

type GetExternalTimestampRequest struct {
	Header               *RequestHeader `protobuf:"bytes,1,opt,name=header,proto3" json:"header,omitempty"`
	XXX_NoUnkeyedLiteral struct{}       `json:"-"`
	XXX_unrecognized     []byte         `json:"-"`
	XXX_sizecache        int32          `json:"-"`
}

func (m *GetExternalTimestampRequest) Reset()         { *m = GetExternalTimestampRequest{} }
func (m *GetExternalTimestampRequest) String() string { return proto.CompactTextString(m) }
func (*GetExternalTimestampRequest) ProtoMessage()    {}
func (*GetExternalTimestampRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_78b27e6f04f44c6e, []int{104}
}
func (m *GetExternalTimestampRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetExternalTimestampRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetExternalTimestampRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetExternalTimestampRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetExternalTimestampRequest.Merge(m, src)
}
func (m *GetExternalTimestampRequest) XXX_Size() int {
	return m.Size()
}
func (m *GetExternalTimestampRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_GetExternalTimestampRequest.DiscardUnknown(m)
}

var xxx_messageInfo_GetExternalTimestampRequest proto.InternalMessageInfo

func (m *GetExternalTimestampRequest) GetHeader() *RequestHeader {
	if m != nil {
		return m.Header
	}
	return nil
}

type GetExternalTimestampResponse struct {
	Header               *ResponseHeader `protobuf:"bytes,1,opt,name=header,proto3" json:"header,omitempty"`
	Timestamp            uint64          `protobuf:"varint,2,opt,name=timestamp,proto3" json:"timestamp,omitempty"`
	XXX_NoUnkeyedLiteral struct{}        `json:"-"`
	XXX_unrecognized     []byte          `json:"-"`
	XXX_sizecache        int32           `json:"-"`
}

func (m *GetExternalTimestampResponse) Reset()         { *m = GetExternalTimestampResponse{} }
func (m *GetExternalTimestampResponse) String() string { return proto.CompactTextString(m) }
func (*GetExternalTimestampResponse) ProtoMessage()    {}
func (*GetExternalTimestampResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_78b27e6f04f44c6e, []int{105}
}
func (m *GetExternalTimestampResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetExternalTimestampResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetExternalTimestampResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetExternalTimestampResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetExternalTimestampResponse.Merge(m, src)
}
func (m *GetExternalTimestampResponse) XXX_Size() int {
	return m.Size()
}
func (m *GetExternalTimestampResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_GetExternalTimestampResponse.DiscardUnknown(m)
}

var xxx_messageInfo_GetExternalTimestampResponse proto.InternalMessageInfo

func (m *GetExternalTimestampResponse) GetHeader() *ResponseHeader {
	if m != nil {
		return m.Header
	}
	return nil
}

func (m *GetExternalTimestampResponse) GetTimestamp() uint64 {
	if m != nil {
		return m.Timestamp
	}
	return 0
}

func init() {
	proto.RegisterEnum("pdpb.EventType", EventType_name, EventType_value)
	proto.RegisterEnum("pdpb.ErrorType", ErrorType_name, ErrorType_value)
	proto.RegisterEnum("pdpb.ServiceMode", ServiceMode_name, ServiceMode_value)
	proto.RegisterEnum("pdpb.CheckPolicy", CheckPolicy_name, CheckPolicy_value)
	proto.RegisterEnum("pdpb.OperatorStatus", OperatorStatus_name, OperatorStatus_value)
	proto.RegisterEnum("pdpb.QueryKind", QueryKind_name, QueryKind_value)
	proto.RegisterType((*WatchGlobalConfigRequest)(nil), "pdpb.WatchGlobalConfigRequest")
	proto.RegisterType((*WatchGlobalConfigResponse)(nil), "pdpb.WatchGlobalConfigResponse")
	proto.RegisterType((*StoreGlobalConfigRequest)(nil), "pdpb.StoreGlobalConfigRequest")
	proto.RegisterType((*StoreGlobalConfigResponse)(nil), "pdpb.StoreGlobalConfigResponse")
	proto.RegisterType((*LoadGlobalConfigRequest)(nil), "pdpb.LoadGlobalConfigRequest")
	proto.RegisterType((*LoadGlobalConfigResponse)(nil), "pdpb.LoadGlobalConfigResponse")
	proto.RegisterType((*GlobalConfigItem)(nil), "pdpb.GlobalConfigItem")
	proto.RegisterType((*RequestHeader)(nil), "pdpb.RequestHeader")
	proto.RegisterType((*ResponseHeader)(nil), "pdpb.ResponseHeader")
	proto.RegisterType((*Error)(nil), "pdpb.Error")
	proto.RegisterType((*TsoRequest)(nil), "pdpb.TsoRequest")
	proto.RegisterType((*TaasRequest)(nil), "pdpb.TaasRequest")
	proto.RegisterType((*Timestamp)(nil), "pdpb.Timestamp")
	proto.RegisterType((*TsoResponse)(nil), "pdpb.TsoResponse")
	proto.RegisterType((*BootstrapRequest)(nil), "pdpb.BootstrapRequest")
	proto.RegisterType((*BootstrapResponse)(nil), "pdpb.BootstrapResponse")
	proto.RegisterType((*IsBootstrappedRequest)(nil), "pdpb.IsBootstrappedRequest")
	proto.RegisterType((*IsBootstrappedResponse)(nil), "pdpb.IsBootstrappedResponse")
	proto.RegisterType((*AllocIDRequest)(nil), "pdpb.AllocIDRequest")
	proto.RegisterType((*AllocIDResponse)(nil), "pdpb.AllocIDResponse")
	proto.RegisterType((*IsSnapshotRecoveringRequest)(nil), "pdpb.IsSnapshotRecoveringRequest")
	proto.RegisterType((*IsSnapshotRecoveringResponse)(nil), "pdpb.IsSnapshotRecoveringResponse")
	proto.RegisterType((*GetStoreRequest)(nil), "pdpb.GetStoreRequest")
	proto.RegisterType((*GetStoreResponse)(nil), "pdpb.GetStoreResponse")
	proto.RegisterType((*PutStoreRequest)(nil), "pdpb.PutStoreRequest")
	proto.RegisterType((*PutStoreResponse)(nil), "pdpb.PutStoreResponse")
	proto.RegisterType((*GetAllStoresRequest)(nil), "pdpb.GetAllStoresRequest")
	proto.RegisterType((*GetAllStoresResponse)(nil), "pdpb.GetAllStoresResponse")
	proto.RegisterType((*GetRegionRequest)(nil), "pdpb.GetRegionRequest")
	proto.RegisterType((*GetRegionResponse)(nil), "pdpb.GetRegionResponse")
	proto.RegisterType((*GetRegionByIDRequest)(nil), "pdpb.GetRegionByIDRequest")
	proto.RegisterType((*ScanRegionsRequest)(nil), "pdpb.ScanRegionsRequest")
	proto.RegisterType((*Region)(nil), "pdpb.Region")
	proto.RegisterType((*ScanRegionsResponse)(nil), "pdpb.ScanRegionsResponse")
	proto.RegisterType((*GetClusterConfigRequest)(nil), "pdpb.GetClusterConfigRequest")
	proto.RegisterType((*GetClusterConfigResponse)(nil), "pdpb.GetClusterConfigResponse")
	proto.RegisterType((*PutClusterConfigRequest)(nil), "pdpb.PutClusterConfigRequest")
	proto.RegisterType((*PutClusterConfigResponse)(nil), "pdpb.PutClusterConfigResponse")
	proto.RegisterType((*Member)(nil), "pdpb.Member")
	proto.RegisterType((*GetMembersRequest)(nil), "pdpb.GetMembersRequest")
	proto.RegisterType((*GetMembersResponse)(nil), "pdpb.GetMembersResponse")
	proto.RegisterMapType((map[string]*Member)(nil), "pdpb.GetMembersResponse.TsoAllocatorLeadersEntry")
	proto.RegisterType((*GetClusterInfoRequest)(nil), "pdpb.GetClusterInfoRequest")
	proto.RegisterType((*GetClusterInfoResponse)(nil), "pdpb.GetClusterInfoResponse")
	proto.RegisterType((*PeerStats)(nil), "pdpb.PeerStats")
	proto.RegisterType((*RegionHeartbeatRequest)(nil), "pdpb.RegionHeartbeatRequest")
	proto.RegisterType((*ChangePeer)(nil), "pdpb.ChangePeer")
	proto.RegisterType((*ChangePeerV2)(nil), "pdpb.ChangePeerV2")
	proto.RegisterType((*TransferLeader)(nil), "pdpb.TransferLeader")
	proto.RegisterType((*Merge)(nil), "pdpb.Merge")
	proto.RegisterType((*SplitRegion)(nil), "pdpb.SplitRegion")
	proto.RegisterType((*SwitchWitness)(nil), "pdpb.SwitchWitness")
	proto.RegisterType((*BatchSwitchWitness)(nil), "pdpb.BatchSwitchWitness")
	proto.RegisterType((*RegionHeartbeatResponse)(nil), "pdpb.RegionHeartbeatResponse")
	proto.RegisterType((*AskSplitRequest)(nil), "pdpb.AskSplitRequest")
	proto.RegisterType((*AskSplitResponse)(nil), "pdpb.AskSplitResponse")
	proto.RegisterType((*ReportSplitRequest)(nil), "pdpb.ReportSplitRequest")
	proto.RegisterType((*ReportSplitResponse)(nil), "pdpb.ReportSplitResponse")
	proto.RegisterType((*AskBatchSplitRequest)(nil), "pdpb.AskBatchSplitRequest")
	proto.RegisterType((*SplitID)(nil), "pdpb.SplitID")
	proto.RegisterType((*AskBatchSplitResponse)(nil), "pdpb.AskBatchSplitResponse")
	proto.RegisterType((*ReportBatchSplitRequest)(nil), "pdpb.ReportBatchSplitRequest")
	proto.RegisterType((*ReportBatchSplitResponse)(nil), "pdpb.ReportBatchSplitResponse")
	proto.RegisterType((*TimeInterval)(nil), "pdpb.TimeInterval")
	proto.RegisterType((*RecordPair)(nil), "pdpb.RecordPair")
	proto.RegisterType((*PeerStat)(nil), "pdpb.PeerStat")
	proto.RegisterType((*StoreStats)(nil), "pdpb.StoreStats")
	proto.RegisterType((*SlowTrend)(nil), "pdpb.SlowTrend")
	proto.RegisterType((*SnapshotStat)(nil), "pdpb.SnapshotStat")
	proto.RegisterType((*PeerReport)(nil), "pdpb.PeerReport")
	proto.RegisterType((*StoreReport)(nil), "pdpb.StoreReport")
	proto.RegisterType((*StoreHeartbeatRequest)(nil), "pdpb.StoreHeartbeatRequest")
	proto.RegisterType((*DemoteFailedVoters)(nil), "pdpb.DemoteFailedVoters")
	proto.RegisterType((*ForceLeader)(nil), "pdpb.ForceLeader")
	proto.RegisterType((*RecoveryPlan)(nil), "pdpb.RecoveryPlan")
	proto.RegisterType((*AwakenRegions)(nil), "pdpb.AwakenRegions")
	proto.RegisterType((*StoreHeartbeatResponse)(nil), "pdpb.StoreHeartbeatResponse")
	proto.RegisterType((*ScatterRegionRequest)(nil), "pdpb.ScatterRegionRequest")
	proto.RegisterType((*ScatterRegionResponse)(nil), "pdpb.ScatterRegionResponse")
	proto.RegisterType((*GetGCSafePointRequest)(nil), "pdpb.GetGCSafePointRequest")
	proto.RegisterType((*GetGCSafePointResponse)(nil), "pdpb.GetGCSafePointResponse")
	proto.RegisterType((*UpdateGCSafePointRequest)(nil), "pdpb.UpdateGCSafePointRequest")
	proto.RegisterType((*UpdateGCSafePointResponse)(nil), "pdpb.UpdateGCSafePointResponse")
	proto.RegisterType((*UpdateServiceGCSafePointRequest)(nil), "pdpb.UpdateServiceGCSafePointRequest")
	proto.RegisterType((*UpdateServiceGCSafePointResponse)(nil), "pdpb.UpdateServiceGCSafePointResponse")
	proto.RegisterType((*RegionStat)(nil), "pdpb.RegionStat")
	proto.RegisterType((*SyncRegionRequest)(nil), "pdpb.SyncRegionRequest")
	proto.RegisterType((*SyncRegionResponse)(nil), "pdpb.SyncRegionResponse")
	proto.RegisterType((*GetOperatorRequest)(nil), "pdpb.GetOperatorRequest")
	proto.RegisterType((*GetOperatorResponse)(nil), "pdpb.GetOperatorResponse")
	proto.RegisterType((*SyncMaxTSRequest)(nil), "pdpb.SyncMaxTSRequest")
	proto.RegisterType((*SyncMaxTSResponse)(nil), "pdpb.SyncMaxTSResponse")
	proto.RegisterType((*SplitRegionsRequest)(nil), "pdpb.SplitRegionsRequest")
	proto.RegisterType((*SplitRegionsResponse)(nil), "pdpb.SplitRegionsResponse")
	proto.RegisterType((*SplitAndScatterRegionsRequest)(nil), "pdpb.SplitAndScatterRegionsRequest")
	proto.RegisterType((*SplitAndScatterRegionsResponse)(nil), "pdpb.SplitAndScatterRegionsResponse")
	proto.RegisterType((*GetDCLocationInfoRequest)(nil), "pdpb.GetDCLocationInfoRequest")
	proto.RegisterType((*GetDCLocationInfoResponse)(nil), "pdpb.GetDCLocationInfoResponse")
	proto.RegisterType((*QueryStats)(nil), "pdpb.QueryStats")
	proto.RegisterType((*ReportBucketsRequest)(nil), "pdpb.ReportBucketsRequest")
	proto.RegisterType((*ReportBucketsResponse)(nil), "pdpb.ReportBucketsResponse")
	proto.RegisterType((*ReportMinResolvedTsRequest)(nil), "pdpb.ReportMinResolvedTsRequest")
	proto.RegisterType((*ReportMinResolvedTsResponse)(nil), "pdpb.ReportMinResolvedTsResponse")
	proto.RegisterType((*SetExternalTimestampRequest)(nil), "pdpb.SetExternalTimestampRequest")
	proto.RegisterType((*SetExternalTimestampResponse)(nil), "pdpb.SetExternalTimestampResponse")
	proto.RegisterType((*GetExternalTimestampRequest)(nil), "pdpb.GetExternalTimestampRequest")
	proto.RegisterType((*GetExternalTimestampResponse)(nil), "pdpb.GetExternalTimestampResponse")
}

func init() { proto.RegisterFile("pdpb.proto", fileDescriptor_78b27e6f04f44c6e) }

var fileDescriptor_78b27e6f04f44c6e = []byte{
	// 5638 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xcc, 0x7c, 0x4b, 0x6f, 0x23, 0x49,
	0x72, 0xb0, 0x8a, 0xa2, 0x24, 0x32, 0xf8, 0x50, 0x29, 0x5b, 0xdd, 0x62, 0xb3, 0x9f, 0x53, 0x3d,
	0x33, 0x5f, 0x4f, 0xef, 0x6c, 0xcf, 0x8c, 0x76, 0xbe, 0xf5, 0x78, 0xec, 0x1d, 0x98, 0x12, 0xd9,
	0x1a, 0x4e, 0xeb, 0x41, 0x17, 0xd9, 0x3d, 0x3b, 0xc6, 0xc2, 0x85, 0x52, 0x55, 0x4a, 0xaa, 0x15,
	0x59, 0xc5, 0xa9, 0x2c, 0x4a, 0xcd, 0x85, 0x0d, 0xf8, 0xb1, 0xf0, 0xae, 0xe1, 0x5d, 0xd8, 0x80,
	0x9f, 0xa7, 0x35, 0xb0, 0x36, 0x6c, 0x5f, 0x0c, 0xdf, 0x0c, 0xfb, 0x0f, 0x18, 0x3e, 0xfa, 0xe8,
	0x93, 0xb1, 0x58, 0x9f, 0xfc, 0x07, 0xf6, 0x62, 0x1f, 0x8c, 0x7c, 0xd5, 0x8b, 0x45, 0x49, 0x5d,
	0x3d, 0x63, 0xec, 0x89, 0x95, 0x11, 0x91, 0x91, 0x91, 0x91, 0x91, 0x99, 0x11, 0x91, 0x99, 0x04,
	0x18, 0xdb, 0xe3, 0xc3, 0xc7, 0x63, 0xdf, 0x0b, 0x3c, 0x54, 0xa4, 0xdf, 0xcd, 0xea, 0x08, 0x07,
	0xa6, 0x84, 0x35, 0x6b, 0xd8, 0x37, 0x8f, 0x82, 0xb0, 0x78, 0x8d, 0x96, 0x0c, 0x82, 0xfd, 0x33,
	0xec, 0x87, 0xc0, 0x86, 0x8f, 0xc7, 0x43, 0xc7, 0x32, 0x03, 0xc7, 0x73, 0x8d, 0x91, 0x67, 0xe3,
	0x10, 0xb3, 0x7e, 0xec, 0x1d, 0x7b, 0xec, 0xf3, 0x1d, 0xfa, 0x25, 0xa0, 0xab, 0xfe, 0x84, 0x04,
	0xec, 0x93, 0x03, 0xb4, 0x4f, 0xa1, 0xf1, 0xa9, 0x19, 0x58, 0x27, 0x3b, 0x43, 0xef, 0xd0, 0x1c,
	0x6e, 0x7b, 0xee, 0x91, 0x73, 0xac, 0xe3, 0xcf, 0x27, 0x98, 0x04, 0xe8, 0x1e, 0x54, 0x2c, 0x06,
	0x30, 0xc6, 0x66, 0x70, 0xd2, 0x50, 0xee, 0x2b, 0x0f, 0xcb, 0x3a, 0x70, 0x50, 0xcf, 0x0c, 0x4e,
	0x50, 0x13, 0x4a, 0x3e, 0x3e, 0x73, 0x88, 0xe3, 0xb9, 0x8d, 0xc2, 0x7d, 0xe5, 0xe1, 0xa2, 0x1e,
	0x96, 0xb5, 0x3f, 0x57, 0xe0, 0x66, 0x06, 0x67, 0x32, 0xf6, 0x5c, 0x82, 0xd1, 0xbb, 0xb0, 0x62,
	0x9d, 0x98, 0xee, 0x31, 0x26, 0x0d, 0xe5, 0xfe, 0xe2, 0xc3, 0xca, 0xe6, 0x8d, 0xc7, 0x4c, 0x1b,
	0x71, 0xe2, 0x6e, 0x80, 0x47, 0xba, 0x24, 0xbb, 0xa8, 0x2d, 0xf4, 0x36, 0x2c, 0x9f, 0x60, 0xd3,
	0xc6, 0x7e, 0x63, 0xf1, 0xbe, 0xf2, 0xb0, 0xb2, 0xb9, 0xce, 0x99, 0xc9, 0xd6, 0x3e, 0x66, 0x38,
	0x5d, 0xd0, 0x68, 0x23, 0x68, 0xf4, 0x03, 0xcf, 0xc7, 0x59, 0x5d, 0x7e, 0x79, 0xb9, 0x52, 0x4a,
	0x2a, 0xa4, 0x95, 0xa4, 0x7d, 0x04, 0x37, 0x33, 0x9a, 0x13, 0x7a, 0x78, 0x0d, 0x96, 0xb0, 0xef,
	0x7b, 0x3e, 0x53, 0x6e, 0x65, 0xb3, 0xc2, 0x5b, 0xeb, 0x50, 0x90, 0xce, 0x31, 0x5a, 0x0f, 0x36,
	0x76, 0x3d, 0xd3, 0xce, 0x92, 0x76, 0x1d, 0x96, 0x5c, 0x73, 0x24, 0x64, 0x2d, 0xeb, 0xbc, 0x70,
	0xb9, 0x44, 0x36, 0x34, 0x66, 0x39, 0x0a, 0x81, 0xde, 0x86, 0x25, 0x27, 0xc0, 0xa3, 0xcb, 0xba,
	0xcf, 0x89, 0x2e, 0x34, 0x80, 0x1f, 0x29, 0xa0, 0xa6, 0xeb, 0x21, 0x04, 0x45, 0x2a, 0xa4, 0xb0,
	0x25, 0xf6, 0x4d, 0x7b, 0x71, 0x66, 0x0e, 0x27, 0x58, 0x48, 0xca, 0x0b, 0x91, 0x66, 0x16, 0xe7,
	0x69, 0x06, 0x3d, 0x80, 0xe2, 0xa9, 0xe3, 0xda, 0x8d, 0xe2, 0x7d, 0xe5, 0x61, 0x7d, 0x73, 0x55,
	0x50, 0x9c, 0x61, 0x37, 0x18, 0x4c, 0xc7, 0x58, 0x67, 0x48, 0xd4, 0x80, 0x95, 0xb1, 0x39, 0x1d,
	0x7a, 0xa6, 0xdd, 0x58, 0xba, 0xaf, 0x3c, 0xac, 0xea, 0xb2, 0xa8, 0x3d, 0x85, 0x9a, 0x50, 0x24,
	0x37, 0x10, 0x74, 0x07, 0xc0, 0x1a, 0x4e, 0x48, 0x80, 0x7d, 0xc3, 0xb1, 0x99, 0x88, 0x45, 0xbd,
	0x2c, 0x20, 0x5d, 0x1b, 0xdd, 0x82, 0x32, 0xc1, 0xae, 0xcd, 0xb1, 0x05, 0x86, 0x2d, 0x71, 0x40,
	0xd7, 0xd6, 0x74, 0xa8, 0x27, 0xcd, 0xed, 0x32, 0x6e, 0x61, 0xff, 0x0a, 0x73, 0x47, 0xfe, 0x09,
	0x2c, 0x75, 0x64, 0x47, 0x83, 0xe9, 0x98, 0x6b, 0x2d, 0xea, 0x28, 0x45, 0xf1, 0x8e, 0x52, 0x24,
	0xed, 0xe8, 0x08, 0x13, 0x62, 0x1e, 0x4b, 0x45, 0xca, 0xa2, 0x36, 0x06, 0x18, 0x10, 0x4f, 0x1a,
	0xcd, 0x57, 0xc2, 0xc9, 0xc2, 0x6d, 0xee, 0x9a, 0x9c, 0x2c, 0x31, 0x55, 0xc8, 0xb9, 0x42, 0xc7,
	0xc6, 0xf2, 0x26, 0x6e, 0xc0, 0x58, 0xd6, 0x74, 0x5e, 0xa0, 0x16, 0x66, 0x5b, 0xc6, 0xd0, 0xe3,
	0xeb, 0x0e, 0x1b, 0xa1, 0xb2, 0x0e, 0xb6, 0xb5, 0x2b, 0x20, 0xda, 0xf7, 0x14, 0xa8, 0x0c, 0x4c,
	0x93, 0xe4, 0x6d, 0x93, 0x04, 0xe6, 0x68, 0xcc, 0xda, 0x2c, 0xe9, 0xbc, 0x10, 0x49, 0xb2, 0x78,
	0x81, 0x24, 0xc5, 0x19, 0x49, 0x0e, 0xa1, 0x3c, 0x70, 0x46, 0x98, 0xf3, 0x68, 0x42, 0x69, 0x7c,
	0x32, 0x25, 0x8e, 0x65, 0x0e, 0x99, 0x20, 0x8b, 0x7a, 0x58, 0xa6, 0xea, 0x1b, 0x7a, 0xc7, 0x0c,
	0xc5, 0x2d, 0x59, 0x16, 0x69, 0x1b, 0x64, 0x72, 0x74, 0xe4, 0xbc, 0x30, 0x0e, 0x9d, 0x80, 0x88,
	0xf6, 0x81, 0x83, 0xb6, 0x9c, 0x80, 0x68, 0xbf, 0x45, 0x7b, 0x4b, 0x15, 0x1c, 0xce, 0xa1, 0x64,
	0x6f, 0x2f, 0x5c, 0x8e, 0xe6, 0xa8, 0xf8, 0xab, 0x50, 0x0e, 0xa4, 0xdc, 0x62, 0x0a, 0x88, 0x71,
	0x0f, 0xbb, 0xa3, 0x47, 0x14, 0xda, 0x0f, 0x14, 0x50, 0xb7, 0x3c, 0x2f, 0x20, 0x81, 0x6f, 0x8e,
	0x73, 0x69, 0xfd, 0x01, 0xd5, 0xba, 0xe7, 0x63, 0x61, 0x8f, 0xb5, 0xc7, 0x62, 0x2f, 0x62, 0x6b,
	0x97, 0xce, 0x71, 0xe8, 0x4d, 0x58, 0xf6, 0xf1, 0xb1, 0x1c, 0xf3, 0xca, 0x66, 0x5d, 0x52, 0xe9,
	0x0c, 0xaa, 0x0b, 0x2c, 0x5d, 0xfc, 0xd7, 0x62, 0xe2, 0xe4, 0xd2, 0xcb, 0x00, 0x50, 0x7c, 0x73,
	0x23, 0x81, 0x19, 0x4c, 0x88, 0x90, 0xee, 0x8d, 0xc7, 0x19, 0xfb, 0x9e, 0x1e, 0x81, 0xfa, 0x8c,
	0x58, 0x5f, 0xf3, 0xd3, 0x20, 0xad, 0x0d, 0xd7, 0xbb, 0x24, 0x14, 0x6d, 0x8c, 0xed, 0x3c, 0xca,
	0xd2, 0xbe, 0x0d, 0x37, 0xd2, 0x5c, 0x72, 0xf5, 0x51, 0x83, 0xea, 0x61, 0x8c, 0x8b, 0xb0, 0xf8,
	0x04, 0x4c, 0xfb, 0x06, 0xd4, 0x5b, 0xc3, 0xa1, 0x67, 0x75, 0xdb, 0xb9, 0x44, 0x3d, 0x80, 0xd5,
	0xb0, 0x7a, 0x2e, 0x19, 0xeb, 0x50, 0x08, 0xd7, 0xbb, 0x82, 0x63, 0x6b, 0x9f, 0xc0, 0xad, 0x2e,
	0xe9, 0xbb, 0xe6, 0x98, 0x9c, 0x78, 0x81, 0x8e, 0x2d, 0xef, 0x0c, 0xfb, 0x8e, 0x7b, 0x9c, 0x4b,
	0x38, 0x1b, 0x6e, 0x67, 0xf3, 0xca, 0x25, 0xe9, 0x0d, 0x58, 0x1e, 0x99, 0xfe, 0x69, 0xa8, 0x47,
	0x51, 0xd2, 0x3e, 0x83, 0xd5, 0x1d, 0x1c, 0x70, 0x43, 0xce, 0x33, 0x35, 0x6e, 0x42, 0x89, 0x99,
	0x7f, 0xb4, 0xee, 0xaf, 0xb0, 0x72, 0xd7, 0xd6, 0x7e, 0x48, 0x37, 0xb9, 0x90, 0x77, 0x2e, 0xa9,
	0xaf, 0x38, 0xf1, 0xe8, 0x32, 0x28, 0x56, 0x9f, 0xca, 0xa6, 0xca, 0x39, 0x32, 0x12, 0x6a, 0xd8,
	0x44, 0xe7, 0x68, 0xcd, 0x82, 0xd5, 0xde, 0xe4, 0x15, 0xba, 0x7a, 0x15, 0x61, 0xb4, 0x3f, 0x53,
	0x40, 0x8d, 0x5a, 0xf9, 0x39, 0x9a, 0xdc, 0xbf, 0x01, 0xd7, 0x76, 0x70, 0xd0, 0x1a, 0x0e, 0x99,
	0x68, 0xf9, 0x76, 0x9f, 0x0f, 0xa0, 0x81, 0x5f, 0x58, 0xc3, 0x89, 0x8d, 0x8d, 0xc0, 0x1b, 0x1d,
	0x92, 0xc0, 0x73, 0xb1, 0xc1, 0xfa, 0x4d, 0x84, 0x59, 0xdd, 0x10, 0xf8, 0x81, 0x44, 0xf3, 0xd6,
	0xb4, 0x53, 0x58, 0x4f, 0xb6, 0x9e, 0x4b, 0x33, 0x6f, 0xc0, 0x72, 0xd8, 0xda, 0xe2, 0xec, 0x10,
	0x08, 0xa4, 0xf6, 0xdb, 0xdc, 0xf0, 0xc4, 0xba, 0x9b, 0xa7, 0xa3, 0x77, 0x00, 0xf8, 0x6a, 0x6d,
	0x9c, 0xe2, 0x29, 0xeb, 0x5a, 0x55, 0x2f, 0x73, 0xc8, 0x53, 0x3c, 0x45, 0xaf, 0x41, 0xd5, 0xc5,
	0xd8, 0x36, 0x0e, 0x27, 0xd6, 0x29, 0x16, 0x86, 0x57, 0xd2, 0x2b, 0x14, 0xb6, 0xc5, 0x41, 0xda,
	0x5f, 0x15, 0x60, 0x2d, 0x26, 0x43, 0xae, 0xee, 0x46, 0x3b, 0x4a, 0xe1, 0xa2, 0x1d, 0x05, 0xbd,
	0x0e, 0xcb, 0xc3, 0xb8, 0x8b, 0x5f, 0x95, 0x74, 0x3d, 0x4c, 0xb9, 0x71, 0x1c, 0x7a, 0x0c, 0x60,
	0x7b, 0xe7, 0xae, 0x31, 0xc6, 0xd8, 0x27, 0x8d, 0x25, 0xa6, 0x40, 0xb1, 0x6d, 0x52, 0x3a, 0x3e,
	0x55, 0xca, 0x94, 0x84, 0x16, 0x09, 0x7a, 0x0f, 0x6a, 0x63, 0xec, 0xda, 0x8e, 0x7b, 0x2c, 0xaa,
	0x2c, 0xb3, 0x2a, 0x49, 0xe6, 0x55, 0x41, 0xc2, 0xab, 0xbc, 0x05, 0x2b, 0x52, 0x25, 0x2b, 0x62,
	0x5b, 0x16, 0xc4, 0x42, 0x2d, 0xba, 0xc4, 0x7f, 0x52, 0x2c, 0x15, 0xd5, 0x25, 0xed, 0x77, 0x15,
	0x66, 0x17, 0xbc, 0x3f, 0x5b, 0xd3, 0x7c, 0xcb, 0x38, 0x75, 0x3e, 0xc5, 0x68, 0x45, 0xce, 0x27,
	0x07, 0x30, 0x5f, 0xf2, 0xd2, 0xb1, 0xfa, 0xa1, 0x02, 0xa8, 0x6f, 0x99, 0x2e, 0x17, 0x83, 0xe4,
	0x95, 0x81, 0x04, 0xa6, 0x1f, 0xc4, 0x0c, 0xa6, 0xc4, 0x00, 0xd4, 0x5e, 0xd6, 0x61, 0x69, 0xe8,
	0x8c, 0x1c, 0xee, 0x9f, 0x2d, 0xe9, 0xbc, 0x80, 0x36, 0x60, 0x05, 0xbb, 0x36, 0xab, 0x50, 0x64,
	0x15, 0x96, 0xb1, 0x6b, 0x3f, 0xc5, 0x53, 0xed, 0x9f, 0x15, 0x58, 0xe6, 0xb2, 0xc4, 0x4c, 0x40,
	0xb9, 0xa2, 0x09, 0x14, 0xae, 0x6c, 0x02, 0x8b, 0x2f, 0x6f, 0x02, 0xc5, 0xcb, 0x4c, 0x40, 0xfb,
	0x17, 0x05, 0xae, 0x25, 0x74, 0x99, 0xcb, 0xf2, 0xdf, 0x83, 0xaa, 0x18, 0x51, 0xda, 0x92, 0x9c,
	0xee, 0xe9, 0xce, 0x57, 0x38, 0xcd, 0x1e, 0x25, 0x41, 0x6f, 0xc2, 0x0a, 0xef, 0xa5, 0xec, 0x58,
	0x52, 0x4a, 0x89, 0xa4, 0x74, 0xbc, 0x5a, 0xd4, 0x1b, 0x21, 0x09, 0xe3, 0x29, 0x91, 0xda, 0x13,
	0xd8, 0xd8, 0xc1, 0xc1, 0x36, 0x8f, 0x49, 0x92, 0xa1, 0xe5, 0x4b, 0x6d, 0xe3, 0x04, 0x1a, 0xb3,
	0x7c, 0x72, 0x29, 0xe5, 0x2d, 0x58, 0x11, 0x21, 0x92, 0x18, 0xe4, 0x70, 0x76, 0x09, 0xee, 0xba,
	0xc4, 0x6b, 0x9f, 0xc3, 0x46, 0x6f, 0xf2, 0xea, 0xc2, 0xbf, 0x4c, 0x93, 0x1f, 0x43, 0x63, 0xb6,
	0xc9, 0x3c, 0xfd, 0xd4, 0xfe, 0xba, 0x00, 0xcb, 0x7b, 0x78, 0x74, 0x88, 0xfd, 0xcc, 0x90, 0xf8,
	0x16, 0x94, 0x47, 0x0c, 0x1b, 0x9b, 0xed, 0x1c, 0xc0, 0xe3, 0x50, 0x6a, 0xa9, 0xc6, 0xc4, 0x1f,
	0x72, 0x3b, 0x28, 0xeb, 0x25, 0x0a, 0x78, 0xe6, 0x0f, 0x79, 0xf0, 0x3f, 0x74, 0xb0, 0x1b, 0x70,
	0x74, 0x91, 0xa1, 0x81, 0x83, 0x18, 0xc1, 0xff, 0x83, 0x55, 0x6e, 0x26, 0xc6, 0xd8, 0x77, 0x3c,
	0xdf, 0x09, 0xa6, 0x2c, 0x2e, 0x5e, 0xd2, 0xeb, 0x1c, 0xdc, 0x13, 0x50, 0x16, 0x5a, 0xe1, 0xf1,
	0xd0, 0x9b, 0xf2, 0x34, 0xc2, 0xb2, 0x08, 0xad, 0x18, 0x88, 0x65, 0x7f, 0xde, 0x80, 0xfa, 0xa1,
	0xe3, 0x9a, 0xfe, 0xd4, 0x38, 0xc3, 0x3e, 0x4b, 0x01, 0xac, 0x30, 0x9a, 0x1a, 0x87, 0x3e, 0xe7,
	0x40, 0xea, 0x3d, 0x1d, 0x3b, 0x81, 0x71, 0x62, 0x92, 0x93, 0x46, 0x89, 0x07, 0xa6, 0xc7, 0x4e,
	0xf0, 0xb1, 0x49, 0x4e, 0xd2, 0xd1, 0x5b, 0x79, 0x26, 0x7a, 0xfb, 0x15, 0xb6, 0xc1, 0x70, 0x45,
	0xe5, 0x5a, 0xb3, 0xb4, 0xff, 0x29, 0x00, 0x8a, 0xb3, 0xc8, 0xb9, 0x49, 0xad, 0x70, 0xed, 0xcb,
	0x59, 0x2a, 0xe6, 0x13, 0xe7, 0xaa, 0x4b, 0x64, 0xc6, 0x26, 0x15, 0x27, 0x93, 0x2b, 0xd4, 0x57,
	0xa1, 0x82, 0x03, 0xcb, 0x36, 0x04, 0x69, 0x31, 0x83, 0x14, 0x28, 0xc1, 0x2e, 0x27, 0xc7, 0x70,
	0x3d, 0x20, 0x9e, 0x61, 0x0e, 0x99, 0x9e, 0x3c, 0xdf, 0x90, 0x4b, 0x00, 0xdf, 0xde, 0xde, 0x13,
	0x19, 0x9a, 0x99, 0x3e, 0x3e, 0x1e, 0x10, 0xaf, 0x25, 0x2b, 0x71, 0x5e, 0xa4, 0xe3, 0x06, 0xfe,
	0x54, 0xbf, 0x16, 0xcc, 0x62, 0x9a, 0x03, 0x68, 0xcc, 0xab, 0x80, 0x54, 0x58, 0xa4, 0x2b, 0x38,
	0xb7, 0x50, 0xfa, 0x89, 0xb4, 0x78, 0xce, 0x26, 0x2d, 0x3d, 0x47, 0x7d, 0x58, 0xf8, 0x40, 0xd1,
	0x3a, 0x70, 0x3d, 0x5a, 0x19, 0xba, 0xee, 0x51, 0x98, 0x85, 0x78, 0xb9, 0xe9, 0xf2, 0x9b, 0x70,
	0x23, 0xcd, 0x26, 0xd7, 0x40, 0xfe, 0x7f, 0xa8, 0x12, 0xec, 0x9f, 0x39, 0x16, 0xde, 0xf3, 0x6c,
	0xe1, 0x62, 0xd5, 0x37, 0xd7, 0x84, 0x37, 0x1d, 0x61, 0xf4, 0x04, 0x99, 0xd6, 0x83, 0x72, 0xb8,
	0x77, 0xa0, 0xfb, 0x50, 0xa4, 0xb3, 0x4d, 0xb4, 0x97, 0x5c, 0x81, 0x19, 0x86, 0x6e, 0xc7, 0x6c,
	0x0b, 0x22, 0xd8, 0xf2, 0x5c, 0x9b, 0x88, 0x09, 0x5c, 0xa1, 0xb0, 0x3e, 0x07, 0x69, 0x3f, 0x5b,
	0x82, 0x1b, 0x7c, 0x35, 0xfe, 0x18, 0x9b, 0x7e, 0x70, 0x88, 0xcd, 0x20, 0xd7, 0xe2, 0xf5, 0x65,
	0xba, 0x4f, 0xc5, 0x97, 0xdf, 0x3b, 0x97, 0x2e, 0x75, 0x9f, 0x1e, 0x40, 0xed, 0x70, 0x1a, 0x60,
	0x62, 0x9c, 0xfb, 0x4e, 0x10, 0x60, 0x97, 0xad, 0x2b, 0x45, 0xbd, 0xca, 0x80, 0x9f, 0x72, 0x18,
	0x75, 0x4d, 0x39, 0x91, 0x8f, 0x4d, 0x9b, 0xad, 0x2a, 0x45, 0xbd, 0xcc, 0x20, 0x3a, 0x36, 0x99,
	0xbb, 0x73, 0x8a, 0xa7, 0x11, 0x8b, 0x12, 0xd7, 0x2f, 0x85, 0x49, 0x0e, 0xb7, 0xa0, 0xcc, 0x48,
	0x18, 0x83, 0x32, 0x5f, 0x40, 0x29, 0x80, 0xd5, 0x7f, 0x0b, 0x54, 0x73, 0x3c, 0xf6, 0xbd, 0x17,
	0xce, 0xc8, 0x0c, 0xb0, 0x41, 0x9c, 0xef, 0xe0, 0x06, 0x30, 0x9a, 0xd5, 0x18, 0xbc, 0xef, 0x7c,
	0x07, 0xa3, 0xc7, 0x50, 0x72, 0xdc, 0x00, 0xfb, 0x67, 0xe6, 0xb0, 0x51, 0x65, 0x9a, 0x43, 0x51,
	0x16, 0xa6, 0x2b, 0x30, 0x7a, 0x48, 0x93, 0x66, 0x4d, 0x9b, 0x6c, 0xd4, 0x66, 0x58, 0x3f, 0xc5,
	0x53, 0x42, 0xd7, 0xfd, 0x00, 0xfb, 0xa3, 0x46, 0x9d, 0xa1, 0xd9, 0x37, 0xfa, 0xb5, 0xcc, 0xb0,
	0x68, 0x95, 0x35, 0xfc, 0x95, 0xec, 0xb0, 0x88, 0xfb, 0xde, 0x97, 0x07, 0x47, 0xe8, 0x3d, 0xa8,
	0x7c, 0x3e, 0xc1, 0xfe, 0xd4, 0xe0, 0x81, 0xa4, 0x1a, 0x0f, 0x24, 0x7f, 0x95, 0x22, 0xf8, 0xf0,
	0xc2, 0xe7, 0xe1, 0x37, 0xd5, 0xa2, 0x35, 0x9e, 0x18, 0x13, 0x96, 0x54, 0x5c, 0xe3, 0x5a, 0xb4,
	0xc6, 0x93, 0x67, 0xb4, 0x8c, 0x1e, 0xc3, 0xb5, 0x44, 0x57, 0xcf, 0xb8, 0x22, 0x11, 0x23, 0x5b,
	0x8b, 0xf7, 0xf6, 0x8c, 0xaa, 0xf2, 0x93, 0x62, 0xa9, 0xa2, 0x56, 0xb5, 0x13, 0x80, 0x6d, 0x96,
	0x39, 0xa7, 0xe6, 0x70, 0x85, 0xb9, 0xf4, 0x01, 0x54, 0x78, 0xa6, 0xdd, 0x60, 0x19, 0xd0, 0x02,
	0xcb, 0x80, 0x6e, 0x3c, 0x96, 0x47, 0x23, 0x74, 0x13, 0xe6, 0xfc, 0x58, 0x26, 0x14, 0xac, 0xf0,
	0x5b, 0xfb, 0x10, 0xaa, 0x51, 0x4b, 0xcf, 0x37, 0xd1, 0xa3, 0x74, 0x6a, 0x5f, 0xf4, 0x3d, 0x22,
	0x0a, 0x93, 0xfa, 0xda, 0x73, 0xa8, 0x0f, 0x7c, 0xd3, 0x25, 0x47, 0x58, 0x2c, 0x84, 0x57, 0x90,
	0x54, 0x83, 0x25, 0x3e, 0x09, 0x0a, 0x19, 0x93, 0x80, 0xa3, 0xb4, 0x77, 0x60, 0x69, 0x0f, 0xfb,
	0xc7, 0x2c, 0x91, 0x16, 0x98, 0xfe, 0x31, 0x0e, 0xe6, 0xf9, 0xbc, 0x1c, 0xab, 0xed, 0x42, 0xa5,
	0x3f, 0x1e, 0x3a, 0x22, 0x7a, 0x40, 0x6f, 0xc1, 0xf2, 0xd8, 0x1b, 0x3a, 0xd6, 0x54, 0xa4, 0x82,
	0xd7, 0x64, 0x17, 0xb0, 0x75, 0xda, 0x63, 0x08, 0x5d, 0x10, 0x50, 0xf3, 0x62, 0xd6, 0x47, 0xa5,
	0xa9, 0xea, 0xec, 0x5b, 0xdb, 0x81, 0x5a, 0xff, 0xdc, 0x09, 0xac, 0x93, 0x4f, 0x9d, 0xc0, 0xc5,
	0x84, 0x50, 0xf7, 0x9c, 0xb9, 0x12, 0x61, 0x82, 0x7a, 0x99, 0x16, 0xbb, 0x36, 0x9d, 0x81, 0x0e,
	0x31, 0xce, 0x39, 0x99, 0x88, 0x7b, 0xcb, 0x0e, 0x11, 0xf5, 0xb4, 0x01, 0xa0, 0x2d, 0x33, 0xb0,
	0x4e, 0x92, 0xdc, 0x3e, 0x02, 0x95, 0x30, 0x80, 0xac, 0x18, 0xaa, 0x5a, 0xac, 0x61, 0x09, 0x72,
	0x7d, 0x95, 0xc4, 0x8b, 0x98, 0x68, 0x7f, 0x5a, 0x84, 0x8d, 0x99, 0x45, 0x31, 0xa7, 0x6f, 0x2d,
	0xad, 0x86, 0x0d, 0x5a, 0x21, 0x6e, 0xeb, 0xb1, 0xf1, 0x16, 0xe6, 0xc2, 0x4c, 0xf1, 0x1b, 0xb0,
	0x1a, 0x88, 0x21, 0x37, 0x86, 0x19, 0x87, 0x49, 0x49, 0x7b, 0xd0, 0xeb, 0x41, 0xd2, 0x3e, 0x12,
	0xf1, 0x59, 0x31, 0x15, 0x9f, 0x7d, 0x3d, 0x74, 0xf5, 0xf1, 0xd8, 0xb3, 0x4e, 0x98, 0xc3, 0x45,
	0x95, 0x92, 0x18, 0xf3, 0x0e, 0x45, 0x49, 0x7f, 0x9f, 0x15, 0xa8, 0xa7, 0xc0, 0xed, 0x80, 0x77,
	0x63, 0x39, 0xc3, 0xf6, 0x80, 0x13, 0xf4, 0xf8, 0xbe, 0xb3, 0x34, 0xa2, 0xd6, 0x25, 0x02, 0xd3,
	0x8a, 0xdc, 0x94, 0xfd, 0x63, 0xac, 0x73, 0x0c, 0x7a, 0x1f, 0xaa, 0x84, 0xda, 0x93, 0x21, 0x76,
	0x8d, 0x12, 0xa3, 0x94, 0x1b, 0x60, 0x64, 0x69, 0x7a, 0x85, 0xc4, 0xcc, 0xee, 0x03, 0xa8, 0xc7,
	0xd4, 0x69, 0x9c, 0x6d, 0xb2, 0x25, 0x35, 0x5c, 0x0b, 0xe3, 0xd3, 0x4c, 0xaf, 0x5a, 0xf1, 0x49,
	0xb7, 0x9d, 0x61, 0x12, 0xc0, 0xea, 0x36, 0x78, 0xdd, 0x59, 0x33, 0x9a, 0xb5, 0x8b, 0x23, 0x58,
	0x6d, 0x91, 0x53, 0x21, 0xdd, 0x97, 0xb7, 0x49, 0x6a, 0xbf, 0xa7, 0x80, 0x1a, 0x35, 0x94, 0x33,
	0xa1, 0x5b, 0x73, 0xf1, 0xb9, 0x91, 0x0e, 0xd5, 0x2b, 0x2e, 0x3e, 0xd7, 0xa5, 0x35, 0xdc, 0xa7,
	0xd1, 0xfa, 0xb9, 0x21, 0x26, 0x1e, 0x77, 0xe1, 0x8b, 0x3a, 0xb8, 0xf8, 0xbc, 0xc7, 0x26, 0x1f,
	0xd1, 0xfe, 0x40, 0x01, 0xa4, 0xe3, 0xb1, 0xe7, 0x07, 0xf9, 0x3b, 0xad, 0x41, 0x71, 0x88, 0x8f,
	0x82, 0x39, 0x5d, 0x66, 0x38, 0xf4, 0x3a, 0x2c, 0xf9, 0xce, 0xf1, 0x49, 0x30, 0x27, 0x9b, 0xcf,
	0x91, 0xda, 0x36, 0x5c, 0x4b, 0x08, 0x93, 0x2b, 0xe0, 0xf9, 0x81, 0x02, 0xeb, 0x2d, 0x72, 0xca,
	0x87, 0xfb, 0xcb, 0x1e, 0x49, 0x76, 0x64, 0xc3, 0xcc, 0x3c, 0x7e, 0x64, 0x04, 0x0c, 0xb4, 0x4d,
	0x21, 0xda, 0x01, 0xac, 0x30, 0x29, 0xba, 0xed, 0xd9, 0x21, 0x53, 0x2e, 0x1f, 0xb2, 0xc2, 0xcc,
	0x90, 0x1d, 0xc1, 0xf5, 0x54, 0xf7, 0x72, 0xd9, 0xcf, 0x3d, 0x58, 0x94, 0xfc, 0x2b, 0x9b, 0xb5,
	0xd8, 0xb4, 0xec, 0xb6, 0x75, 0x8a, 0xd1, 0xc6, 0x74, 0x89, 0xa4, 0x83, 0xf1, 0x8a, 0x9a, 0x7c,
	0x18, 0xa5, 0x08, 0xb2, 0x13, 0x0f, 0x61, 0x92, 0xe0, 0x63, 0x68, 0xcc, 0xb6, 0x98, 0xcb, 0x06,
	0xbe, 0x05, 0xd5, 0xb8, 0xdb, 0x44, 0x43, 0x51, 0x9e, 0x4f, 0x8a, 0x4e, 0xba, 0xb8, 0xee, 0xeb,
	0x0c, 0x1c, 0x9d, 0xdb, 0x3d, 0x80, 0x1a, 0x76, 0xed, 0x18, 0x19, 0x9f, 0x55, 0x55, 0xec, 0xda,
	0x21, 0x91, 0xf6, 0x3e, 0x80, 0x8e, 0x2d, 0xcf, 0xb7, 0x7b, 0xa6, 0xe3, 0x67, 0x84, 0x2c, 0x89,
	0x63, 0xe6, 0xa2, 0x08, 0x52, 0xb4, 0xff, 0x50, 0xa0, 0x24, 0x7d, 0xdb, 0xe4, 0x22, 0xae, 0xa4,
	0x16, 0x71, 0x86, 0x34, 0x6d, 0x43, 0xec, 0xaa, 0x02, 0x69, 0xda, 0xcc, 0x99, 0x63, 0xc9, 0x54,
	0xd3, 0x36, 0x98, 0x93, 0xca, 0xec, 0xad, 0xa8, 0x33, 0xf2, 0x2d, 0x0a, 0x48, 0xfb, 0x5e, 0xc5,
	0x2b, 0xf8, 0x5e, 0xaf, 0x41, 0x55, 0xf8, 0xb7, 0xbc, 0xc5, 0x25, 0x6e, 0x95, 0x02, 0xc6, 0x1a,
	0x7d, 0x00, 0x35, 0x49, 0xc2, 0xdb, 0x15, 0xbe, 0xb4, 0x00, 0xb2, 0xa6, 0xb5, 0x7f, 0x28, 0x01,
	0x44, 0xe7, 0x04, 0x89, 0xb3, 0x0c, 0x25, 0x71, 0x96, 0x81, 0x9a, 0x50, 0xb2, 0xcc, 0xb1, 0x69,
	0x39, 0xc1, 0x54, 0xf6, 0x4f, 0x96, 0xd1, 0x6d, 0x28, 0x9b, 0x67, 0xa6, 0x33, 0x34, 0x0f, 0x87,
	0x58, 0x76, 0x2f, 0x04, 0x50, 0x59, 0x85, 0xde, 0xf8, 0x7c, 0x2b, 0xb2, 0xf9, 0x26, 0xb6, 0x32,
	0x36, 0xe1, 0xd0, 0xdb, 0x80, 0x88, 0x08, 0x15, 0x88, 0x6b, 0x8e, 0x05, 0xe1, 0x12, 0x23, 0x54,
	0x05, 0xa6, 0xef, 0x9a, 0x63, 0x4e, 0xfd, 0x2e, 0xac, 0xfb, 0xd8, 0xc2, 0xce, 0x59, 0x8a, 0x7e,
	0x99, 0xd1, 0xa3, 0x10, 0x17, 0xd5, 0xb8, 0x03, 0x10, 0xd9, 0x12, 0xdb, 0x00, 0x6b, 0x7a, 0x39,
	0x34, 0x23, 0xe1, 0xac, 0x0e, 0xa7, 0x29, 0x7e, 0x25, 0x46, 0xb7, 0x26, 0x51, 0x11, 0xbb, 0x0d,
	0x58, 0x71, 0x88, 0x71, 0x38, 0x21, 0x53, 0xb6, 0xd5, 0x95, 0xf4, 0x65, 0x87, 0x6c, 0x4d, 0xc8,
	0x94, 0x5a, 0xc1, 0x84, 0x60, 0x3b, 0x1e, 0x34, 0x94, 0x28, 0x80, 0x45, 0x0b, 0x33, 0xc1, 0x4d,
	0x25, 0x23, 0xb8, 0x49, 0x47, 0x2f, 0xd5, 0xd9, 0xe8, 0x25, 0x19, 0xff, 0xd4, 0xd2, 0xf1, 0x4f,
	0x22, 0xb8, 0xa9, 0xa7, 0x82, 0x9b, 0x78, 0xc4, 0xb2, 0x7a, 0x85, 0x88, 0xe5, 0x1d, 0x80, 0xd0,
	0xc7, 0xa7, 0x51, 0x41, 0xcc, 0x33, 0x8e, 0xa6, 0x93, 0x5e, 0x96, 0x6e, 0x3f, 0x41, 0xef, 0x43,
	0x8d, 0x99, 0xba, 0xe3, 0x19, 0xbe, 0x49, 0xad, 0x6e, 0x6d, 0x4e, 0x9d, 0x0a, 0x25, 0xeb, 0x7a,
	0x3a, 0x25, 0x42, 0x5f, 0x87, 0x3a, 0xed, 0x30, 0x8e, 0xaa, 0xa1, 0x39, 0xd5, 0x98, 0xf9, 0x62,
	0x59, 0xef, 0x6b, 0x50, 0xf5, 0xc6, 0xc6, 0xd0, 0x0c, 0xb0, 0x6b, 0x39, 0x98, 0x34, 0xae, 0xcd,
	0x6b, 0xcc, 0x1b, 0xef, 0x4a, 0x22, 0xf4, 0x55, 0x00, 0xb6, 0x54, 0xf3, 0xd9, 0xb6, 0x2e, 0xd6,
	0xb7, 0x44, 0x1c, 0xab, 0xb3, 0x1c, 0x1a, 0x9f, 0x13, 0xa9, 0xd9, 0x79, 0xfd, 0x0a, 0xb3, 0x93,
	0x9a, 0xdb, 0xd0, 0x3b, 0x37, 0x88, 0xe5, 0xf9, 0xb8, 0x71, 0x83, 0x8f, 0x10, 0x85, 0xf4, 0x29,
	0x80, 0x5a, 0xbb, 0x6d, 0x8e, 0xcc, 0x63, 0x6c, 0x8b, 0x7d, 0x85, 0xd0, 0xf9, 0xb6, 0xc1, 0x76,
	0x0d, 0x55, 0x60, 0x44, 0xf6, 0xb8, 0x6b, 0xd3, 0x1d, 0xc8, 0x21, 0x06, 0x33, 0x42, 0x6e, 0x72,
	0x0d, 0x9e, 0xbf, 0x77, 0x48, 0x8b, 0xc2, 0x98, 0xdd, 0xfd, 0x22, 0xd4, 0x89, 0x38, 0x27, 0x15,
	0x62, 0xde, 0x64, 0xdd, 0x12, 0x83, 0x2b, 0xcf, 0x50, 0x59, 0xd7, 0x6a, 0x24, 0x56, 0x22, 0x34,
	0xaa, 0x67, 0xb2, 0x06, 0x3e, 0x76, 0xed, 0x46, 0x33, 0x7e, 0x97, 0xa0, 0x3f, 0xf4, 0xce, 0x07,
	0x14, 0xcc, 0x85, 0x67, 0x9f, 0xda, 0x1f, 0x2a, 0x50, 0x0e, 0x11, 0x2c, 0xa1, 0x68, 0x4e, 0x08,
	0x36, 0xf8, 0xe2, 0x49, 0xd7, 0x0c, 0x45, 0x07, 0x06, 0x7a, 0xce, 0x2e, 0xea, 0xdc, 0x01, 0x5e,
	0x62, 0xc3, 0xca, 0x16, 0x0e, 0x45, 0x2f, 0x33, 0x08, 0x1d, 0x41, 0xbe, 0x36, 0x90, 0xc9, 0x30,
	0x10, 0x0c, 0x16, 0x19, 0x41, 0x85, 0xc3, 0x38, 0x87, 0x7b, 0x20, 0x8a, 0x9c, 0x45, 0x91, 0x37,
	0xc1, 0x41, 0x94, 0x87, 0xf6, 0x13, 0x05, 0xaa, 0xf1, 0x1e, 0x5e, 0xbc, 0x50, 0x6f, 0xc2, 0xf5,
	0x63, 0xec, 0x62, 0xca, 0xcb, 0xb0, 0x27, 0xbe, 0x08, 0xa5, 0xb1, 0x25, 0x16, 0xb5, 0x6b, 0x12,
	0xd9, 0x16, 0xb8, 0x3e, 0xb6, 0xd0, 0x23, 0x58, 0xa3, 0x8b, 0x50, 0x92, 0x9e, 0xaf, 0x73, 0xab,
	0x14, 0x11, 0xa7, 0x7d, 0x1b, 0x50, 0xe0, 0x05, 0xe6, 0x30, 0x49, 0xcc, 0x7d, 0x7e, 0x95, 0x61,
	0xe2, 0xd4, 0x6f, 0x00, 0x0f, 0x15, 0xe8, 0x0e, 0xca, 0x57, 0x0d, 0xbe, 0x92, 0xd7, 0x42, 0x28,
	0x5d, 0x3a, 0x68, 0x17, 0x81, 0x39, 0xf4, 0x6c, 0xab, 0x45, 0xbf, 0x0c, 0xc0, 0xaf, 0xfb, 0x05,
	0x54, 0x23, 0x7c, 0x73, 0xbd, 0xf3, 0x38, 0x79, 0x03, 0x50, 0x37, 0x8f, 0x82, 0x5d, 0xcf, 0x32,
	0x87, 0x54, 0x25, 0x58, 0x2f, 0x53, 0x2c, 0xfb, 0x44, 0x5b, 0xe1, 0x7a, 0xcc, 0xeb, 0x73, 0x67,
	0xe9, 0x5e, 0xba, 0x3e, 0x23, 0x89, 0x71, 0x10, 0x0b, 0x36, 0xe7, 0xf1, 0x26, 0xac, 0x3a, 0xc4,
	0x38, 0xf2, 0x7c, 0x0b, 0xc7, 0xe3, 0xa1, 0x92, 0x5e, 0x73, 0xc8, 0x13, 0x0a, 0xdd, 0x95, 0x8e,
	0x84, 0x7a, 0x62, 0x12, 0xc3, 0xf2, 0x46, 0x23, 0x27, 0x30, 0x78, 0xfc, 0x51, 0x64, 0x84, 0xf5,
	0x13, 0x93, 0x6c, 0x33, 0x30, 0x0b, 0x41, 0xb4, 0xe7, 0x50, 0x11, 0x47, 0xc6, 0xac, 0x8b, 0x5f,
	0x83, 0x2a, 0x9b, 0xa4, 0x3e, 0x2b, 0xa6, 0x82, 0xf2, 0x48, 0x15, 0x7a, 0x65, 0x1c, 0x7e, 0xb3,
	0xa4, 0x09, 0x09, 0xb0, 0x74, 0x00, 0xd8, 0xb7, 0xf6, 0xdf, 0x0a, 0x5c, 0x67, 0x8c, 0x5f, 0x35,
	0x95, 0x26, 0x8e, 0xd8, 0x0b, 0x17, 0x1e, 0xb1, 0xb3, 0x10, 0x8a, 0xed, 0xa0, 0x5c, 0x70, 0xe1,
	0x3b, 0xaf, 0xc5, 0xc8, 0xa5, 0xe0, 0x24, 0xd6, 0xdb, 0x4f, 0x01, 0xd9, 0xbe, 0x61, 0x4e, 0x02,
	0x8f, 0x4c, 0x5d, 0x4b, 0x66, 0x76, 0xb8, 0x23, 0xf0, 0x56, 0x56, 0x66, 0x87, 0x71, 0x6a, 0xeb,
	0xad, 0x49, 0xe0, 0xf5, 0xa7, 0xae, 0x25, 0xf2, 0x3a, 0xaa, 0xed, 0xb7, 0x04, 0x0f, 0x71, 0xe6,
	0x6d, 0x03, 0x6a, 0xe3, 0x91, 0x17, 0xe0, 0x27, 0xa6, 0x33, 0xc4, 0xf6, 0x73, 0x2f, 0xc0, 0x3e,
	0xb9, 0x78, 0x82, 0xbc, 0x07, 0xb5, 0x23, 0x46, 0x6c, 0x9c, 0x31, 0xea, 0xcc, 0x8c, 0x45, 0xf5,
	0x28, 0xc6, 0x4f, 0x3b, 0x84, 0x4a, 0x7c, 0xd0, 0x1f, 0x84, 0x1c, 0xc4, 0x59, 0xb5, 0xc2, 0x96,
	0x36, 0x51, 0x87, 0x9f, 0x7f, 0xd3, 0x3d, 0x17, 0xd3, 0x5d, 0x26, 0x61, 0x44, 0xd2, 0x77, 0x5e,
	0x63, 0xa8, 0x18, 0x4f, 0xa2, 0x7d, 0xb7, 0x00, 0x55, 0x71, 0x07, 0x64, 0xda, 0x1b, 0x9a, 0x2e,
	0xf5, 0x51, 0x2d, 0x1f, 0xb3, 0xcd, 0x42, 0xc9, 0xf6, 0x51, 0x05, 0x1a, 0xbd, 0x0d, 0x2b, 0x93,
	0xb1, 0xcd, 0x28, 0x33, 0xbd, 0xd9, 0xad, 0x42, 0x43, 0xd1, 0x25, 0x09, 0xba, 0x0b, 0x10, 0x1e,
	0xed, 0x87, 0xe1, 0x57, 0x04, 0x41, 0x9b, 0xb0, 0x62, 0x33, 0x95, 0xca, 0x1c, 0xa8, 0x88, 0x55,
	0x67, 0xf5, 0xac, 0x4b, 0x42, 0x6a, 0x15, 0x89, 0xb9, 0xb2, 0x14, 0xb7, 0x8a, 0x58, 0x37, 0xf5,
	0xca, 0x51, 0x4c, 0x8f, 0xd2, 0x9c, 0x97, 0x63, 0xe6, 0xfc, 0x01, 0xd4, 0x5a, 0xe7, 0xe6, 0x29,
	0x96, 0xc7, 0x8b, 0xd4, 0x4d, 0x36, 0x0f, 0x5d, 0xcf, 0x1f, 0x99, 0xc3, 0xa4, 0xba, 0xeb, 0x12,
	0x2c, 0x2e, 0x20, 0xfc, 0xac, 0x00, 0x37, 0xd2, 0x13, 0xe1, 0xe7, 0xe7, 0x76, 0x06, 0xed, 0x87,
	0xbc, 0x10, 0x29, 0x0f, 0x8c, 0xf8, 0xcd, 0xc1, 0xba, 0x00, 0xcb, 0x13, 0xa3, 0x0f, 0x61, 0xc3,
	0xc7, 0x9f, 0x4f, 0x1c, 0x1f, 0x1b, 0x36, 0x0e, 0xb8, 0x9d, 0x89, 0xc9, 0xc6, 0x56, 0x16, 0x36,
	0x9a, 0xd7, 0x05, 0x49, 0x5b, 0x50, 0x88, 0x79, 0xf6, 0x0b, 0xd4, 0x3b, 0xe1, 0x36, 0x64, 0x8c,
	0x87, 0xa6, 0x2b, 0x06, 0x02, 0x45, 0x0e, 0x83, 0x34, 0x2f, 0xbd, 0xea, 0xc7, 0x8d, 0xed, 0x43,
	0xa8, 0x9b, 0x4c, 0xed, 0x72, 0xc7, 0x16, 0xe9, 0x16, 0xb1, 0x66, 0x24, 0x86, 0x44, 0xaf, 0x99,
	0xf1, 0xa2, 0xf6, 0xfd, 0x02, 0xac, 0xf7, 0x2d, 0x33, 0x08, 0xe8, 0x42, 0x95, 0xfb, 0x42, 0xc6,
	0xbd, 0x99, 0x23, 0x7e, 0xd6, 0xd1, 0x68, 0xde, 0x5e, 0xf1, 0xf6, 0x5d, 0x2c, 0xd9, 0x5f, 0xbc,
	0x20, 0xd9, 0xbf, 0x0e, 0x4b, 0xc7, 0xbe, 0x37, 0x19, 0x33, 0x0d, 0x95, 0x75, 0x5e, 0x88, 0x6e,
	0x85, 0x30, 0x8f, 0x65, 0x99, 0xd9, 0x99, 0x10, 0x8b, 0xba, 0x2a, 0x6c, 0xab, 0x0e, 0xfc, 0xa9,
	0xc1, 0xcf, 0xfa, 0x79, 0x6a, 0x1e, 0x18, 0x68, 0x97, 0x42, 0xb4, 0x33, 0xb8, 0x9e, 0xd2, 0x44,
	0x2e, 0x0b, 0x7c, 0x07, 0xae, 0x1d, 0x39, 0xae, 0x43, 0x4e, 0xb0, 0x6d, 0x8c, 0xb1, 0x6f, 0x61,
	0x37, 0x90, 0x17, 0x5b, 0x8b, 0x3a, 0x92, 0xa8, 0x5e, 0x88, 0xd1, 0xda, 0xec, 0xa0, 0x69, 0x67,
	0xbb, 0x6f, 0x1e, 0xe1, 0x9e, 0xe7, 0xb8, 0xb9, 0xf6, 0x00, 0x0d, 0xb3, 0x73, 0xa6, 0x04, 0x97,
	0x5c, 0xe2, 0x53, 0xf7, 0xd0, 0x3c, 0xc2, 0xc6, 0x98, 0xf2, 0x10, 0x52, 0x97, 0x89, 0x64, 0xaa,
	0x1d, 0x41, 0xe3, 0x19, 0x5b, 0x8b, 0x5e, 0x51, 0xde, 0xcb, 0xda, 0xf1, 0xe0, 0x66, 0x46, 0x3b,
	0xb9, 0x7a, 0xf4, 0x3a, 0xd4, 0x5d, 0x7c, 0x6e, 0xcc, 0xb4, 0x56, 0x75, 0xf1, 0x79, 0xc8, 0x5b,
	0xfb, 0x91, 0x02, 0xf7, 0x78, 0x8b, 0xe2, 0x30, 0xed, 0x8b, 0xe8, 0x20, 0xe7, 0x24, 0x27, 0x45,
	0x55, 0x2f, 0x0b, 0x48, 0xd7, 0xa6, 0x51, 0xfe, 0x60, 0xb0, 0xcb, 0xa6, 0xc3, 0xa2, 0x4e, 0x3f,
	0x53, 0x1a, 0x29, 0xa6, 0x35, 0xf2, 0xb7, 0x0a, 0xdc, 0x9f, 0x2f, 0x60, 0xee, 0xb1, 0x7e, 0x29,
	0x11, 0x5f, 0x87, 0xfa, 0xc8, 0x71, 0x8d, 0x19, 0x31, 0xab, 0x23, 0xc7, 0x8d, 0x54, 0xf9, 0x47,
	0x0a, 0x80, 0x1e, 0xfa, 0x63, 0xb3, 0xa1, 0xa5, 0x72, 0xe9, 0xb9, 0x59, 0xe1, 0xb2, 0x73, 0xb3,
	0xc5, 0x4b, 0xce, 0xcd, 0x8a, 0xc9, 0xd0, 0x52, 0xfb, 0x9e, 0x02, 0x6b, 0xd4, 0x17, 0x79, 0x85,
	0x35, 0xee, 0x75, 0x58, 0xe6, 0x87, 0xe5, 0x99, 0x07, 0xc7, 0x02, 0xc7, 0xd2, 0x77, 0x2c, 0x98,
	0x77, 0x5c, 0x1b, 0xbf, 0x10, 0x72, 0xf2, 0xf8, 0xbe, 0x4b, 0x21, 0xda, 0x8f, 0x0b, 0x80, 0xe2,
	0x92, 0xe4, 0x1a, 0xb8, 0x2b, 0xa7, 0xc0, 0x2e, 0x95, 0x87, 0xfa, 0xb2, 0x31, 0x87, 0x5b, 0xba,
	0x0d, 0x6a, 0xfc, 0xd6, 0x0d, 0x8b, 0xcc, 0x62, 0x1e, 0x36, 0x0d, 0x6d, 0xeb, 0xa2, 0x52, 0xf2,
	0x44, 0x3f, 0xb9, 0x5c, 0xd7, 0x38, 0x8d, 0x70, 0x92, 0xe2, 0xd7, 0xcf, 0x96, 0xc5, 0xf9, 0xec,
	0x9c, 0xeb, 0x67, 0xda, 0xaf, 0xb3, 0x9b, 0x0f, 0x07, 0x63, 0x1a, 0xec, 0x78, 0xfe, 0x17, 0x7e,
	0xeb, 0x4c, 0xfb, 0x47, 0x85, 0x5d, 0xb7, 0x8c, 0x1a, 0xc8, 0x35, 0x0a, 0x17, 0x5e, 0x6c, 0x43,
	0x50, 0xb4, 0x31, 0xe1, 0x91, 0x58, 0x55, 0x67, 0xdf, 0x94, 0x7d, 0xcc, 0x7b, 0xae, 0x4b, 0xf6,
	0x52, 0x0c, 0xe1, 0x7f, 0x08, 0x1a, 0x76, 0x0c, 0xe6, 0xb8, 0xf2, 0xed, 0x07, 0xfb, 0x66, 0x79,
	0x7e, 0x6a, 0x3d, 0x7b, 0xe6, 0x8b, 0x41, 0x3f, 0x6f, 0x1e, 0x7a, 0x64, 0xbe, 0x30, 0xc2, 0x60,
	0x61, 0xe6, 0x6a, 0xfe, 0xd2, 0xc8, 0x7c, 0x31, 0xe0, 0x69, 0x82, 0x53, 0x67, 0x6c, 0x58, 0x27,
	0xd8, 0x3a, 0x15, 0xf1, 0x53, 0x99, 0x42, 0xd8, 0x89, 0x9d, 0xf6, 0xc7, 0x62, 0x42, 0x09, 0x41,
	0xf2, 0x5e, 0x23, 0xa3, 0xa2, 0x0c, 0x69, 0x18, 0x77, 0x81, 0x40, 0x30, 0x32, 0x5f, 0xb0, 0x50,
	0x4f, 0x48, 0x35, 0x75, 0x2d, 0x6c, 0x1b, 0xb6, 0x25, 0x6f, 0x10, 0x95, 0x39, 0xa4, 0x6d, 0x11,
	0xed, 0x77, 0x14, 0xb8, 0x16, 0x3b, 0x0a, 0x22, 0xb9, 0x17, 0x6e, 0x96, 0x81, 0x8f, 0x1d, 0x42,
	0x96, 0x19, 0x84, 0xa5, 0x2e, 0x53, 0x7e, 0xc4, 0xe2, 0x8c, 0x1f, 0xf1, 0x27, 0x0a, 0xac, 0x27,
	0x85, 0xf8, 0x3f, 0xf1, 0x23, 0x52, 0xfe, 0xcf, 0x62, 0xca, 0xff, 0xd1, 0x7e, 0xac, 0xc0, 0x1d,
	0x26, 0x56, 0xcb, 0xb5, 0x13, 0x7e, 0xce, 0x97, 0xa2, 0xa5, 0xd0, 0x45, 0x5b, 0x8c, 0xbb, 0x68,
	0x29, 0xdd, 0x15, 0x67, 0x74, 0xf7, 0x5f, 0x0a, 0xdc, 0x9d, 0x27, 0x64, 0x2e, 0x2d, 0x7e, 0x08,
	0x37, 0xb9, 0x98, 0xf3, 0x75, 0xb9, 0xc1, 0x08, 0x9e, 0xcc, 0x2a, 0xf4, 0x23, 0xb8, 0x45, 0xb8,
	0x0c, 0x99, 0xb5, 0xf9, 0xc8, 0xdf, 0x14, 0x24, 0x4f, 0x2e, 0x1b, 0x90, 0x62, 0x7a, 0x40, 0x4e,
	0xd8, 0xd5, 0xc3, 0xf6, 0xb6, 0xbc, 0x32, 0x16, 0xbf, 0x63, 0xf4, 0x92, 0xde, 0x77, 0xe2, 0x2e,
	0x5a, 0x61, 0xe6, 0x2e, 0xda, 0xef, 0x2b, 0x70, 0x33, 0xa3, 0xa9, 0xbc, 0x2f, 0x15, 0xf8, 0xfb,
	0x21, 0xd6, 0xce, 0x92, 0x2e, 0x4a, 0xb1, 0x75, 0x65, 0xf1, 0xa2, 0x75, 0x45, 0xfb, 0xa7, 0x02,
	0x40, 0x94, 0x99, 0x44, 0x75, 0x28, 0xec, 0x6c, 0x0b, 0x8f, 0xa0, 0xb0, 0xb3, 0x4d, 0x7d, 0x8e,
	0x1d, 0x2c, 0x3d, 0x34, 0xfa, 0x49, 0x97, 0xc1, 0xbe, 0x65, 0xca, 0x2d, 0x9f, 0x7d, 0xa3, 0xfb,
	0x50, 0xd9, 0xf6, 0xc6, 0xbe, 0x67, 0x61, 0x42, 0x3c, 0x5f, 0xd8, 0x51, 0x1c, 0x44, 0xc5, 0x6c,
	0xe3, 0x21, 0x0e, 0x64, 0xce, 0x4a, 0x94, 0x68, 0x4d, 0xfe, 0xa5, 0x9b, 0xee, 0x31, 0x16, 0xd1,
	0x6b, 0x1c, 0x44, 0x25, 0xe8, 0x4d, 0x64, 0x7c, 0x40, 0x3f, 0x51, 0x13, 0x4a, 0x3d, 0x1f, 0xb3,
	0xdc, 0xae, 0xb8, 0xb0, 0x13, 0x96, 0xd1, 0xd7, 0xe1, 0x46, 0xcb, 0x62, 0xd1, 0x5c, 0x0f, 0x13,
	0xe2, 0x8c, 0x1c, 0x12, 0x38, 0x54, 0xf1, 0xa7, 0xe2, 0xea, 0xce, 0x1c, 0x2c, 0x95, 0x8f, 0x27,
	0x98, 0x44, 0x26, 0x5e, 0x94, 0x68, 0x5b, 0xba, 0x37, 0x1c, 0x1e, 0x9a, 0xd6, 0xa9, 0x48, 0xc1,
	0x87, 0x65, 0xed, 0x6f, 0x14, 0x58, 0x17, 0xe7, 0x59, 0x62, 0xc3, 0xcc, 0x63, 0x2d, 0xe9, 0x13,
	0xfd, 0xc2, 0x15, 0x4f, 0xf4, 0x63, 0xdb, 0xf7, 0xe2, 0xc5, 0xb7, 0xc7, 0xb5, 0x0e, 0x5c, 0x4f,
	0xc9, 0x99, 0xf7, 0xe0, 0xb5, 0xc9, 0xf9, 0xec, 0x39, 0xd4, 0x53, 0xf2, 0x86, 0x67, 0xd8, 0x1e,
	0x90, 0x2f, 0xf8, 0x21, 0x0c, 0x7a, 0x13, 0x56, 0xa9, 0x53, 0xeb, 0x8b, 0x06, 0xa4, 0x09, 0x17,
	0xf5, 0xda, 0x28, 0xde, 0xac, 0xf6, 0x14, 0x6e, 0x65, 0x4a, 0x93, 0xab, 0x6f, 0x27, 0x70, 0xab,
	0x8f, 0x83, 0xce, 0x8b, 0x00, 0xfb, 0xae, 0x39, 0x8c, 0x66, 0x49, 0x9e, 0xbe, 0xdd, 0x8e, 0x3f,
	0xb8, 0x13, 0xae, 0x73, 0xf4, 0xbe, 0x6e, 0x17, 0x6e, 0x67, 0xb7, 0x94, 0x4b, 0xee, 0x4f, 0xe0,
	0xd6, 0xce, 0x17, 0x24, 0xb7, 0xf6, 0x6d, 0xb8, 0xbd, 0xf3, 0x85, 0x49, 0x76, 0xb1, 0x16, 0x1e,
	0xdd, 0x87, 0x72, 0xf8, 0xbc, 0x16, 0xad, 0xc0, 0x62, 0xef, 0xd9, 0x40, 0x5d, 0x40, 0x00, 0xcb,
	0xed, 0xce, 0x6e, 0x67, 0xd0, 0x51, 0x95, 0x47, 0xdf, 0x2d, 0x40, 0x39, 0x7c, 0x98, 0x8a, 0x96,
	0xa1, 0x70, 0xf0, 0x54, 0x5d, 0x40, 0x15, 0x58, 0x79, 0xb6, 0xff, 0x74, 0xff, 0xe0, 0xd3, 0x7d,
	0x55, 0x41, 0xeb, 0xa0, 0xee, 0x1f, 0x0c, 0x8c, 0xad, 0x83, 0x83, 0x41, 0x7f, 0xa0, 0xb7, 0x7a,
	0xbd, 0x4e, 0x5b, 0x2d, 0xa0, 0x6b, 0xb0, 0xda, 0x1f, 0x1c, 0xe8, 0x1d, 0x63, 0x70, 0xb0, 0xb7,
	0xd5, 0x1f, 0x1c, 0xec, 0x77, 0xd4, 0x45, 0xd4, 0x80, 0xf5, 0xd6, 0xae, 0xde, 0x69, 0xb5, 0x3f,
	0x4b, 0x92, 0x17, 0x29, 0xa6, 0xbb, 0xbf, 0x7d, 0xb0, 0xd7, 0x6b, 0x0d, 0xba, 0x5b, 0xbb, 0x1d,
	0xe3, 0x79, 0x47, 0xef, 0x77, 0x0f, 0xf6, 0xd5, 0x25, 0xca, 0x5e, 0xef, 0xec, 0x74, 0x0f, 0xf6,
	0x0d, 0xda, 0xca, 0x93, 0x83, 0x67, 0xfb, 0x6d, 0x75, 0x19, 0xdd, 0x82, 0x8d, 0x9d, 0xdd, 0x83,
	0xad, 0xd6, 0xae, 0xb1, 0x7d, 0xb0, 0xff, 0xa4, 0xbb, 0x13, 0x43, 0xae, 0xd0, 0x2a, 0xed, 0x67,
	0xbd, 0xdd, 0xee, 0x76, 0x6b, 0xd0, 0x69, 0x1b, 0x9d, 0xfd, 0x81, 0xfe, 0x99, 0x5a, 0xa2, 0x12,
	0xb1, 0xcf, 0x18, 0x69, 0x19, 0xad, 0x41, 0xad, 0xbb, 0xff, 0xbc, 0xb5, 0xdb, 0x6d, 0x1b, 0xcf,
	0x5b, 0xbb, 0xcf, 0x3a, 0x2a, 0x20, 0x04, 0xf5, 0x76, 0x6b, 0xd0, 0x32, 0x98, 0x34, 0xdb, 0x83,
	0x4e, 0x5b, 0xad, 0x3c, 0x7a, 0x02, 0x95, 0xd8, 0x6d, 0x52, 0xda, 0x80, 0xe8, 0xbf, 0xd1, 0x7f,
	0xbe, 0x6d, 0xec, 0x1d, 0xb4, 0x3b, 0xea, 0x02, 0x5a, 0x85, 0x4a, 0xaf, 0x1d, 0x01, 0x14, 0xa4,
	0x42, 0xb5, 0xd5, 0xeb, 0x46, 0x90, 0xc2, 0xa3, 0xf7, 0xa1, 0x12, 0xbb, 0xdb, 0x85, 0x4a, 0x50,
	0xec, 0x6f, 0xb7, 0xf6, 0x79, 0xdd, 0x56, 0xaf, 0xa7, 0x1f, 0x7c, 0xb3, 0xbb, 0xd7, 0xa2, 0x8a,
	0xa7, 0x83, 0xf0, 0xac, 0xdf, 0x79, 0xda, 0xf9, 0x4c, 0x2d, 0x3c, 0xea, 0x41, 0x3d, 0xe9, 0x0d,
	0xd3, 0x01, 0xe8, 0x3f, 0xdb, 0xde, 0xee, 0xf4, 0xfb, 0x7c, 0x34, 0x06, 0xdd, 0xbd, 0xce, 0xc1,
	0xb3, 0x01, 0xaf, 0xb7, 0xdd, 0xda, 0xdf, 0xee, 0xec, 0xaa, 0x05, 0x8a, 0xd0, 0x3b, 0xbd, 0xdd,
	0xd6, 0x36, 0xd5, 0x3d, 0x2d, 0x3c, 0xdb, 0xdf, 0xef, 0xee, 0xef, 0xa8, 0xc5, 0x47, 0x7f, 0xaf,
	0x40, 0x99, 0xed, 0x37, 0x4f, 0x1d, 0xd7, 0xa6, 0x75, 0x0e, 0x82, 0x13, 0xec, 0x13, 0x75, 0x81,
	0x0e, 0xf1, 0xce, 0xb6, 0xaa, 0x50, 0x6b, 0xd8, 0xc1, 0x81, 0x5a, 0x60, 0x32, 0x5a, 0xa6, 0xab,
	0x2e, 0x52, 0x19, 0x63, 0x9b, 0x89, 0x5a, 0x64, 0x86, 0xc2, 0xf6, 0x08, 0x75, 0x89, 0x22, 0x63,
	0xfb, 0x85, 0xba, 0xcc, 0xcc, 0x69, 0x12, 0xa8, 0x2b, 0xa8, 0x1a, 0x6d, 0x14, 0x6a, 0x09, 0x35,
	0xe7, 0x6d, 0x0d, 0x6a, 0x99, 0xc9, 0xce, 0x16, 0x7c, 0x15, 0x68, 0x2d, 0xb9, 0xc4, 0xab, 0x95,
	0xcd, 0xbf, 0x6c, 0x40, 0xa1, 0xd7, 0x46, 0x7b, 0x50, 0x4f, 0x5e, 0x1b, 0x46, 0xb7, 0xc2, 0xdb,
	0xd2, 0xb3, 0x77, 0x92, 0x9b, 0xb7, 0xb3, 0x91, 0x7c, 0xa2, 0x68, 0x0b, 0xa8, 0x05, 0x10, 0x5d,
	0xb3, 0x46, 0x1b, 0xb3, 0x17, 0xaf, 0x39, 0x9b, 0xc6, 0xbc, 0x1b, 0xd9, 0xda, 0x02, 0x7a, 0x17,
	0x16, 0x07, 0xc4, 0x43, 0x22, 0x32, 0x8c, 0x5e, 0x65, 0x37, 0xd7, 0x62, 0x10, 0x49, 0xfd, 0x50,
	0x79, 0x57, 0x41, 0x9b, 0x50, 0x1c, 0x98, 0x26, 0x41, 0x92, 0x20, 0x7a, 0x55, 0x3d, 0xbf, 0xce,
	0x47, 0x50, 0x0e, 0x1f, 0xa7, 0x22, 0xf1, 0x84, 0x3f, 0xfd, 0x3a, 0xb8, 0xb9, 0x31, 0x03, 0x0f,
	0xa5, 0xdc, 0x83, 0x7a, 0xf2, 0x79, 0xab, 0xd4, 0x5b, 0xe6, 0xd3, 0x59, 0xa9, 0xb7, 0xec, 0x17,
	0xb1, 0xda, 0x02, 0xfa, 0x00, 0x56, 0xc4, 0x13, 0x54, 0x24, 0x56, 0x9f, 0xe4, 0x83, 0xd6, 0xe6,
	0xf5, 0x14, 0x34, 0xac, 0x69, 0xc0, 0x7a, 0xd6, 0xfb, 0x50, 0xf4, 0x9a, 0x6c, 0x71, 0xee, 0x3b,
	0xd4, 0xa6, 0x76, 0x11, 0x49, 0xd8, 0xc0, 0x2f, 0x41, 0x49, 0x3e, 0xdf, 0x44, 0xd7, 0xc3, 0x71,
	0x8b, 0xbf, 0x9f, 0x6c, 0xde, 0x48, 0x83, 0xe3, 0x95, 0xe5, 0x33, 0x48, 0x59, 0x39, 0xf5, 0xf8,
	0x52, 0x56, 0x4e, 0xbf, 0x96, 0xd4, 0x16, 0xd0, 0x0e, 0x54, 0xe3, 0xaf, 0x05, 0xd1, 0xcd, 0xb0,
	0x99, 0xf4, 0xfb, 0xc5, 0x66, 0x33, 0x0b, 0x15, 0x1f, 0xac, 0x64, 0xd2, 0x5f, 0x0e, 0x56, 0xe6,
	0x99, 0x98, 0x1c, 0xac, 0xec, 0x73, 0x02, 0x6d, 0x01, 0x0d, 0x60, 0x35, 0x75, 0x07, 0x13, 0xdd,
	0x8e, 0xe7, 0x31, 0x66, 0x18, 0xde, 0x99, 0x83, 0x4d, 0x5b, 0x64, 0xf8, 0x06, 0x0e, 0x45, 0x1a,
	0x4d, 0x64, 0x92, 0x9a, 0x1b, 0x33, 0xf0, 0x50, 0xaa, 0x2d, 0xa8, 0xed, 0xe0, 0xa0, 0xe7, 0xe3,
	0xb3, 0xfc, 0x3c, 0x9e, 0x30, 0x1e, 0xd1, 0x3b, 0x3c, 0xd4, 0x4c, 0xd1, 0xc6, 0x1e, 0xe7, 0x5d,
	0xc4, 0xa7, 0x0d, 0x95, 0xd8, 0xeb, 0x2f, 0x24, 0xa6, 0xfb, 0xec, 0xe3, 0xba, 0xe6, 0xcd, 0x0c,
	0x4c, 0xc8, 0xe5, 0x23, 0x28, 0xc9, 0xbb, 0x86, 0xd2, 0x78, 0x52, 0x97, 0x1c, 0xa5, 0xf1, 0xa4,
	0xaf, 0x24, 0x6a, 0x8b, 0xdf, 0x2f, 0x28, 0x68, 0x07, 0x2a, 0xb1, 0x5b, 0x79, 0x52, 0x8a, 0xd9,
	0x5b, 0x83, 0x52, 0x8a, 0x8c, 0x2b, 0x7c, 0x9c, 0xd1, 0x27, 0x50, 0x4b, 0xdc, 0x5c, 0x93, 0x6a,
	0xc9, 0xba, 0xad, 0xd7, 0xbc, 0x95, 0x89, 0x0b, 0x3b, 0xd5, 0x07, 0x35, 0x7d, 0x57, 0x0c, 0xdd,
	0x89, 0xb7, 0x3f, 0xcb, 0xf1, 0xee, 0x3c, 0x74, 0x9c, 0x69, 0xfa, 0x75, 0x99, 0x64, 0x3a, 0xe7,
	0xf5, 0x9a, 0x64, 0x3a, 0xef, 0x51, 0x1a, 0x67, 0x9a, 0x7e, 0xca, 0x25, 0x99, 0xce, 0x79, 0x55,
	0x26, 0x99, 0xce, 0x7b, 0x01, 0xa6, 0x2d, 0x50, 0x55, 0x26, 0xe2, 0x6d, 0xa9, 0xca, 0xac, 0xb3,
	0x21, 0xa9, 0xca, 0xcc, 0xd3, 0x12, 0x3e, 0xad, 0x93, 0x47, 0x11, 0xb1, 0xbd, 0x6b, 0x36, 0xab,
	0x1e, 0xdb, 0xbb, 0x32, 0x32, 0xda, 0xda, 0x02, 0x7a, 0x0e, 0x6b, 0x33, 0x47, 0x01, 0x48, 0xf4,
	0x68, 0xde, 0x59, 0x44, 0xf3, 0xde, 0x5c, 0x7c, 0xc8, 0xf7, 0x54, 0x1e, 0x65, 0xcc, 0xe6, 0xd3,
	0xd1, 0x1b, 0xf1, 0xea, 0x73, 0x0f, 0x04, 0x9a, 0x6f, 0x5e, 0x46, 0x16, 0x9b, 0xc1, 0x95, 0x28,
	0xeb, 0x1b, 0xee, 0xc0, 0x33, 0x29, 0x69, 0xb9, 0x03, 0xcf, 0x66, 0x88, 0xc5, 0x6a, 0xd4, 0x86,
	0x4a, 0x2c, 0x71, 0x89, 0xa2, 0x0d, 0x3b, 0x95, 0x2c, 0x6d, 0xde, 0xcc, 0xc0, 0xc4, 0x66, 0x70,
	0x39, 0x4c, 0xde, 0xc9, 0xf5, 0x28, 0x9d, 0x56, 0x6c, 0x6e, 0xcc, 0xc0, 0xe3, 0x3b, 0x40, 0x3c,
	0xc3, 0x25, 0x77, 0x80, 0x8c, 0xd4, 0x9b, 0xdc, 0x01, 0xb2, 0x12, 0x62, 0xda, 0x02, 0xc2, 0x70,
	0x23, 0x3b, 0xdd, 0x83, 0x1e, 0xc4, 0xea, 0xcd, 0xcb, 0x58, 0x35, 0x5f, 0xbf, 0x98, 0x28, 0x6e,
	0x42, 0x33, 0xf9, 0x0f, 0x14, 0xcd, 0xb4, 0xcc, 0x1c, 0x8c, 0x34, 0xa1, 0xb9, 0x89, 0x13, 0xce,
	0x77, 0xe6, 0x0f, 0x92, 0x24, 0xdf, 0x79, 0x7f, 0xd4, 0x24, 0xf9, 0xce, 0xfd, 0x67, 0x25, 0x3e,
	0xc5, 0xd3, 0x7f, 0x73, 0x24, 0xa7, 0xf8, 0x9c, 0x3f, 0x54, 0x92, 0x53, 0x7c, 0xde, 0xbf, 0x23,
	0x69, 0x0b, 0xe8, 0x9b, 0xb0, 0x36, 0xf3, 0xaf, 0x56, 0x52, 0xd8, 0x79, 0x7f, 0xa4, 0x25, 0x85,
	0x9d, 0xfb, 0x77, 0x58, 0xda, 0xc2, 0xbb, 0x0a, 0xda, 0x85, 0x5a, 0x22, 0xde, 0x97, 0x8b, 0x47,
	0x56, 0xb2, 0x42, 0x2e, 0x1e, 0x99, 0x09, 0x02, 0x6a, 0xe4, 0xe8, 0x5b, 0xf2, 0xd2, 0x76, 0x3c,
	0xce, 0xee, 0xa3, 0xfb, 0xf1, 0x7a, 0x59, 0x09, 0x81, 0xe6, 0x6b, 0x17, 0x50, 0xc4, 0xfd, 0xb2,
	0xac, 0x70, 0x58, 0xfa, 0x65, 0x17, 0x04, 0xe5, 0xd2, 0x2f, 0xbb, 0x28, 0x9a, 0xe6, 0x0d, 0xec,
	0x5c, 0xd0, 0xc0, 0xce, 0xe5, 0x0d, 0xec, 0x5c, 0xd8, 0xc0, 0xd6, 0x9b, 0xff, 0xfe, 0x77, 0x25,
	0xe5, 0x5f, 0x7f, 0x7a, 0x57, 0xf9, 0xb7, 0x9f, 0xde, 0x55, 0x7e, 0xf2, 0xd3, 0xbb, 0xca, 0x5f,
	0xfc, 0xe7, 0xdd, 0x05, 0x50, 0x3d, 0xff, 0xf8, 0x71, 0xe0, 0x9c, 0x9e, 0x3d, 0x3e, 0x3d, 0x63,
	0xff, 0x8f, 0x76, 0xb8, 0xcc, 0x7e, 0xbe, 0xf6, 0xbf, 0x01, 0x00, 0x00, 0xff, 0xff, 0xad, 0x67,
	0x14, 0xfe, 0xad, 0x4d, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// PDClient is the client API for PD service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type PDClient interface {
	// GetClusterInfo get the information of this cluster. It does not require
	// the cluster_id in request matchs the id of this cluster.
	GetClusterInfo(ctx context.Context, in *GetClusterInfoRequest, opts ...grpc.CallOption) (*GetClusterInfoResponse, error)
	// GetMembers get the member list of this cluster. It does not require
	// the cluster_id in request matchs the id of this cluster.
	GetMembers(ctx context.Context, in *GetMembersRequest, opts ...grpc.CallOption) (*GetMembersResponse, error)
	Tso(ctx context.Context, opts ...grpc.CallOption) (PD_TsoClient, error)
	Taas(ctx context.Context, opts ...grpc.CallOption) (PD_TaasClient, error)
	Bootstrap(ctx context.Context, in *BootstrapRequest, opts ...grpc.CallOption) (*BootstrapResponse, error)
	IsBootstrapped(ctx context.Context, in *IsBootstrappedRequest, opts ...grpc.CallOption) (*IsBootstrappedResponse, error)
	AllocID(ctx context.Context, in *AllocIDRequest, opts ...grpc.CallOption) (*AllocIDResponse, error)
	IsSnapshotRecovering(ctx context.Context, in *IsSnapshotRecoveringRequest, opts ...grpc.CallOption) (*IsSnapshotRecoveringResponse, error)
	GetStore(ctx context.Context, in *GetStoreRequest, opts ...grpc.CallOption) (*GetStoreResponse, error)
	PutStore(ctx context.Context, in *PutStoreRequest, opts ...grpc.CallOption) (*PutStoreResponse, error)
	GetAllStores(ctx context.Context, in *GetAllStoresRequest, opts ...grpc.CallOption) (*GetAllStoresResponse, error)
	StoreHeartbeat(ctx context.Context, in *StoreHeartbeatRequest, opts ...grpc.CallOption) (*StoreHeartbeatResponse, error)
	RegionHeartbeat(ctx context.Context, opts ...grpc.CallOption) (PD_RegionHeartbeatClient, error)
	GetRegion(ctx context.Context, in *GetRegionRequest, opts ...grpc.CallOption) (*GetRegionResponse, error)
	GetPrevRegion(ctx context.Context, in *GetRegionRequest, opts ...grpc.CallOption) (*GetRegionResponse, error)
	GetRegionByID(ctx context.Context, in *GetRegionByIDRequest, opts ...grpc.CallOption) (*GetRegionResponse, error)
	ScanRegions(ctx context.Context, in *ScanRegionsRequest, opts ...grpc.CallOption) (*ScanRegionsResponse, error)
	AskSplit(ctx context.Context, in *AskSplitRequest, opts ...grpc.CallOption) (*AskSplitResponse, error)
	ReportSplit(ctx context.Context, in *ReportSplitRequest, opts ...grpc.CallOption) (*ReportSplitResponse, error)
	AskBatchSplit(ctx context.Context, in *AskBatchSplitRequest, opts ...grpc.CallOption) (*AskBatchSplitResponse, error)
	ReportBatchSplit(ctx context.Context, in *ReportBatchSplitRequest, opts ...grpc.CallOption) (*ReportBatchSplitResponse, error)
	GetClusterConfig(ctx context.Context, in *GetClusterConfigRequest, opts ...grpc.CallOption) (*GetClusterConfigResponse, error)
	PutClusterConfig(ctx context.Context, in *PutClusterConfigRequest, opts ...grpc.CallOption) (*PutClusterConfigResponse, error)
	ScatterRegion(ctx context.Context, in *ScatterRegionRequest, opts ...grpc.CallOption) (*ScatterRegionResponse, error)
	GetGCSafePoint(ctx context.Context, in *GetGCSafePointRequest, opts ...grpc.CallOption) (*GetGCSafePointResponse, error)
	UpdateGCSafePoint(ctx context.Context, in *UpdateGCSafePointRequest, opts ...grpc.CallOption) (*UpdateGCSafePointResponse, error)
	UpdateServiceGCSafePoint(ctx context.Context, in *UpdateServiceGCSafePointRequest, opts ...grpc.CallOption) (*UpdateServiceGCSafePointResponse, error)
	SyncRegions(ctx context.Context, opts ...grpc.CallOption) (PD_SyncRegionsClient, error)
	GetOperator(ctx context.Context, in *GetOperatorRequest, opts ...grpc.CallOption) (*GetOperatorResponse, error)
	SyncMaxTS(ctx context.Context, in *SyncMaxTSRequest, opts ...grpc.CallOption) (*SyncMaxTSResponse, error)
	SplitRegions(ctx context.Context, in *SplitRegionsRequest, opts ...grpc.CallOption) (*SplitRegionsResponse, error)
	SplitAndScatterRegions(ctx context.Context, in *SplitAndScatterRegionsRequest, opts ...grpc.CallOption) (*SplitAndScatterRegionsResponse, error)
	GetDCLocationInfo(ctx context.Context, in *GetDCLocationInfoRequest, opts ...grpc.CallOption) (*GetDCLocationInfoResponse, error)
	StoreGlobalConfig(ctx context.Context, in *StoreGlobalConfigRequest, opts ...grpc.CallOption) (*StoreGlobalConfigResponse, error)
	LoadGlobalConfig(ctx context.Context, in *LoadGlobalConfigRequest, opts ...grpc.CallOption) (*LoadGlobalConfigResponse, error)
	WatchGlobalConfig(ctx context.Context, in *WatchGlobalConfigRequest, opts ...grpc.CallOption) (PD_WatchGlobalConfigClient, error)
	ReportBuckets(ctx context.Context, opts ...grpc.CallOption) (PD_ReportBucketsClient, error)
	ReportMinResolvedTS(ctx context.Context, in *ReportMinResolvedTsRequest, opts ...grpc.CallOption) (*ReportMinResolvedTsResponse, error)
	SetExternalTimestamp(ctx context.Context, in *SetExternalTimestampRequest, opts ...grpc.CallOption) (*SetExternalTimestampResponse, error)
	GetExternalTimestamp(ctx context.Context, in *GetExternalTimestampRequest, opts ...grpc.CallOption) (*GetExternalTimestampResponse, error)
}

type pDClient struct {
	cc *grpc.ClientConn
}

func NewPDClient(cc *grpc.ClientConn) PDClient {
	return &pDClient{cc}
}

func (c *pDClient) GetClusterInfo(ctx context.Context, in *GetClusterInfoRequest, opts ...grpc.CallOption) (*GetClusterInfoResponse, error) {
	out := new(GetClusterInfoResponse)
	err := c.cc.Invoke(ctx, "/pdpb.PD/GetClusterInfo", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *pDClient) GetMembers(ctx context.Context, in *GetMembersRequest, opts ...grpc.CallOption) (*GetMembersResponse, error) {
	out := new(GetMembersResponse)
	err := c.cc.Invoke(ctx, "/pdpb.PD/GetMembers", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *pDClient) Tso(ctx context.Context, opts ...grpc.CallOption) (PD_TsoClient, error) {
	stream, err := c.cc.NewStream(ctx, &_PD_serviceDesc.Streams[0], "/pdpb.PD/Tso", opts...)
	if err != nil {
		return nil, err
	}
	x := &pDTsoClient{stream}
	return x, nil
}

type PD_TsoClient interface {
	Send(*TsoRequest) error
	Recv() (*TsoResponse, error)
	grpc.ClientStream
}

type pDTsoClient struct {
	grpc.ClientStream
}

func (x *pDTsoClient) Send(m *TsoRequest) error {
	return x.ClientStream.SendMsg(m)
}

func (x *pDTsoClient) Recv() (*TsoResponse, error) {
	m := new(TsoResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *pDClient) Taas(ctx context.Context, opts ...grpc.CallOption) (PD_TaasClient, error) {
	stream, err := c.cc.NewStream(ctx, &_PD_serviceDesc.Streams[1], "/pdpb.PD/Taas", opts...)
	if err != nil {
		return nil, err
	}
	x := &pDTaasClient{stream}
	return x, nil
}

type PD_TaasClient interface {
	Send(*TaasRequest) error
	Recv() (*TsoResponse, error)
	grpc.ClientStream
}

type pDTaasClient struct {
	grpc.ClientStream
}

func (x *pDTaasClient) Send(m *TaasRequest) error {
	return x.ClientStream.SendMsg(m)
}

func (x *pDTaasClient) Recv() (*TsoResponse, error) {
	m := new(TsoResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *pDClient) Bootstrap(ctx context.Context, in *BootstrapRequest, opts ...grpc.CallOption) (*BootstrapResponse, error) {
	out := new(BootstrapResponse)
	err := c.cc.Invoke(ctx, "/pdpb.PD/Bootstrap", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *pDClient) IsBootstrapped(ctx context.Context, in *IsBootstrappedRequest, opts ...grpc.CallOption) (*IsBootstrappedResponse, error) {
	out := new(IsBootstrappedResponse)
	err := c.cc.Invoke(ctx, "/pdpb.PD/IsBootstrapped", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *pDClient) AllocID(ctx context.Context, in *AllocIDRequest, opts ...grpc.CallOption) (*AllocIDResponse, error) {
	out := new(AllocIDResponse)
	err := c.cc.Invoke(ctx, "/pdpb.PD/AllocID", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *pDClient) IsSnapshotRecovering(ctx context.Context, in *IsSnapshotRecoveringRequest, opts ...grpc.CallOption) (*IsSnapshotRecoveringResponse, error) {
	out := new(IsSnapshotRecoveringResponse)
	err := c.cc.Invoke(ctx, "/pdpb.PD/IsSnapshotRecovering", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *pDClient) GetStore(ctx context.Context, in *GetStoreRequest, opts ...grpc.CallOption) (*GetStoreResponse, error) {
	out := new(GetStoreResponse)
	err := c.cc.Invoke(ctx, "/pdpb.PD/GetStore", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *pDClient) PutStore(ctx context.Context, in *PutStoreRequest, opts ...grpc.CallOption) (*PutStoreResponse, error) {
	out := new(PutStoreResponse)
	err := c.cc.Invoke(ctx, "/pdpb.PD/PutStore", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *pDClient) GetAllStores(ctx context.Context, in *GetAllStoresRequest, opts ...grpc.CallOption) (*GetAllStoresResponse, error) {
	out := new(GetAllStoresResponse)
	err := c.cc.Invoke(ctx, "/pdpb.PD/GetAllStores", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *pDClient) StoreHeartbeat(ctx context.Context, in *StoreHeartbeatRequest, opts ...grpc.CallOption) (*StoreHeartbeatResponse, error) {
	out := new(StoreHeartbeatResponse)
	err := c.cc.Invoke(ctx, "/pdpb.PD/StoreHeartbeat", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *pDClient) RegionHeartbeat(ctx context.Context, opts ...grpc.CallOption) (PD_RegionHeartbeatClient, error) {
	stream, err := c.cc.NewStream(ctx, &_PD_serviceDesc.Streams[2], "/pdpb.PD/RegionHeartbeat", opts...)
	if err != nil {
		return nil, err
	}
	x := &pDRegionHeartbeatClient{stream}
	return x, nil
}

type PD_RegionHeartbeatClient interface {
	Send(*RegionHeartbeatRequest) error
	Recv() (*RegionHeartbeatResponse, error)
	grpc.ClientStream
}

type pDRegionHeartbeatClient struct {
	grpc.ClientStream
}

func (x *pDRegionHeartbeatClient) Send(m *RegionHeartbeatRequest) error {
	return x.ClientStream.SendMsg(m)
}

func (x *pDRegionHeartbeatClient) Recv() (*RegionHeartbeatResponse, error) {
	m := new(RegionHeartbeatResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *pDClient) GetRegion(ctx context.Context, in *GetRegionRequest, opts ...grpc.CallOption) (*GetRegionResponse, error) {
	out := new(GetRegionResponse)
	err := c.cc.Invoke(ctx, "/pdpb.PD/GetRegion", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *pDClient) GetPrevRegion(ctx context.Context, in *GetRegionRequest, opts ...grpc.CallOption) (*GetRegionResponse, error) {
	out := new(GetRegionResponse)
	err := c.cc.Invoke(ctx, "/pdpb.PD/GetPrevRegion", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *pDClient) GetRegionByID(ctx context.Context, in *GetRegionByIDRequest, opts ...grpc.CallOption) (*GetRegionResponse, error) {
	out := new(GetRegionResponse)
	err := c.cc.Invoke(ctx, "/pdpb.PD/GetRegionByID", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *pDClient) ScanRegions(ctx context.Context, in *ScanRegionsRequest, opts ...grpc.CallOption) (*ScanRegionsResponse, error) {
	out := new(ScanRegionsResponse)
	err := c.cc.Invoke(ctx, "/pdpb.PD/ScanRegions", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Deprecated: Do not use.
func (c *pDClient) AskSplit(ctx context.Context, in *AskSplitRequest, opts ...grpc.CallOption) (*AskSplitResponse, error) {
	out := new(AskSplitResponse)
	err := c.cc.Invoke(ctx, "/pdpb.PD/AskSplit", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Deprecated: Do not use.
func (c *pDClient) ReportSplit(ctx context.Context, in *ReportSplitRequest, opts ...grpc.CallOption) (*ReportSplitResponse, error) {
	out := new(ReportSplitResponse)
	err := c.cc.Invoke(ctx, "/pdpb.PD/ReportSplit", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *pDClient) AskBatchSplit(ctx context.Context, in *AskBatchSplitRequest, opts ...grpc.CallOption) (*AskBatchSplitResponse, error) {
	out := new(AskBatchSplitResponse)
	err := c.cc.Invoke(ctx, "/pdpb.PD/AskBatchSplit", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *pDClient) ReportBatchSplit(ctx context.Context, in *ReportBatchSplitRequest, opts ...grpc.CallOption) (*ReportBatchSplitResponse, error) {
	out := new(ReportBatchSplitResponse)
	err := c.cc.Invoke(ctx, "/pdpb.PD/ReportBatchSplit", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *pDClient) GetClusterConfig(ctx context.Context, in *GetClusterConfigRequest, opts ...grpc.CallOption) (*GetClusterConfigResponse, error) {
	out := new(GetClusterConfigResponse)
	err := c.cc.Invoke(ctx, "/pdpb.PD/GetClusterConfig", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *pDClient) PutClusterConfig(ctx context.Context, in *PutClusterConfigRequest, opts ...grpc.CallOption) (*PutClusterConfigResponse, error) {
	out := new(PutClusterConfigResponse)
	err := c.cc.Invoke(ctx, "/pdpb.PD/PutClusterConfig", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *pDClient) ScatterRegion(ctx context.Context, in *ScatterRegionRequest, opts ...grpc.CallOption) (*ScatterRegionResponse, error) {
	out := new(ScatterRegionResponse)
	err := c.cc.Invoke(ctx, "/pdpb.PD/ScatterRegion", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *pDClient) GetGCSafePoint(ctx context.Context, in *GetGCSafePointRequest, opts ...grpc.CallOption) (*GetGCSafePointResponse, error) {
	out := new(GetGCSafePointResponse)
	err := c.cc.Invoke(ctx, "/pdpb.PD/GetGCSafePoint", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *pDClient) UpdateGCSafePoint(ctx context.Context, in *UpdateGCSafePointRequest, opts ...grpc.CallOption) (*UpdateGCSafePointResponse, error) {
	out := new(UpdateGCSafePointResponse)
	err := c.cc.Invoke(ctx, "/pdpb.PD/UpdateGCSafePoint", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *pDClient) UpdateServiceGCSafePoint(ctx context.Context, in *UpdateServiceGCSafePointRequest, opts ...grpc.CallOption) (*UpdateServiceGCSafePointResponse, error) {
	out := new(UpdateServiceGCSafePointResponse)
	err := c.cc.Invoke(ctx, "/pdpb.PD/UpdateServiceGCSafePoint", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *pDClient) SyncRegions(ctx context.Context, opts ...grpc.CallOption) (PD_SyncRegionsClient, error) {
	stream, err := c.cc.NewStream(ctx, &_PD_serviceDesc.Streams[3], "/pdpb.PD/SyncRegions", opts...)
	if err != nil {
		return nil, err
	}
	x := &pDSyncRegionsClient{stream}
	return x, nil
}

type PD_SyncRegionsClient interface {
	Send(*SyncRegionRequest) error
	Recv() (*SyncRegionResponse, error)
	grpc.ClientStream
}

type pDSyncRegionsClient struct {
	grpc.ClientStream
}

func (x *pDSyncRegionsClient) Send(m *SyncRegionRequest) error {
	return x.ClientStream.SendMsg(m)
}

func (x *pDSyncRegionsClient) Recv() (*SyncRegionResponse, error) {
	m := new(SyncRegionResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *pDClient) GetOperator(ctx context.Context, in *GetOperatorRequest, opts ...grpc.CallOption) (*GetOperatorResponse, error) {
	out := new(GetOperatorResponse)
	err := c.cc.Invoke(ctx, "/pdpb.PD/GetOperator", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *pDClient) SyncMaxTS(ctx context.Context, in *SyncMaxTSRequest, opts ...grpc.CallOption) (*SyncMaxTSResponse, error) {
	out := new(SyncMaxTSResponse)
	err := c.cc.Invoke(ctx, "/pdpb.PD/SyncMaxTS", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *pDClient) SplitRegions(ctx context.Context, in *SplitRegionsRequest, opts ...grpc.CallOption) (*SplitRegionsResponse, error) {
	out := new(SplitRegionsResponse)
	err := c.cc.Invoke(ctx, "/pdpb.PD/SplitRegions", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *pDClient) SplitAndScatterRegions(ctx context.Context, in *SplitAndScatterRegionsRequest, opts ...grpc.CallOption) (*SplitAndScatterRegionsResponse, error) {
	out := new(SplitAndScatterRegionsResponse)
	err := c.cc.Invoke(ctx, "/pdpb.PD/SplitAndScatterRegions", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *pDClient) GetDCLocationInfo(ctx context.Context, in *GetDCLocationInfoRequest, opts ...grpc.CallOption) (*GetDCLocationInfoResponse, error) {
	out := new(GetDCLocationInfoResponse)
	err := c.cc.Invoke(ctx, "/pdpb.PD/GetDCLocationInfo", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *pDClient) StoreGlobalConfig(ctx context.Context, in *StoreGlobalConfigRequest, opts ...grpc.CallOption) (*StoreGlobalConfigResponse, error) {
	out := new(StoreGlobalConfigResponse)
	err := c.cc.Invoke(ctx, "/pdpb.PD/StoreGlobalConfig", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *pDClient) LoadGlobalConfig(ctx context.Context, in *LoadGlobalConfigRequest, opts ...grpc.CallOption) (*LoadGlobalConfigResponse, error) {
	out := new(LoadGlobalConfigResponse)
	err := c.cc.Invoke(ctx, "/pdpb.PD/LoadGlobalConfig", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *pDClient) WatchGlobalConfig(ctx context.Context, in *WatchGlobalConfigRequest, opts ...grpc.CallOption) (PD_WatchGlobalConfigClient, error) {
	stream, err := c.cc.NewStream(ctx, &_PD_serviceDesc.Streams[4], "/pdpb.PD/WatchGlobalConfig", opts...)
	if err != nil {
		return nil, err
	}
	x := &pDWatchGlobalConfigClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type PD_WatchGlobalConfigClient interface {
	Recv() (*WatchGlobalConfigResponse, error)
	grpc.ClientStream
}

type pDWatchGlobalConfigClient struct {
	grpc.ClientStream
}

func (x *pDWatchGlobalConfigClient) Recv() (*WatchGlobalConfigResponse, error) {
	m := new(WatchGlobalConfigResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *pDClient) ReportBuckets(ctx context.Context, opts ...grpc.CallOption) (PD_ReportBucketsClient, error) {
	stream, err := c.cc.NewStream(ctx, &_PD_serviceDesc.Streams[5], "/pdpb.PD/ReportBuckets", opts...)
	if err != nil {
		return nil, err
	}
	x := &pDReportBucketsClient{stream}
	return x, nil
}

type PD_ReportBucketsClient interface {
	Send(*ReportBucketsRequest) error
	CloseAndRecv() (*ReportBucketsResponse, error)
	grpc.ClientStream
}

type pDReportBucketsClient struct {
	grpc.ClientStream
}

func (x *pDReportBucketsClient) Send(m *ReportBucketsRequest) error {
	return x.ClientStream.SendMsg(m)
}

func (x *pDReportBucketsClient) CloseAndRecv() (*ReportBucketsResponse, error) {
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	m := new(ReportBucketsResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *pDClient) ReportMinResolvedTS(ctx context.Context, in *ReportMinResolvedTsRequest, opts ...grpc.CallOption) (*ReportMinResolvedTsResponse, error) {
	out := new(ReportMinResolvedTsResponse)
	err := c.cc.Invoke(ctx, "/pdpb.PD/ReportMinResolvedTS", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *pDClient) SetExternalTimestamp(ctx context.Context, in *SetExternalTimestampRequest, opts ...grpc.CallOption) (*SetExternalTimestampResponse, error) {
	out := new(SetExternalTimestampResponse)
	err := c.cc.Invoke(ctx, "/pdpb.PD/SetExternalTimestamp", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *pDClient) GetExternalTimestamp(ctx context.Context, in *GetExternalTimestampRequest, opts ...grpc.CallOption) (*GetExternalTimestampResponse, error) {
	out := new(GetExternalTimestampResponse)
	err := c.cc.Invoke(ctx, "/pdpb.PD/GetExternalTimestamp", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// PDServer is the server API for PD service.
type PDServer interface {
	// GetClusterInfo get the information of this cluster. It does not require
	// the cluster_id in request matchs the id of this cluster.
	GetClusterInfo(context.Context, *GetClusterInfoRequest) (*GetClusterInfoResponse, error)
	// GetMembers get the member list of this cluster. It does not require
	// the cluster_id in request matchs the id of this cluster.
	GetMembers(context.Context, *GetMembersRequest) (*GetMembersResponse, error)
	Tso(PD_TsoServer) error
	Taas(PD_TaasServer) error
	Bootstrap(context.Context, *BootstrapRequest) (*BootstrapResponse, error)
	IsBootstrapped(context.Context, *IsBootstrappedRequest) (*IsBootstrappedResponse, error)
	AllocID(context.Context, *AllocIDRequest) (*AllocIDResponse, error)
	IsSnapshotRecovering(context.Context, *IsSnapshotRecoveringRequest) (*IsSnapshotRecoveringResponse, error)
	GetStore(context.Context, *GetStoreRequest) (*GetStoreResponse, error)
	PutStore(context.Context, *PutStoreRequest) (*PutStoreResponse, error)
	GetAllStores(context.Context, *GetAllStoresRequest) (*GetAllStoresResponse, error)
	StoreHeartbeat(context.Context, *StoreHeartbeatRequest) (*StoreHeartbeatResponse, error)
	RegionHeartbeat(PD_RegionHeartbeatServer) error
	GetRegion(context.Context, *GetRegionRequest) (*GetRegionResponse, error)
	GetPrevRegion(context.Context, *GetRegionRequest) (*GetRegionResponse, error)
	GetRegionByID(context.Context, *GetRegionByIDRequest) (*GetRegionResponse, error)
	ScanRegions(context.Context, *ScanRegionsRequest) (*ScanRegionsResponse, error)
	AskSplit(context.Context, *AskSplitRequest) (*AskSplitResponse, error)
	ReportSplit(context.Context, *ReportSplitRequest) (*ReportSplitResponse, error)
	AskBatchSplit(context.Context, *AskBatchSplitRequest) (*AskBatchSplitResponse, error)
	ReportBatchSplit(context.Context, *ReportBatchSplitRequest) (*ReportBatchSplitResponse, error)
	GetClusterConfig(context.Context, *GetClusterConfigRequest) (*GetClusterConfigResponse, error)
	PutClusterConfig(context.Context, *PutClusterConfigRequest) (*PutClusterConfigResponse, error)
	ScatterRegion(context.Context, *ScatterRegionRequest) (*ScatterRegionResponse, error)
	GetGCSafePoint(context.Context, *GetGCSafePointRequest) (*GetGCSafePointResponse, error)
	UpdateGCSafePoint(context.Context, *UpdateGCSafePointRequest) (*UpdateGCSafePointResponse, error)
	UpdateServiceGCSafePoint(context.Context, *UpdateServiceGCSafePointRequest) (*UpdateServiceGCSafePointResponse, error)
	SyncRegions(PD_SyncRegionsServer) error
	GetOperator(context.Context, *GetOperatorRequest) (*GetOperatorResponse, error)
	SyncMaxTS(context.Context, *SyncMaxTSRequest) (*SyncMaxTSResponse, error)
	SplitRegions(context.Context, *SplitRegionsRequest) (*SplitRegionsResponse, error)
	SplitAndScatterRegions(context.Context, *SplitAndScatterRegionsRequest) (*SplitAndScatterRegionsResponse, error)
	GetDCLocationInfo(context.Context, *GetDCLocationInfoRequest) (*GetDCLocationInfoResponse, error)
	StoreGlobalConfig(context.Context, *StoreGlobalConfigRequest) (*StoreGlobalConfigResponse, error)
	LoadGlobalConfig(context.Context, *LoadGlobalConfigRequest) (*LoadGlobalConfigResponse, error)
	WatchGlobalConfig(*WatchGlobalConfigRequest, PD_WatchGlobalConfigServer) error
	ReportBuckets(PD_ReportBucketsServer) error
	ReportMinResolvedTS(context.Context, *ReportMinResolvedTsRequest) (*ReportMinResolvedTsResponse, error)
	SetExternalTimestamp(context.Context, *SetExternalTimestampRequest) (*SetExternalTimestampResponse, error)
	GetExternalTimestamp(context.Context, *GetExternalTimestampRequest) (*GetExternalTimestampResponse, error)
}

// UnimplementedPDServer can be embedded to have forward compatible implementations.
type UnimplementedPDServer struct {
}

func (*UnimplementedPDServer) GetClusterInfo(ctx context.Context, req *GetClusterInfoRequest) (*GetClusterInfoResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetClusterInfo not implemented")
}
func (*UnimplementedPDServer) GetMembers(ctx context.Context, req *GetMembersRequest) (*GetMembersResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetMembers not implemented")
}
func (*UnimplementedPDServer) Tso(srv PD_TsoServer) error {
	return status.Errorf(codes.Unimplemented, "method Tso not implemented")
}
func (*UnimplementedPDServer) Taas(srv PD_TaasServer) error {
	return status.Errorf(codes.Unimplemented, "method Taas not implemented")
}
func (*UnimplementedPDServer) Bootstrap(ctx context.Context, req *BootstrapRequest) (*BootstrapResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Bootstrap not implemented")
}
func (*UnimplementedPDServer) IsBootstrapped(ctx context.Context, req *IsBootstrappedRequest) (*IsBootstrappedResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method IsBootstrapped not implemented")
}
func (*UnimplementedPDServer) AllocID(ctx context.Context, req *AllocIDRequest) (*AllocIDResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AllocID not implemented")
}
func (*UnimplementedPDServer) IsSnapshotRecovering(ctx context.Context, req *IsSnapshotRecoveringRequest) (*IsSnapshotRecoveringResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method IsSnapshotRecovering not implemented")
}
func (*UnimplementedPDServer) GetStore(ctx context.Context, req *GetStoreRequest) (*GetStoreResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetStore not implemented")
}
func (*UnimplementedPDServer) PutStore(ctx context.Context, req *PutStoreRequest) (*PutStoreResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PutStore not implemented")
}
func (*UnimplementedPDServer) GetAllStores(ctx context.Context, req *GetAllStoresRequest) (*GetAllStoresResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetAllStores not implemented")
}
func (*UnimplementedPDServer) StoreHeartbeat(ctx context.Context, req *StoreHeartbeatRequest) (*StoreHeartbeatResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method StoreHeartbeat not implemented")
}
func (*UnimplementedPDServer) RegionHeartbeat(srv PD_RegionHeartbeatServer) error {
	return status.Errorf(codes.Unimplemented, "method RegionHeartbeat not implemented")
}
func (*UnimplementedPDServer) GetRegion(ctx context.Context, req *GetRegionRequest) (*GetRegionResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetRegion not implemented")
}
func (*UnimplementedPDServer) GetPrevRegion(ctx context.Context, req *GetRegionRequest) (*GetRegionResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetPrevRegion not implemented")
}
func (*UnimplementedPDServer) GetRegionByID(ctx context.Context, req *GetRegionByIDRequest) (*GetRegionResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetRegionByID not implemented")
}
func (*UnimplementedPDServer) ScanRegions(ctx context.Context, req *ScanRegionsRequest) (*ScanRegionsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ScanRegions not implemented")
}
func (*UnimplementedPDServer) AskSplit(ctx context.Context, req *AskSplitRequest) (*AskSplitResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AskSplit not implemented")
}
func (*UnimplementedPDServer) ReportSplit(ctx context.Context, req *ReportSplitRequest) (*ReportSplitResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ReportSplit not implemented")
}
func (*UnimplementedPDServer) AskBatchSplit(ctx context.Context, req *AskBatchSplitRequest) (*AskBatchSplitResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AskBatchSplit not implemented")
}
func (*UnimplementedPDServer) ReportBatchSplit(ctx context.Context, req *ReportBatchSplitRequest) (*ReportBatchSplitResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ReportBatchSplit not implemented")
}
func (*UnimplementedPDServer) GetClusterConfig(ctx context.Context, req *GetClusterConfigRequest) (*GetClusterConfigResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetClusterConfig not implemented")
}
func (*UnimplementedPDServer) PutClusterConfig(ctx context.Context, req *PutClusterConfigRequest) (*PutClusterConfigResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PutClusterConfig not implemented")
}
func (*UnimplementedPDServer) ScatterRegion(ctx context.Context, req *ScatterRegionRequest) (*ScatterRegionResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ScatterRegion not implemented")
}
func (*UnimplementedPDServer) GetGCSafePoint(ctx context.Context, req *GetGCSafePointRequest) (*GetGCSafePointResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetGCSafePoint not implemented")
}
func (*UnimplementedPDServer) UpdateGCSafePoint(ctx context.Context, req *UpdateGCSafePointRequest) (*UpdateGCSafePointResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateGCSafePoint not implemented")
}
func (*UnimplementedPDServer) UpdateServiceGCSafePoint(ctx context.Context, req *UpdateServiceGCSafePointRequest) (*UpdateServiceGCSafePointResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateServiceGCSafePoint not implemented")
}
func (*UnimplementedPDServer) SyncRegions(srv PD_SyncRegionsServer) error {
	return status.Errorf(codes.Unimplemented, "method SyncRegions not implemented")
}
func (*UnimplementedPDServer) GetOperator(ctx context.Context, req *GetOperatorRequest) (*GetOperatorResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetOperator not implemented")
}
func (*UnimplementedPDServer) SyncMaxTS(ctx context.Context, req *SyncMaxTSRequest) (*SyncMaxTSResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SyncMaxTS not implemented")
}
func (*UnimplementedPDServer) SplitRegions(ctx context.Context, req *SplitRegionsRequest) (*SplitRegionsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SplitRegions not implemented")
}
func (*UnimplementedPDServer) SplitAndScatterRegions(ctx context.Context, req *SplitAndScatterRegionsRequest) (*SplitAndScatterRegionsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SplitAndScatterRegions not implemented")
}
func (*UnimplementedPDServer) GetDCLocationInfo(ctx context.Context, req *GetDCLocationInfoRequest) (*GetDCLocationInfoResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetDCLocationInfo not implemented")
}
func (*UnimplementedPDServer) StoreGlobalConfig(ctx context.Context, req *StoreGlobalConfigRequest) (*StoreGlobalConfigResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method StoreGlobalConfig not implemented")
}
func (*UnimplementedPDServer) LoadGlobalConfig(ctx context.Context, req *LoadGlobalConfigRequest) (*LoadGlobalConfigResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method LoadGlobalConfig not implemented")
}
func (*UnimplementedPDServer) WatchGlobalConfig(req *WatchGlobalConfigRequest, srv PD_WatchGlobalConfigServer) error {
	return status.Errorf(codes.Unimplemented, "method WatchGlobalConfig not implemented")
}
func (*UnimplementedPDServer) ReportBuckets(srv PD_ReportBucketsServer) error {
	return status.Errorf(codes.Unimplemented, "method ReportBuckets not implemented")
}
func (*UnimplementedPDServer) ReportMinResolvedTS(ctx context.Context, req *ReportMinResolvedTsRequest) (*ReportMinResolvedTsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ReportMinResolvedTS not implemented")
}
func (*UnimplementedPDServer) SetExternalTimestamp(ctx context.Context, req *SetExternalTimestampRequest) (*SetExternalTimestampResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetExternalTimestamp not implemented")
}
func (*UnimplementedPDServer) GetExternalTimestamp(ctx context.Context, req *GetExternalTimestampRequest) (*GetExternalTimestampResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetExternalTimestamp not implemented")
}

func RegisterPDServer(s *grpc.Server, srv PDServer) {
	s.RegisterService(&_PD_serviceDesc, srv)
}

func _PD_GetClusterInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetClusterInfoRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PDServer).GetClusterInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pdpb.PD/GetClusterInfo",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PDServer).GetClusterInfo(ctx, req.(*GetClusterInfoRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _PD_GetMembers_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetMembersRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PDServer).GetMembers(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pdpb.PD/GetMembers",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PDServer).GetMembers(ctx, req.(*GetMembersRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _PD_Tso_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(PDServer).Tso(&pDTsoServer{stream})
}

type PD_TsoServer interface {
	Send(*TsoResponse) error
	Recv() (*TsoRequest, error)
	grpc.ServerStream
}

type pDTsoServer struct {
	grpc.ServerStream
}

func (x *pDTsoServer) Send(m *TsoResponse) error {
	return x.ServerStream.SendMsg(m)
}

func (x *pDTsoServer) Recv() (*TsoRequest, error) {
	m := new(TsoRequest)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _PD_Taas_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(PDServer).Taas(&pDTaasServer{stream})
}

type PD_TaasServer interface {
	Send(*TsoResponse) error
	Recv() (*TaasRequest, error)
	grpc.ServerStream
}

type pDTaasServer struct {
	grpc.ServerStream
}

func (x *pDTaasServer) Send(m *TsoResponse) error {
	return x.ServerStream.SendMsg(m)
}

func (x *pDTaasServer) Recv() (*TaasRequest, error) {
	m := new(TaasRequest)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _PD_Bootstrap_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BootstrapRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PDServer).Bootstrap(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pdpb.PD/Bootstrap",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PDServer).Bootstrap(ctx, req.(*BootstrapRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _PD_IsBootstrapped_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(IsBootstrappedRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PDServer).IsBootstrapped(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pdpb.PD/IsBootstrapped",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PDServer).IsBootstrapped(ctx, req.(*IsBootstrappedRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _PD_AllocID_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AllocIDRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PDServer).AllocID(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pdpb.PD/AllocID",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PDServer).AllocID(ctx, req.(*AllocIDRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _PD_IsSnapshotRecovering_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(IsSnapshotRecoveringRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PDServer).IsSnapshotRecovering(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pdpb.PD/IsSnapshotRecovering",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PDServer).IsSnapshotRecovering(ctx, req.(*IsSnapshotRecoveringRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _PD_GetStore_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetStoreRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PDServer).GetStore(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pdpb.PD/GetStore",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PDServer).GetStore(ctx, req.(*GetStoreRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _PD_PutStore_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PutStoreRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PDServer).PutStore(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pdpb.PD/PutStore",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PDServer).PutStore(ctx, req.(*PutStoreRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _PD_GetAllStores_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetAllStoresRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PDServer).GetAllStores(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pdpb.PD/GetAllStores",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PDServer).GetAllStores(ctx, req.(*GetAllStoresRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _PD_StoreHeartbeat_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StoreHeartbeatRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PDServer).StoreHeartbeat(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pdpb.PD/StoreHeartbeat",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PDServer).StoreHeartbeat(ctx, req.(*StoreHeartbeatRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _PD_RegionHeartbeat_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(PDServer).RegionHeartbeat(&pDRegionHeartbeatServer{stream})
}

type PD_RegionHeartbeatServer interface {
	Send(*RegionHeartbeatResponse) error
	Recv() (*RegionHeartbeatRequest, error)
	grpc.ServerStream
}

type pDRegionHeartbeatServer struct {
	grpc.ServerStream
}

func (x *pDRegionHeartbeatServer) Send(m *RegionHeartbeatResponse) error {
	return x.ServerStream.SendMsg(m)
}

func (x *pDRegionHeartbeatServer) Recv() (*RegionHeartbeatRequest, error) {
	m := new(RegionHeartbeatRequest)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _PD_GetRegion_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetRegionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PDServer).GetRegion(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pdpb.PD/GetRegion",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PDServer).GetRegion(ctx, req.(*GetRegionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _PD_GetPrevRegion_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetRegionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PDServer).GetPrevRegion(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pdpb.PD/GetPrevRegion",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PDServer).GetPrevRegion(ctx, req.(*GetRegionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _PD_GetRegionByID_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetRegionByIDRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PDServer).GetRegionByID(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pdpb.PD/GetRegionByID",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PDServer).GetRegionByID(ctx, req.(*GetRegionByIDRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _PD_ScanRegions_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ScanRegionsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PDServer).ScanRegions(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pdpb.PD/ScanRegions",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PDServer).ScanRegions(ctx, req.(*ScanRegionsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _PD_AskSplit_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AskSplitRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PDServer).AskSplit(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pdpb.PD/AskSplit",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PDServer).AskSplit(ctx, req.(*AskSplitRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _PD_ReportSplit_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ReportSplitRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PDServer).ReportSplit(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pdpb.PD/ReportSplit",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PDServer).ReportSplit(ctx, req.(*ReportSplitRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _PD_AskBatchSplit_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AskBatchSplitRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PDServer).AskBatchSplit(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pdpb.PD/AskBatchSplit",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PDServer).AskBatchSplit(ctx, req.(*AskBatchSplitRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _PD_ReportBatchSplit_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ReportBatchSplitRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PDServer).ReportBatchSplit(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pdpb.PD/ReportBatchSplit",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PDServer).ReportBatchSplit(ctx, req.(*ReportBatchSplitRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _PD_GetClusterConfig_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetClusterConfigRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PDServer).GetClusterConfig(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pdpb.PD/GetClusterConfig",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PDServer).GetClusterConfig(ctx, req.(*GetClusterConfigRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _PD_PutClusterConfig_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PutClusterConfigRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PDServer).PutClusterConfig(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pdpb.PD/PutClusterConfig",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PDServer).PutClusterConfig(ctx, req.(*PutClusterConfigRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _PD_ScatterRegion_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ScatterRegionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PDServer).ScatterRegion(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pdpb.PD/ScatterRegion",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PDServer).ScatterRegion(ctx, req.(*ScatterRegionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _PD_GetGCSafePoint_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetGCSafePointRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PDServer).GetGCSafePoint(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pdpb.PD/GetGCSafePoint",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PDServer).GetGCSafePoint(ctx, req.(*GetGCSafePointRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _PD_UpdateGCSafePoint_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateGCSafePointRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PDServer).UpdateGCSafePoint(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pdpb.PD/UpdateGCSafePoint",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PDServer).UpdateGCSafePoint(ctx, req.(*UpdateGCSafePointRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _PD_UpdateServiceGCSafePoint_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateServiceGCSafePointRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PDServer).UpdateServiceGCSafePoint(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pdpb.PD/UpdateServiceGCSafePoint",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PDServer).UpdateServiceGCSafePoint(ctx, req.(*UpdateServiceGCSafePointRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _PD_SyncRegions_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(PDServer).SyncRegions(&pDSyncRegionsServer{stream})
}

type PD_SyncRegionsServer interface {
	Send(*SyncRegionResponse) error
	Recv() (*SyncRegionRequest, error)
	grpc.ServerStream
}

type pDSyncRegionsServer struct {
	grpc.ServerStream
}

func (x *pDSyncRegionsServer) Send(m *SyncRegionResponse) error {
	return x.ServerStream.SendMsg(m)
}

func (x *pDSyncRegionsServer) Recv() (*SyncRegionRequest, error) {
	m := new(SyncRegionRequest)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _PD_GetOperator_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetOperatorRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PDServer).GetOperator(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pdpb.PD/GetOperator",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PDServer).GetOperator(ctx, req.(*GetOperatorRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _PD_SyncMaxTS_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SyncMaxTSRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PDServer).SyncMaxTS(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pdpb.PD/SyncMaxTS",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PDServer).SyncMaxTS(ctx, req.(*SyncMaxTSRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _PD_SplitRegions_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SplitRegionsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PDServer).SplitRegions(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pdpb.PD/SplitRegions",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PDServer).SplitRegions(ctx, req.(*SplitRegionsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _PD_SplitAndScatterRegions_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SplitAndScatterRegionsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PDServer).SplitAndScatterRegions(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pdpb.PD/SplitAndScatterRegions",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PDServer).SplitAndScatterRegions(ctx, req.(*SplitAndScatterRegionsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _PD_GetDCLocationInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetDCLocationInfoRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PDServer).GetDCLocationInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pdpb.PD/GetDCLocationInfo",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PDServer).GetDCLocationInfo(ctx, req.(*GetDCLocationInfoRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _PD_StoreGlobalConfig_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StoreGlobalConfigRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PDServer).StoreGlobalConfig(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pdpb.PD/StoreGlobalConfig",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PDServer).StoreGlobalConfig(ctx, req.(*StoreGlobalConfigRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _PD_LoadGlobalConfig_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LoadGlobalConfigRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PDServer).LoadGlobalConfig(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pdpb.PD/LoadGlobalConfig",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PDServer).LoadGlobalConfig(ctx, req.(*LoadGlobalConfigRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _PD_WatchGlobalConfig_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(WatchGlobalConfigRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(PDServer).WatchGlobalConfig(m, &pDWatchGlobalConfigServer{stream})
}

type PD_WatchGlobalConfigServer interface {
	Send(*WatchGlobalConfigResponse) error
	grpc.ServerStream
}

type pDWatchGlobalConfigServer struct {
	grpc.ServerStream
}

func (x *pDWatchGlobalConfigServer) Send(m *WatchGlobalConfigResponse) error {
	return x.ServerStream.SendMsg(m)
}

func _PD_ReportBuckets_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(PDServer).ReportBuckets(&pDReportBucketsServer{stream})
}

type PD_ReportBucketsServer interface {
	SendAndClose(*ReportBucketsResponse) error
	Recv() (*ReportBucketsRequest, error)
	grpc.ServerStream
}

type pDReportBucketsServer struct {
	grpc.ServerStream
}

func (x *pDReportBucketsServer) SendAndClose(m *ReportBucketsResponse) error {
	return x.ServerStream.SendMsg(m)
}

func (x *pDReportBucketsServer) Recv() (*ReportBucketsRequest, error) {
	m := new(ReportBucketsRequest)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _PD_ReportMinResolvedTS_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ReportMinResolvedTsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PDServer).ReportMinResolvedTS(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pdpb.PD/ReportMinResolvedTS",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PDServer).ReportMinResolvedTS(ctx, req.(*ReportMinResolvedTsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _PD_SetExternalTimestamp_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetExternalTimestampRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PDServer).SetExternalTimestamp(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pdpb.PD/SetExternalTimestamp",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PDServer).SetExternalTimestamp(ctx, req.(*SetExternalTimestampRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _PD_GetExternalTimestamp_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetExternalTimestampRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PDServer).GetExternalTimestamp(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pdpb.PD/GetExternalTimestamp",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PDServer).GetExternalTimestamp(ctx, req.(*GetExternalTimestampRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _PD_serviceDesc = grpc.ServiceDesc{
	ServiceName: "pdpb.PD",
	HandlerType: (*PDServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetClusterInfo",
			Handler:    _PD_GetClusterInfo_Handler,
		},
		{
			MethodName: "GetMembers",
			Handler:    _PD_GetMembers_Handler,
		},
		{
			MethodName: "Bootstrap",
			Handler:    _PD_Bootstrap_Handler,
		},
		{
			MethodName: "IsBootstrapped",
			Handler:    _PD_IsBootstrapped_Handler,
		},
		{
			MethodName: "AllocID",
			Handler:    _PD_AllocID_Handler,
		},
		{
			MethodName: "IsSnapshotRecovering",
			Handler:    _PD_IsSnapshotRecovering_Handler,
		},
		{
			MethodName: "GetStore",
			Handler:    _PD_GetStore_Handler,
		},
		{
			MethodName: "PutStore",
			Handler:    _PD_PutStore_Handler,
		},
		{
			MethodName: "GetAllStores",
			Handler:    _PD_GetAllStores_Handler,
		},
		{
			MethodName: "StoreHeartbeat",
			Handler:    _PD_StoreHeartbeat_Handler,
		},
		{
			MethodName: "GetRegion",
			Handler:    _PD_GetRegion_Handler,
		},
		{
			MethodName: "GetPrevRegion",
			Handler:    _PD_GetPrevRegion_Handler,
		},
		{
			MethodName: "GetRegionByID",
			Handler:    _PD_GetRegionByID_Handler,
		},
		{
			MethodName: "ScanRegions",
			Handler:    _PD_ScanRegions_Handler,
		},
		{
			MethodName: "AskSplit",
			Handler:    _PD_AskSplit_Handler,
		},
		{
			MethodName: "ReportSplit",
			Handler:    _PD_ReportSplit_Handler,
		},
		{
			MethodName: "AskBatchSplit",
			Handler:    _PD_AskBatchSplit_Handler,
		},
		{
			MethodName: "ReportBatchSplit",
			Handler:    _PD_ReportBatchSplit_Handler,
		},
		{
			MethodName: "GetClusterConfig",
			Handler:    _PD_GetClusterConfig_Handler,
		},
		{
			MethodName: "PutClusterConfig",
			Handler:    _PD_PutClusterConfig_Handler,
		},
		{
			MethodName: "ScatterRegion",
			Handler:    _PD_ScatterRegion_Handler,
		},
		{
			MethodName: "GetGCSafePoint",
			Handler:    _PD_GetGCSafePoint_Handler,
		},
		{
			MethodName: "UpdateGCSafePoint",
			Handler:    _PD_UpdateGCSafePoint_Handler,
		},
		{
			MethodName: "UpdateServiceGCSafePoint",
			Handler:    _PD_UpdateServiceGCSafePoint_Handler,
		},
		{
			MethodName: "GetOperator",
			Handler:    _PD_GetOperator_Handler,
		},
		{
			MethodName: "SyncMaxTS",
			Handler:    _PD_SyncMaxTS_Handler,
		},
		{
			MethodName: "SplitRegions",
			Handler:    _PD_SplitRegions_Handler,
		},
		{
			MethodName: "SplitAndScatterRegions",
			Handler:    _PD_SplitAndScatterRegions_Handler,
		},
		{
			MethodName: "GetDCLocationInfo",
			Handler:    _PD_GetDCLocationInfo_Handler,
		},
		{
			MethodName: "StoreGlobalConfig",
			Handler:    _PD_StoreGlobalConfig_Handler,
		},
		{
			MethodName: "LoadGlobalConfig",
			Handler:    _PD_LoadGlobalConfig_Handler,
		},
		{
			MethodName: "ReportMinResolvedTS",
			Handler:    _PD_ReportMinResolvedTS_Handler,
		},
		{
			MethodName: "SetExternalTimestamp",
			Handler:    _PD_SetExternalTimestamp_Handler,
		},
		{
			MethodName: "GetExternalTimestamp",
			Handler:    _PD_GetExternalTimestamp_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "Tso",
			Handler:       _PD_Tso_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
		{
			StreamName:    "Taas",
			Handler:       _PD_Taas_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
		{
			StreamName:    "RegionHeartbeat",
			Handler:       _PD_RegionHeartbeat_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
		{
			StreamName:    "SyncRegions",
			Handler:       _PD_SyncRegions_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
		{
			StreamName:    "WatchGlobalConfig",
			Handler:       _PD_WatchGlobalConfig_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "ReportBuckets",
			Handler:       _PD_ReportBuckets_Handler,
			ClientStreams: true,
		},
	},
	Metadata: "pdpb.proto",
}

func (m *WatchGlobalConfigRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WatchGlobalConfigRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *WatchGlobalConfigRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Revision != 0 {
		i = encodeVarintPdpb(dAtA, i, uint64(m.Revision))
		i--
		dAtA[i] = 0x10
	}
	if len(m.ConfigPath) > 0 {
		i -= len(m.ConfigPath)
		copy(dAtA[i:], m.ConfigPath)
		i = encodeVarintPdpb(dAtA, i, uint64(len(m.ConfigPath)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *WatchGlobalConfigResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WatchGlobalConfigResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *WatchGlobalConfigResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Header != nil {
		{
			size, err := m.Header.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPdpb(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.Revision != 0 {
		i = encodeVarintPdpb(dAtA, i, uint64(m.Revision))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Changes) > 0 {
		for iNdEx := len(m.Changes) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Changes[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPdpb(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *StoreGlobalConfigRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StoreGlobalConfigRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *StoreGlobalConfigRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.ConfigPath) > 0 {
		i -= len(m.ConfigPath)
		copy(dAtA[i:], m.ConfigPath)
		i = encodeVarintPdpb(dAtA, i, uint64(len(m.ConfigPath)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Changes) > 0 {
		for iNdEx := len(m.Changes) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Changes[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPdpb(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *StoreGlobalConfigResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StoreGlobalConfigResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *StoreGlobalConfigResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Error != nil {
		{
			size, err := m.Error.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPdpb(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *LoadGlobalConfigRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LoadGlobalConfigRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LoadGlobalConfigRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.ConfigPath) > 0 {
		i -= len(m.ConfigPath)
		copy(dAtA[i:], m.ConfigPath)
		i = encodeVarintPdpb(dAtA, i, uint64(len(m.ConfigPath)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Names) > 0 {
		for iNdEx := len(m.Names) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Names[iNdEx])
			copy(dAtA[i:], m.Names[iNdEx])
			i = encodeVarintPdpb(dAtA, i, uint64(len(m.Names[iNdEx])))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *LoadGlobalConfigResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LoadGlobalConfigResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LoadGlobalConfigResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Revision != 0 {
		i = encodeVarintPdpb(dAtA, i, uint64(m.Revision))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Items) > 0 {
		for iNdEx := len(m.Items) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Items[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPdpb(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *GlobalConfigItem) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GlobalConfigItem) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GlobalConfigItem) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Payload) > 0 {
		i -= len(m.Payload)
		copy(dAtA[i:], m.Payload)
		i = encodeVarintPdpb(dAtA, i, uint64(len(m.Payload)))
		i--
		dAtA[i] = 0x2a
	}
	if m.Kind != 0 {
		i = encodeVarintPdpb(dAtA, i, uint64(m.Kind))
		i--
		dAtA[i] = 0x20
	}
	if m.Error != nil {
		{
			size, err := m.Error.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPdpb(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Value) > 0 {
		i -= len(m.Value)
		copy(dAtA[i:], m.Value)
		i = encodeVarintPdpb(dAtA, i, uint64(len(m.Value)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintPdpb(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *RequestHeader) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RequestHeader) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RequestHeader) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.SenderId != 0 {
		i = encodeVarintPdpb(dAtA, i, uint64(m.SenderId))
		i--
		dAtA[i] = 0x10
	}
	if m.ClusterId != 0 {
		i = encodeVarintPdpb(dAtA, i, uint64(m.ClusterId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ResponseHeader) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ResponseHeader) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ResponseHeader) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Error != nil {
		{
			size, err := m.Error.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPdpb(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.ClusterId != 0 {
		i = encodeVarintPdpb(dAtA, i, uint64(m.ClusterId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Error) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Error) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Error) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Message) > 0 {
		i -= len(m.Message)
		copy(dAtA[i:], m.Message)
		i = encodeVarintPdpb(dAtA, i, uint64(len(m.Message)))
		i--
		dAtA[i] = 0x12
	}
	if m.Type != 0 {
		i = encodeVarintPdpb(dAtA, i, uint64(m.Type))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *TsoRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TsoRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TsoRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.DcLocation) > 0 {
		i -= len(m.DcLocation)
		copy(dAtA[i:], m.DcLocation)
		i = encodeVarintPdpb(dAtA, i, uint64(len(m.DcLocation)))
		i--
		dAtA[i] = 0x1a
	}
	if m.Count != 0 {
		i = encodeVarintPdpb(dAtA, i, uint64(m.Count))
		i--
		dAtA[i] = 0x10
	}
	if m.Header != nil {
		{
			size, err := m.Header.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPdpb(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *TaasRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TaasRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TaasRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.DcLocation) > 0 {
		i -= len(m.DcLocation)
		copy(dAtA[i:], m.DcLocation)
		i = encodeVarintPdpb(dAtA, i, uint64(len(m.DcLocation)))
		i--
		dAtA[i] = 0x22
	}
	if m.Count != 0 {
		i = encodeVarintPdpb(dAtA, i, uint64(m.Count))
		i--
		dAtA[i] = 0x18
	}
	if m.Stamp {
		i--
		if m.Stamp {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if m.Header != nil {
		{
			size, err := m.Header.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPdpb(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Timestamp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Timestamp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Timestamp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.SuffixBits != 0 {
		i = encodeVarintPdpb(dAtA, i, uint64(m.SuffixBits))
		i--
		dAtA[i] = 0x18
	}
	if m.Logical != 0 {
		i = encodeVarintPdpb(dAtA, i, uint64(m.Logical))
		i--
		dAtA[i] = 0x10
	}
	if m.Physical != 0 {
		i = encodeVarintPdpb(dAtA, i, uint64(m.Physical))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *TsoResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TsoResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TsoResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Timestamp != nil {
		{
			size, err := m.Timestamp.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPdpb(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.Count != 0 {
		i = encodeVarintPdpb(dAtA, i, uint64(m.Count))
		i--
		dAtA[i] = 0x10
	}
	if m.Header != nil {
		{
			size, err := m.Header.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPdpb(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *BootstrapRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BootstrapRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BootstrapRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Region != nil {
		{
			size, err := m.Region.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPdpb(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.Store != nil {
		{
			size, err := m.Store.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPdpb(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Header != nil {
		{
			size, err := m.Header.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPdpb(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *BootstrapResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BootstrapResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BootstrapResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.ReplicationStatus != nil {
		{
			size, err := m.ReplicationStatus.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPdpb(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Header != nil {
		{
			size, err := m.Header.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPdpb(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *IsBootstrappedRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *IsBootstrappedRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *IsBootstrappedRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Header != nil {
		{
			size, err := m.Header.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPdpb(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *IsBootstrappedResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *IsBootstrappedResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *IsBootstrappedResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Bootstrapped {
		i--
		if m.Bootstrapped {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if m.Header != nil {
		{
			size, err := m.Header.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPdpb(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *AllocIDRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AllocIDRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AllocIDRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Header != nil {
		{
			size, err := m.Header.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPdpb(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *AllocIDResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AllocIDResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AllocIDResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Id != 0 {
		i = encodeVarintPdpb(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x10
	}
	if m.Header != nil {
		{
			size, err := m.Header.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPdpb(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *IsSnapshotRecoveringRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *IsSnapshotRecoveringRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *IsSnapshotRecoveringRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Header != nil {
		{
			size, err := m.Header.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPdpb(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *IsSnapshotRecoveringResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *IsSnapshotRecoveringResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *IsSnapshotRecoveringResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Marked {
		i--
		if m.Marked {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if m.Header != nil {
		{
			size, err := m.Header.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPdpb(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GetStoreRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetStoreRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetStoreRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.StoreId != 0 {
		i = encodeVarintPdpb(dAtA, i, uint64(m.StoreId))
		i--
		dAtA[i] = 0x10
	}
	if m.Header != nil {
		{
			size, err := m.Header.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPdpb(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GetStoreResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetStoreResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetStoreResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Stats != nil {
		{
			size, err := m.Stats.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPdpb(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.Store != nil {
		{
			size, err := m.Store.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPdpb(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Header != nil {
		{
			size, err := m.Header.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPdpb(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *PutStoreRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PutStoreRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PutStoreRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Store != nil {
		{
			size, err := m.Store.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPdpb(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Header != nil {
		{
			size, err := m.Header.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPdpb(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *PutStoreResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PutStoreResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PutStoreResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.ReplicationStatus != nil {
		{
			size, err := m.ReplicationStatus.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPdpb(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Header != nil {
		{
			size, err := m.Header.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPdpb(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GetAllStoresRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetAllStoresRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetAllStoresRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.ExcludeTombstoneStores {
		i--
		if m.ExcludeTombstoneStores {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if m.Header != nil {
		{
			size, err := m.Header.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPdpb(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GetAllStoresResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetAllStoresResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetAllStoresResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Stores) > 0 {
		for iNdEx := len(m.Stores) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Stores[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPdpb(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.Header != nil {
		{
			size, err := m.Header.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPdpb(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GetRegionRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetRegionRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetRegionRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.NeedBuckets {
		i--
		if m.NeedBuckets {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if len(m.RegionKey) > 0 {
		i -= len(m.RegionKey)
		copy(dAtA[i:], m.RegionKey)
		i = encodeVarintPdpb(dAtA, i, uint64(len(m.RegionKey)))
		i--
		dAtA[i] = 0x12
	}
	if m.Header != nil {
		{
			size, err := m.Header.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPdpb(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GetRegionResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetRegionResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetRegionResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Buckets != nil {
		{
			size, err := m.Buckets.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPdpb(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3a
	}
	if len(m.PendingPeers) > 0 {
		for iNdEx := len(m.PendingPeers) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.PendingPeers[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPdpb(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x32
		}
	}
	if len(m.DownPeers) > 0 {
		for iNdEx := len(m.DownPeers) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.DownPeers[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPdpb(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	if m.Leader != nil {
		{
			size, err := m.Leader.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPdpb(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.Region != nil {
		{
			size, err := m.Region.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPdpb(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Header != nil {
		{
			size, err := m.Header.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPdpb(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GetRegionByIDRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetRegionByIDRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetRegionByIDRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.NeedBuckets {
		i--
		if m.NeedBuckets {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if m.RegionId != 0 {
		i = encodeVarintPdpb(dAtA, i, uint64(m.RegionId))
		i--
		dAtA[i] = 0x10
	}
	if m.Header != nil {
		{
			size, err := m.Header.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPdpb(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ScanRegionsRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ScanRegionsRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ScanRegionsRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.EndKey) > 0 {
		i -= len(m.EndKey)
		copy(dAtA[i:], m.EndKey)
		i = encodeVarintPdpb(dAtA, i, uint64(len(m.EndKey)))
		i--
		dAtA[i] = 0x22
	}
	if m.Limit != 0 {
		i = encodeVarintPdpb(dAtA, i, uint64(m.Limit))
		i--
		dAtA[i] = 0x18
	}
	if len(m.StartKey) > 0 {
		i -= len(m.StartKey)
		copy(dAtA[i:], m.StartKey)
		i = encodeVarintPdpb(dAtA, i, uint64(len(m.StartKey)))
		i--
		dAtA[i] = 0x12
	}
	if m.Header != nil {
		{
			size, err := m.Header.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPdpb(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Region) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Region) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Region) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.PendingPeers) > 0 {
		for iNdEx := len(m.PendingPeers) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.PendingPeers[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPdpb(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.DownPeers) > 0 {
		for iNdEx := len(m.DownPeers) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.DownPeers[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPdpb(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if m.Leader != nil {
		{
			size, err := m.Leader.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPdpb(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Region != nil {
		{
			size, err := m.Region.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPdpb(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ScanRegionsResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ScanRegionsResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ScanRegionsResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Regions) > 0 {
		for iNdEx := len(m.Regions) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Regions[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPdpb(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.Leaders) > 0 {
		for iNdEx := len(m.Leaders) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Leaders[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPdpb(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.RegionMetas) > 0 {
		for iNdEx := len(m.RegionMetas) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.RegionMetas[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPdpb(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.Header != nil {
		{
			size, err := m.Header.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPdpb(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GetClusterConfigRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetClusterConfigRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetClusterConfigRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Header != nil {
		{
			size, err := m.Header.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPdpb(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GetClusterConfigResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetClusterConfigResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetClusterConfigResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Cluster != nil {
		{
			size, err := m.Cluster.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPdpb(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Header != nil {
		{
			size, err := m.Header.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPdpb(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *PutClusterConfigRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PutClusterConfigRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PutClusterConfigRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Cluster != nil {
		{
			size, err := m.Cluster.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPdpb(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Header != nil {
		{
			size, err := m.Header.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPdpb(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *PutClusterConfigResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PutClusterConfigResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PutClusterConfigResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Header != nil {
		{
			size, err := m.Header.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPdpb(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Member) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Member) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Member) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.DcLocation) > 0 {
		i -= len(m.DcLocation)
		copy(dAtA[i:], m.DcLocation)
		i = encodeVarintPdpb(dAtA, i, uint64(len(m.DcLocation)))
		i--
		dAtA[i] = 0x4a
	}
	if len(m.GitHash) > 0 {
		i -= len(m.GitHash)
		copy(dAtA[i:], m.GitHash)
		i = encodeVarintPdpb(dAtA, i, uint64(len(m.GitHash)))
		i--
		dAtA[i] = 0x42
	}
	if len(m.BinaryVersion) > 0 {
		i -= len(m.BinaryVersion)
		copy(dAtA[i:], m.BinaryVersion)
		i = encodeVarintPdpb(dAtA, i, uint64(len(m.BinaryVersion)))
		i--
		dAtA[i] = 0x3a
	}
	if len(m.DeployPath) > 0 {
		i -= len(m.DeployPath)
		copy(dAtA[i:], m.DeployPath)
		i = encodeVarintPdpb(dAtA, i, uint64(len(m.DeployPath)))
		i--
		dAtA[i] = 0x32
	}
	if m.LeaderPriority != 0 {
		i = encodeVarintPdpb(dAtA, i, uint64(m.LeaderPriority))
		i--
		dAtA[i] = 0x28
	}
	if len(m.ClientUrls) > 0 {
		for iNdEx := len(m.ClientUrls) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.ClientUrls[iNdEx])
			copy(dAtA[i:], m.ClientUrls[iNdEx])
			i = encodeVarintPdpb(dAtA, i, uint64(len(m.ClientUrls[iNdEx])))
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.PeerUrls) > 0 {
		for iNdEx := len(m.PeerUrls) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.PeerUrls[iNdEx])
			copy(dAtA[i:], m.PeerUrls[iNdEx])
			i = encodeVarintPdpb(dAtA, i, uint64(len(m.PeerUrls[iNdEx])))
			i--
			dAtA[i] = 0x1a
		}
	}
	if m.MemberId != 0 {
		i = encodeVarintPdpb(dAtA, i, uint64(m.MemberId))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintPdpb(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GetMembersRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetMembersRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetMembersRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Header != nil {
		{
			size, err := m.Header.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPdpb(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GetMembersResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetMembersResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetMembersResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.TsoAllocatorLeaders) > 0 {
		for k := range m.TsoAllocatorLeaders {
			v := m.TsoAllocatorLeaders[k]
			baseI := i
			if v != nil {
				{
					size, err := v.MarshalToSizedBuffer(dAtA[:i])
					if err != nil {
						return 0, err
					}
					i -= size
					i = encodeVarintPdpb(dAtA, i, uint64(size))
				}
				i--
				dAtA[i] = 0x12
			}
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintPdpb(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintPdpb(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x2a
		}
	}
	if m.EtcdLeader != nil {
		{
			size, err := m.EtcdLeader.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPdpb(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.Leader != nil {
		{
			size, err := m.Leader.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPdpb(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Members) > 0 {
		for iNdEx := len(m.Members) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Members[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPdpb(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.Header != nil {
		{
			size, err := m.Header.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPdpb(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GetClusterInfoRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetClusterInfoRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetClusterInfoRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Header != nil {
		{
			size, err := m.Header.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPdpb(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GetClusterInfoResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetClusterInfoResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetClusterInfoResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.ServiceModes) > 0 {
		dAtA53 := make([]byte, len(m.ServiceModes)*10)
		var j52 int
		for _, num := range m.ServiceModes {
			for num >= 1<<7 {
				dAtA53[j52] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j52++
			}
			dAtA53[j52] = uint8(num)
			j52++
		}
		i -= j52
		copy(dAtA[i:], dAtA53[:j52])
		i = encodeVarintPdpb(dAtA, i, uint64(j52))
		i--
		dAtA[i] = 0x12
	}
	if m.Header != nil {
		{
			size, err := m.Header.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPdpb(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *PeerStats) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PeerStats) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PeerStats) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.DownSeconds != 0 {
		i = encodeVarintPdpb(dAtA, i, uint64(m.DownSeconds))
		i--
		dAtA[i] = 0x10
	}
	if m.Peer != nil {
		{
			size, err := m.Peer.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPdpb(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *RegionHeartbeatRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RegionHeartbeatRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RegionHeartbeatRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.ApproximateKvSize != 0 {
		i = encodeVarintPdpb(dAtA, i, uint64(m.ApproximateKvSize))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x90
	}
	if m.CpuUsage != 0 {
		i = encodeVarintPdpb(dAtA, i, uint64(m.CpuUsage))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x88
	}
	if m.QueryStats != nil {
		{
			size, err := m.QueryStats.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPdpb(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x82
	}
	if m.ReplicationStatus != nil {
		{
			size, err := m.ReplicationStatus.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPdpb(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x7a
	}
	if m.Term != 0 {
		i = encodeVarintPdpb(dAtA, i, uint64(m.Term))
		i--
		dAtA[i] = 0x70
	}
	if m.ApproximateKeys != 0 {
		i = encodeVarintPdpb(dAtA, i, uint64(m.ApproximateKeys))
		i--
		dAtA[i] = 0x68
	}
	if m.Interval != nil {
		{
			size, err := m.Interval.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPdpb(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x62
	}
	if m.ApproximateSize != 0 {
		i = encodeVarintPdpb(dAtA, i, uint64(m.ApproximateSize))
		i--
		dAtA[i] = 0x50
	}
	if m.KeysRead != 0 {
		i = encodeVarintPdpb(dAtA, i, uint64(m.KeysRead))
		i--
		dAtA[i] = 0x48
	}
	if m.KeysWritten != 0 {
		i = encodeVarintPdpb(dAtA, i, uint64(m.KeysWritten))
		i--
		dAtA[i] = 0x40
	}
	if m.BytesRead != 0 {
		i = encodeVarintPdpb(dAtA, i, uint64(m.BytesRead))
		i--
		dAtA[i] = 0x38
	}
	if m.BytesWritten != 0 {
		i = encodeVarintPdpb(dAtA, i, uint64(m.BytesWritten))
		i--
		dAtA[i] = 0x30
	}
	if len(m.PendingPeers) > 0 {
		for iNdEx := len(m.PendingPeers) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.PendingPeers[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPdpb(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	if len(m.DownPeers) > 0 {
		for iNdEx := len(m.DownPeers) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.DownPeers[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPdpb(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if m.Leader != nil {
		{
			size, err := m.Leader.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPdpb(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.Region != nil {
		{
			size, err := m.Region.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPdpb(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Header != nil {
		{
			size, err := m.Header.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPdpb(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ChangePeer) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ChangePeer) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ChangePeer) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.ChangeType != 0 {
		i = encodeVarintPdpb(dAtA, i, uint64(m.ChangeType))
		i--
		dAtA[i] = 0x10
	}
	if m.Peer != nil {
		{
			size, err := m.Peer.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPdpb(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ChangePeerV2) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ChangePeerV2) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ChangePeerV2) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Changes) > 0 {
		for iNdEx := len(m.Changes) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Changes[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPdpb(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *TransferLeader) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TransferLeader) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TransferLeader) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Peers) > 0 {
		for iNdEx := len(m.Peers) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Peers[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPdpb(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.Peer != nil {
		{
			size, err := m.Peer.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPdpb(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Merge) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Merge) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Merge) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Target != nil {
		{
			size, err := m.Target.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPdpb(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SplitRegion) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SplitRegion) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SplitRegion) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Keys) > 0 {
		for iNdEx := len(m.Keys) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Keys[iNdEx])
			copy(dAtA[i:], m.Keys[iNdEx])
			i = encodeVarintPdpb(dAtA, i, uint64(len(m.Keys[iNdEx])))
			i--
			dAtA[i] = 0x12
		}
	}
	if m.Policy != 0 {
		i = encodeVarintPdpb(dAtA, i, uint64(m.Policy))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *SwitchWitness) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SwitchWitness) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SwitchWitness) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.IsWitness {
		i--
		if m.IsWitness {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if m.PeerId != 0 {
		i = encodeVarintPdpb(dAtA, i, uint64(m.PeerId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *BatchSwitchWitness) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BatchSwitchWitness) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BatchSwitchWitness) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.SwitchWitnesses) > 0 {
		for iNdEx := len(m.SwitchWitnesses) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.SwitchWitnesses[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPdpb(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *RegionHeartbeatResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RegionHeartbeatResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RegionHeartbeatResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.SwitchWitnesses != nil {
		{
			size, err := m.SwitchWitnesses.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPdpb(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x52
	}
	if m.ChangePeerV2 != nil {
		{
			size, err := m.ChangePeerV2.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPdpb(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x4a
	}
	if m.SplitRegion != nil {
		{
			size, err := m.SplitRegion.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPdpb(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x42
	}
	if m.Merge != nil {
		{
			size, err := m.Merge.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPdpb(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3a
	}
	if m.TargetPeer != nil {
		{
			size, err := m.TargetPeer.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPdpb(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	if m.RegionEpoch != nil {
		{
			size, err := m.RegionEpoch.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPdpb(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if m.RegionId != 0 {
		i = encodeVarintPdpb(dAtA, i, uint64(m.RegionId))
		i--
		dAtA[i] = 0x20
	}
	if m.TransferLeader != nil {
		{
			size, err := m.TransferLeader.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPdpb(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.ChangePeer != nil {
		{
			size, err := m.ChangePeer.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPdpb(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Header != nil {
		{
			size, err := m.Header.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPdpb(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *AskSplitRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AskSplitRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AskSplitRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Region != nil {
		{
			size, err := m.Region.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPdpb(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Header != nil {
		{
			size, err := m.Header.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPdpb(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *AskSplitResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AskSplitResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AskSplitResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.NewPeerIds) > 0 {
		dAtA77 := make([]byte, len(m.NewPeerIds)*10)
		var j76 int
		for _, num := range m.NewPeerIds {
			for num >= 1<<7 {
				dAtA77[j76] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j76++
			}
			dAtA77[j76] = uint8(num)
			j76++
		}
		i -= j76
		copy(dAtA[i:], dAtA77[:j76])
		i = encodeVarintPdpb(dAtA, i, uint64(j76))
		i--
		dAtA[i] = 0x1a
	}
	if m.NewRegionId != 0 {
		i = encodeVarintPdpb(dAtA, i, uint64(m.NewRegionId))
		i--
		dAtA[i] = 0x10
	}
	if m.Header != nil {
		{
			size, err := m.Header.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPdpb(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ReportSplitRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReportSplitRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ReportSplitRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Right != nil {
		{
			size, err := m.Right.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPdpb(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.Left != nil {
		{
			size, err := m.Left.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPdpb(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Header != nil {
		{
			size, err := m.Header.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPdpb(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ReportSplitResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReportSplitResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ReportSplitResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Header != nil {
		{
			size, err := m.Header.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPdpb(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *AskBatchSplitRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AskBatchSplitRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AskBatchSplitRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.SplitCount != 0 {
		i = encodeVarintPdpb(dAtA, i, uint64(m.SplitCount))
		i--
		dAtA[i] = 0x18
	}
	if m.Region != nil {
		{
			size, err := m.Region.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPdpb(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Header != nil {
		{
			size, err := m.Header.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPdpb(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SplitID) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SplitID) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SplitID) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.NewPeerIds) > 0 {
		dAtA86 := make([]byte, len(m.NewPeerIds)*10)
		var j85 int
		for _, num := range m.NewPeerIds {
			for num >= 1<<7 {
				dAtA86[j85] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j85++
			}
			dAtA86[j85] = uint8(num)
			j85++
		}
		i -= j85
		copy(dAtA[i:], dAtA86[:j85])
		i = encodeVarintPdpb(dAtA, i, uint64(j85))
		i--
		dAtA[i] = 0x12
	}
	if m.NewRegionId != 0 {
		i = encodeVarintPdpb(dAtA, i, uint64(m.NewRegionId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *AskBatchSplitResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AskBatchSplitResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AskBatchSplitResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Ids) > 0 {
		for iNdEx := len(m.Ids) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Ids[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPdpb(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.Header != nil {
		{
			size, err := m.Header.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPdpb(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ReportBatchSplitRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReportBatchSplitRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ReportBatchSplitRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Regions) > 0 {
		for iNdEx := len(m.Regions) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Regions[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPdpb(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.Header != nil {
		{
			size, err := m.Header.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPdpb(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ReportBatchSplitResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReportBatchSplitResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ReportBatchSplitResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Header != nil {
		{
			size, err := m.Header.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPdpb(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *TimeInterval) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TimeInterval) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TimeInterval) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.EndTimestamp != 0 {
		i = encodeVarintPdpb(dAtA, i, uint64(m.EndTimestamp))
		i--
		dAtA[i] = 0x10
	}
	if m.StartTimestamp != 0 {
		i = encodeVarintPdpb(dAtA, i, uint64(m.StartTimestamp))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *RecordPair) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RecordPair) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RecordPair) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Value != 0 {
		i = encodeVarintPdpb(dAtA, i, uint64(m.Value))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Key) > 0 {
		i -= len(m.Key)
		copy(dAtA[i:], m.Key)
		i = encodeVarintPdpb(dAtA, i, uint64(len(m.Key)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *PeerStat) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PeerStat) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PeerStat) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.WrittenBytes != 0 {
		i = encodeVarintPdpb(dAtA, i, uint64(m.WrittenBytes))
		i--
		dAtA[i] = 0x30
	}
	if m.WrittenKeys != 0 {
		i = encodeVarintPdpb(dAtA, i, uint64(m.WrittenKeys))
		i--
		dAtA[i] = 0x28
	}
	if m.QueryStats != nil {
		{
			size, err := m.QueryStats.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPdpb(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.ReadBytes != 0 {
		i = encodeVarintPdpb(dAtA, i, uint64(m.ReadBytes))
		i--
		dAtA[i] = 0x18
	}
	if m.ReadKeys != 0 {
		i = encodeVarintPdpb(dAtA, i, uint64(m.ReadKeys))
		i--
		dAtA[i] = 0x10
	}
	if m.RegionId != 0 {
		i = encodeVarintPdpb(dAtA, i, uint64(m.RegionId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *StoreStats) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StoreStats) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *StoreStats) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.SlowTrend != nil {
		{
			size, err := m.SlowTrend.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPdpb(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xd2
	}
	if len(m.SnapshotStats) > 0 {
		for iNdEx := len(m.SnapshotStats) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.SnapshotStats[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPdpb(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0xca
		}
	}
	if m.IsApplyBusy {
		i--
		if m.IsApplyBusy {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xc0
	}
	if len(m.DamagedRegionsId) > 0 {
		dAtA93 := make([]byte, len(m.DamagedRegionsId)*10)
		var j92 int
		for _, num := range m.DamagedRegionsId {
			for num >= 1<<7 {
				dAtA93[j92] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j92++
			}
			dAtA93[j92] = uint8(num)
			j92++
		}
		i -= j92
		copy(dAtA[i:], dAtA93[:j92])
		i = encodeVarintPdpb(dAtA, i, uint64(j92))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xba
	}
	if m.SlowScore != 0 {
		i = encodeVarintPdpb(dAtA, i, uint64(m.SlowScore))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xb0
	}
	if m.QueryStats != nil {
		{
			size, err := m.QueryStats.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPdpb(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xaa
	}
	if len(m.PeerStats) > 0 {
		for iNdEx := len(m.PeerStats) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.PeerStats[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPdpb(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0xa2
		}
	}
	if len(m.OpLatencies) > 0 {
		for iNdEx := len(m.OpLatencies) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.OpLatencies[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPdpb(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0x9a
		}
	}
	if len(m.WriteIoRates) > 0 {
		for iNdEx := len(m.WriteIoRates) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.WriteIoRates[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPdpb(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0x92
		}
	}
	if len(m.ReadIoRates) > 0 {
		for iNdEx := len(m.ReadIoRates) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.ReadIoRates[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPdpb(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0x8a
		}
	}
	if len(m.CpuUsages) > 0 {
		for iNdEx := len(m.CpuUsages) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.CpuUsages[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPdpb(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0x82
		}
	}
	if m.Interval != nil {
		{
			size, err := m.Interval.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPdpb(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x7a
	}
	if m.KeysRead != 0 {
		i = encodeVarintPdpb(dAtA, i, uint64(m.KeysRead))
		i--
		dAtA[i] = 0x70
	}
	if m.BytesRead != 0 {
		i = encodeVarintPdpb(dAtA, i, uint64(m.BytesRead))
		i--
		dAtA[i] = 0x68
	}
	if m.KeysWritten != 0 {
		i = encodeVarintPdpb(dAtA, i, uint64(m.KeysWritten))
		i--
		dAtA[i] = 0x60
	}
	if m.BytesWritten != 0 {
		i = encodeVarintPdpb(dAtA, i, uint64(m.BytesWritten))
		i--
		dAtA[i] = 0x58
	}
	if m.UsedSize != 0 {
		i = encodeVarintPdpb(dAtA, i, uint64(m.UsedSize))
		i--
		dAtA[i] = 0x50
	}
	if m.IsBusy {
		i--
		if m.IsBusy {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x48
	}
	if m.ApplyingSnapCount != 0 {
		i = encodeVarintPdpb(dAtA, i, uint64(m.ApplyingSnapCount))
		i--
		dAtA[i] = 0x40
	}
	if m.StartTime != 0 {
		i = encodeVarintPdpb(dAtA, i, uint64(m.StartTime))
		i--
		dAtA[i] = 0x38
	}
	if m.ReceivingSnapCount != 0 {
		i = encodeVarintPdpb(dAtA, i, uint64(m.ReceivingSnapCount))
		i--
		dAtA[i] = 0x30
	}
	if m.SendingSnapCount != 0 {
		i = encodeVarintPdpb(dAtA, i, uint64(m.SendingSnapCount))
		i--
		dAtA[i] = 0x28
	}
	if m.RegionCount != 0 {
		i = encodeVarintPdpb(dAtA, i, uint64(m.RegionCount))
		i--
		dAtA[i] = 0x20
	}
	if m.Available != 0 {
		i = encodeVarintPdpb(dAtA, i, uint64(m.Available))
		i--
		dAtA[i] = 0x18
	}
	if m.Capacity != 0 {
		i = encodeVarintPdpb(dAtA, i, uint64(m.Capacity))
		i--
		dAtA[i] = 0x10
	}
	if m.StoreId != 0 {
		i = encodeVarintPdpb(dAtA, i, uint64(m.StoreId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *SlowTrend) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SlowTrend) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SlowTrend) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.ResultRate != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.ResultRate))))
		i--
		dAtA[i] = 0x21
	}
	if m.ResultValue != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.ResultValue))))
		i--
		dAtA[i] = 0x19
	}
	if m.CauseRate != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.CauseRate))))
		i--
		dAtA[i] = 0x11
	}
	if m.CauseValue != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.CauseValue))))
		i--
		dAtA[i] = 0x9
	}
	return len(dAtA) - i, nil
}

func (m *SnapshotStat) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SnapshotStat) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SnapshotStat) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.TransportSize != 0 {
		i = encodeVarintPdpb(dAtA, i, uint64(m.TransportSize))
		i--
		dAtA[i] = 0x28
	}
	if m.TotalDurationSec != 0 {
		i = encodeVarintPdpb(dAtA, i, uint64(m.TotalDurationSec))
		i--
		dAtA[i] = 0x20
	}
	if m.SendDurationSec != 0 {
		i = encodeVarintPdpb(dAtA, i, uint64(m.SendDurationSec))
		i--
		dAtA[i] = 0x18
	}
	if m.GenerateDurationSec != 0 {
		i = encodeVarintPdpb(dAtA, i, uint64(m.GenerateDurationSec))
		i--
		dAtA[i] = 0x10
	}
	if m.RegionId != 0 {
		i = encodeVarintPdpb(dAtA, i, uint64(m.RegionId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *PeerReport) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PeerReport) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PeerReport) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.HasCommitMerge {
		i--
		if m.HasCommitMerge {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x20
	}
	if m.IsForceLeader {
		i--
		if m.IsForceLeader {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if m.RegionState != nil {
		{
			size, err := m.RegionState.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPdpb(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.RaftState != nil {
		{
			size, err := m.RaftState.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPdpb(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *StoreReport) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StoreReport) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *StoreReport) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Step != 0 {
		i = encodeVarintPdpb(dAtA, i, uint64(m.Step))
		i--
		dAtA[i] = 0x10
	}
	if len(m.PeerReports) > 0 {
		for iNdEx := len(m.PeerReports) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.PeerReports[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPdpb(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *StoreHeartbeatRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StoreHeartbeatRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *StoreHeartbeatRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.DrAutosyncStatus != nil {
		{
			size, err := m.DrAutosyncStatus.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPdpb(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.StoreReport != nil {
		{
			size, err := m.StoreReport.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPdpb(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.Stats != nil {
		{
			size, err := m.Stats.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPdpb(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Header != nil {
		{
			size, err := m.Header.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPdpb(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *DemoteFailedVoters) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DemoteFailedVoters) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DemoteFailedVoters) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.FailedVoters) > 0 {
		for iNdEx := len(m.FailedVoters) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.FailedVoters[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPdpb(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.RegionId != 0 {
		i = encodeVarintPdpb(dAtA, i, uint64(m.RegionId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ForceLeader) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ForceLeader) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ForceLeader) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.EnterForceLeaders) > 0 {
		dAtA103 := make([]byte, len(m.EnterForceLeaders)*10)
		var j102 int
		for _, num := range m.EnterForceLeaders {
			for num >= 1<<7 {
				dAtA103[j102] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j102++
			}
			dAtA103[j102] = uint8(num)
			j102++
		}
		i -= j102
		copy(dAtA[i:], dAtA103[:j102])
		i = encodeVarintPdpb(dAtA, i, uint64(j102))
		i--
		dAtA[i] = 0x12
	}
	if len(m.FailedStores) > 0 {
		dAtA105 := make([]byte, len(m.FailedStores)*10)
		var j104 int
		for _, num := range m.FailedStores {
			for num >= 1<<7 {
				dAtA105[j104] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j104++
			}
			dAtA105[j104] = uint8(num)
			j104++
		}
		i -= j104
		copy(dAtA[i:], dAtA105[:j104])
		i = encodeVarintPdpb(dAtA, i, uint64(j104))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *RecoveryPlan) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RecoveryPlan) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RecoveryPlan) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Step != 0 {
		i = encodeVarintPdpb(dAtA, i, uint64(m.Step))
		i--
		dAtA[i] = 0x30
	}
	if m.ForceLeader != nil {
		{
			size, err := m.ForceLeader.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPdpb(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if len(m.Demotes) > 0 {
		for iNdEx := len(m.Demotes) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Demotes[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPdpb(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.Tombstones) > 0 {
		dAtA108 := make([]byte, len(m.Tombstones)*10)
		var j107 int
		for _, num := range m.Tombstones {
			for num >= 1<<7 {
				dAtA108[j107] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j107++
			}
			dAtA108[j107] = uint8(num)
			j107++
		}
		i -= j107
		copy(dAtA[i:], dAtA108[:j107])
		i = encodeVarintPdpb(dAtA, i, uint64(j107))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Updates) > 0 {
		for iNdEx := len(m.Updates) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Updates[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPdpb(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.Creates) > 0 {
		for iNdEx := len(m.Creates) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Creates[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPdpb(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *AwakenRegions) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AwakenRegions) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AwakenRegions) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.AbnormalStores) > 0 {
		dAtA110 := make([]byte, len(m.AbnormalStores)*10)
		var j109 int
		for _, num := range m.AbnormalStores {
			for num >= 1<<7 {
				dAtA110[j109] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j109++
			}
			dAtA110[j109] = uint8(num)
			j109++
		}
		i -= j109
		copy(dAtA[i:], dAtA110[:j109])
		i = encodeVarintPdpb(dAtA, i, uint64(j109))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *StoreHeartbeatResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StoreHeartbeatResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *StoreHeartbeatResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.AwakenRegions != nil {
		{
			size, err := m.AwakenRegions.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPdpb(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	if m.RecoveryPlan != nil {
		{
			size, err := m.RecoveryPlan.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPdpb(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if m.RequireDetailedReport {
		i--
		if m.RequireDetailedReport {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x20
	}
	if len(m.ClusterVersion) > 0 {
		i -= len(m.ClusterVersion)
		copy(dAtA[i:], m.ClusterVersion)
		i = encodeVarintPdpb(dAtA, i, uint64(len(m.ClusterVersion)))
		i--
		dAtA[i] = 0x1a
	}
	if m.ReplicationStatus != nil {
		{
			size, err := m.ReplicationStatus.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPdpb(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Header != nil {
		{
			size, err := m.Header.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPdpb(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ScatterRegionRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ScatterRegionRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ScatterRegionRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.RetryLimit != 0 {
		i = encodeVarintPdpb(dAtA, i, uint64(m.RetryLimit))
		i--
		dAtA[i] = 0x38
	}
	if len(m.RegionsId) > 0 {
		dAtA116 := make([]byte, len(m.RegionsId)*10)
		var j115 int
		for _, num := range m.RegionsId {
			for num >= 1<<7 {
				dAtA116[j115] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j115++
			}
			dAtA116[j115] = uint8(num)
			j115++
		}
		i -= j115
		copy(dAtA[i:], dAtA116[:j115])
		i = encodeVarintPdpb(dAtA, i, uint64(j115))
		i--
		dAtA[i] = 0x32
	}
	if len(m.Group) > 0 {
		i -= len(m.Group)
		copy(dAtA[i:], m.Group)
		i = encodeVarintPdpb(dAtA, i, uint64(len(m.Group)))
		i--
		dAtA[i] = 0x2a
	}
	if m.Leader != nil {
		{
			size, err := m.Leader.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPdpb(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.Region != nil {
		{
			size, err := m.Region.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPdpb(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.RegionId != 0 {
		i = encodeVarintPdpb(dAtA, i, uint64(m.RegionId))
		i--
		dAtA[i] = 0x10
	}
	if m.Header != nil {
		{
			size, err := m.Header.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPdpb(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ScatterRegionResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ScatterRegionResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ScatterRegionResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.FinishedPercentage != 0 {
		i = encodeVarintPdpb(dAtA, i, uint64(m.FinishedPercentage))
		i--
		dAtA[i] = 0x10
	}
	if m.Header != nil {
		{
			size, err := m.Header.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPdpb(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GetGCSafePointRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetGCSafePointRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetGCSafePointRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Header != nil {
		{
			size, err := m.Header.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPdpb(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GetGCSafePointResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetGCSafePointResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetGCSafePointResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.SafePoint != 0 {
		i = encodeVarintPdpb(dAtA, i, uint64(m.SafePoint))
		i--
		dAtA[i] = 0x10
	}
	if m.Header != nil {
		{
			size, err := m.Header.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPdpb(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *UpdateGCSafePointRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UpdateGCSafePointRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UpdateGCSafePointRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.SafePoint != 0 {
		i = encodeVarintPdpb(dAtA, i, uint64(m.SafePoint))
		i--
		dAtA[i] = 0x10
	}
	if m.Header != nil {
		{
			size, err := m.Header.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPdpb(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *UpdateGCSafePointResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UpdateGCSafePointResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UpdateGCSafePointResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.NewSafePoint != 0 {
		i = encodeVarintPdpb(dAtA, i, uint64(m.NewSafePoint))
		i--
		dAtA[i] = 0x10
	}
	if m.Header != nil {
		{
			size, err := m.Header.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPdpb(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *UpdateServiceGCSafePointRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UpdateServiceGCSafePointRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UpdateServiceGCSafePointRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.SafePoint != 0 {
		i = encodeVarintPdpb(dAtA, i, uint64(m.SafePoint))
		i--
		dAtA[i] = 0x20
	}
	if m.TTL != 0 {
		i = encodeVarintPdpb(dAtA, i, uint64(m.TTL))
		i--
		dAtA[i] = 0x18
	}
	if len(m.ServiceId) > 0 {
		i -= len(m.ServiceId)
		copy(dAtA[i:], m.ServiceId)
		i = encodeVarintPdpb(dAtA, i, uint64(len(m.ServiceId)))
		i--
		dAtA[i] = 0x12
	}
	if m.Header != nil {
		{
			size, err := m.Header.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPdpb(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *UpdateServiceGCSafePointResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UpdateServiceGCSafePointResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UpdateServiceGCSafePointResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.MinSafePoint != 0 {
		i = encodeVarintPdpb(dAtA, i, uint64(m.MinSafePoint))
		i--
		dAtA[i] = 0x20
	}
	if m.TTL != 0 {
		i = encodeVarintPdpb(dAtA, i, uint64(m.TTL))
		i--
		dAtA[i] = 0x18
	}
	if len(m.ServiceId) > 0 {
		i -= len(m.ServiceId)
		copy(dAtA[i:], m.ServiceId)
		i = encodeVarintPdpb(dAtA, i, uint64(len(m.ServiceId)))
		i--
		dAtA[i] = 0x12
	}
	if m.Header != nil {
		{
			size, err := m.Header.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPdpb(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *RegionStat) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RegionStat) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RegionStat) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.KeysRead != 0 {
		i = encodeVarintPdpb(dAtA, i, uint64(m.KeysRead))
		i--
		dAtA[i] = 0x20
	}
	if m.KeysWritten != 0 {
		i = encodeVarintPdpb(dAtA, i, uint64(m.KeysWritten))
		i--
		dAtA[i] = 0x18
	}
	if m.BytesRead != 0 {
		i = encodeVarintPdpb(dAtA, i, uint64(m.BytesRead))
		i--
		dAtA[i] = 0x10
	}
	if m.BytesWritten != 0 {
		i = encodeVarintPdpb(dAtA, i, uint64(m.BytesWritten))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *SyncRegionRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SyncRegionRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SyncRegionRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.StartIndex != 0 {
		i = encodeVarintPdpb(dAtA, i, uint64(m.StartIndex))
		i--
		dAtA[i] = 0x18
	}
	if m.Member != nil {
		{
			size, err := m.Member.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPdpb(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Header != nil {
		{
			size, err := m.Header.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPdpb(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SyncRegionResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SyncRegionResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SyncRegionResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Buckets) > 0 {
		for iNdEx := len(m.Buckets) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Buckets[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPdpb(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x32
		}
	}
	if len(m.RegionLeaders) > 0 {
		for iNdEx := len(m.RegionLeaders) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.RegionLeaders[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPdpb(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	if len(m.RegionStats) > 0 {
		for iNdEx := len(m.RegionStats) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.RegionStats[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPdpb(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if m.StartIndex != 0 {
		i = encodeVarintPdpb(dAtA, i, uint64(m.StartIndex))
		i--
		dAtA[i] = 0x18
	}
	if len(m.Regions) > 0 {
		for iNdEx := len(m.Regions) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Regions[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPdpb(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.Header != nil {
		{
			size, err := m.Header.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPdpb(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GetOperatorRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetOperatorRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetOperatorRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.RegionId != 0 {
		i = encodeVarintPdpb(dAtA, i, uint64(m.RegionId))
		i--
		dAtA[i] = 0x10
	}
	if m.Header != nil {
		{
			size, err := m.Header.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPdpb(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GetOperatorResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetOperatorResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetOperatorResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Kind) > 0 {
		i -= len(m.Kind)
		copy(dAtA[i:], m.Kind)
		i = encodeVarintPdpb(dAtA, i, uint64(len(m.Kind)))
		i--
		dAtA[i] = 0x2a
	}
	if m.Status != 0 {
		i = encodeVarintPdpb(dAtA, i, uint64(m.Status))
		i--
		dAtA[i] = 0x20
	}
	if len(m.Desc) > 0 {
		i -= len(m.Desc)
		copy(dAtA[i:], m.Desc)
		i = encodeVarintPdpb(dAtA, i, uint64(len(m.Desc)))
		i--
		dAtA[i] = 0x1a
	}
	if m.RegionId != 0 {
		i = encodeVarintPdpb(dAtA, i, uint64(m.RegionId))
		i--
		dAtA[i] = 0x10
	}
	if m.Header != nil {
		{
			size, err := m.Header.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPdpb(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SyncMaxTSRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SyncMaxTSRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SyncMaxTSRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.SkipCheck {
		i--
		if m.SkipCheck {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if m.MaxTs != nil {
		{
			size, err := m.MaxTs.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPdpb(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Header != nil {
		{
			size, err := m.Header.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPdpb(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SyncMaxTSResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SyncMaxTSResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SyncMaxTSResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.SyncedDcs) > 0 {
		for iNdEx := len(m.SyncedDcs) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.SyncedDcs[iNdEx])
			copy(dAtA[i:], m.SyncedDcs[iNdEx])
			i = encodeVarintPdpb(dAtA, i, uint64(len(m.SyncedDcs[iNdEx])))
			i--
			dAtA[i] = 0x1a
		}
	}
	if m.MaxLocalTs != nil {
		{
			size, err := m.MaxLocalTs.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPdpb(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Header != nil {
		{
			size, err := m.Header.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPdpb(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SplitRegionsRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SplitRegionsRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SplitRegionsRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.RetryLimit != 0 {
		i = encodeVarintPdpb(dAtA, i, uint64(m.RetryLimit))
		i--
		dAtA[i] = 0x18
	}
	if len(m.SplitKeys) > 0 {
		for iNdEx := len(m.SplitKeys) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.SplitKeys[iNdEx])
			copy(dAtA[i:], m.SplitKeys[iNdEx])
			i = encodeVarintPdpb(dAtA, i, uint64(len(m.SplitKeys[iNdEx])))
			i--
			dAtA[i] = 0x12
		}
	}
	if m.Header != nil {
		{
			size, err := m.Header.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPdpb(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SplitRegionsResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SplitRegionsResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SplitRegionsResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.RegionsId) > 0 {
		dAtA138 := make([]byte, len(m.RegionsId)*10)
		var j137 int
		for _, num := range m.RegionsId {
			for num >= 1<<7 {
				dAtA138[j137] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j137++
			}
			dAtA138[j137] = uint8(num)
			j137++
		}
		i -= j137
		copy(dAtA[i:], dAtA138[:j137])
		i = encodeVarintPdpb(dAtA, i, uint64(j137))
		i--
		dAtA[i] = 0x1a
	}
	if m.FinishedPercentage != 0 {
		i = encodeVarintPdpb(dAtA, i, uint64(m.FinishedPercentage))
		i--
		dAtA[i] = 0x10
	}
	if m.Header != nil {
		{
			size, err := m.Header.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPdpb(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SplitAndScatterRegionsRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SplitAndScatterRegionsRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SplitAndScatterRegionsRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.RetryLimit != 0 {
		i = encodeVarintPdpb(dAtA, i, uint64(m.RetryLimit))
		i--
		dAtA[i] = 0x20
	}
	if len(m.Group) > 0 {
		i -= len(m.Group)
		copy(dAtA[i:], m.Group)
		i = encodeVarintPdpb(dAtA, i, uint64(len(m.Group)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.SplitKeys) > 0 {
		for iNdEx := len(m.SplitKeys) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.SplitKeys[iNdEx])
			copy(dAtA[i:], m.SplitKeys[iNdEx])
			i = encodeVarintPdpb(dAtA, i, uint64(len(m.SplitKeys[iNdEx])))
			i--
			dAtA[i] = 0x12
		}
	}
	if m.Header != nil {
		{
			size, err := m.Header.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPdpb(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SplitAndScatterRegionsResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SplitAndScatterRegionsResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SplitAndScatterRegionsResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.RegionsId) > 0 {
		dAtA142 := make([]byte, len(m.RegionsId)*10)
		var j141 int
		for _, num := range m.RegionsId {
			for num >= 1<<7 {
				dAtA142[j141] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j141++
			}
			dAtA142[j141] = uint8(num)
			j141++
		}
		i -= j141
		copy(dAtA[i:], dAtA142[:j141])
		i = encodeVarintPdpb(dAtA, i, uint64(j141))
		i--
		dAtA[i] = 0x22
	}
	if m.ScatterFinishedPercentage != 0 {
		i = encodeVarintPdpb(dAtA, i, uint64(m.ScatterFinishedPercentage))
		i--
		dAtA[i] = 0x18
	}
	if m.SplitFinishedPercentage != 0 {
		i = encodeVarintPdpb(dAtA, i, uint64(m.SplitFinishedPercentage))
		i--
		dAtA[i] = 0x10
	}
	if m.Header != nil {
		{
			size, err := m.Header.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPdpb(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GetDCLocationInfoRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetDCLocationInfoRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetDCLocationInfoRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.DcLocation) > 0 {
		i -= len(m.DcLocation)
		copy(dAtA[i:], m.DcLocation)
		i = encodeVarintPdpb(dAtA, i, uint64(len(m.DcLocation)))
		i--
		dAtA[i] = 0x12
	}
	if m.Header != nil {
		{
			size, err := m.Header.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPdpb(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GetDCLocationInfoResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetDCLocationInfoResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetDCLocationInfoResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.MaxTs != nil {
		{
			size, err := m.MaxTs.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPdpb(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.Suffix != 0 {
		i = encodeVarintPdpb(dAtA, i, uint64(m.Suffix))
		i--
		dAtA[i] = 0x10
	}
	if m.Header != nil {
		{
			size, err := m.Header.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPdpb(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *QueryStats) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueryStats) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QueryStats) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Rollback != 0 {
		i = encodeVarintPdpb(dAtA, i, uint64(m.Rollback))
		i--
		dAtA[i] = 0x58
	}
	if m.Commit != 0 {
		i = encodeVarintPdpb(dAtA, i, uint64(m.Commit))
		i--
		dAtA[i] = 0x50
	}
	if m.AcquirePessimisticLock != 0 {
		i = encodeVarintPdpb(dAtA, i, uint64(m.AcquirePessimisticLock))
		i--
		dAtA[i] = 0x48
	}
	if m.Prewrite != 0 {
		i = encodeVarintPdpb(dAtA, i, uint64(m.Prewrite))
		i--
		dAtA[i] = 0x40
	}
	if m.Put != 0 {
		i = encodeVarintPdpb(dAtA, i, uint64(m.Put))
		i--
		dAtA[i] = 0x38
	}
	if m.DeleteRange != 0 {
		i = encodeVarintPdpb(dAtA, i, uint64(m.DeleteRange))
		i--
		dAtA[i] = 0x30
	}
	if m.Delete != 0 {
		i = encodeVarintPdpb(dAtA, i, uint64(m.Delete))
		i--
		dAtA[i] = 0x28
	}
	if m.Coprocessor != 0 {
		i = encodeVarintPdpb(dAtA, i, uint64(m.Coprocessor))
		i--
		dAtA[i] = 0x20
	}
	if m.Scan != 0 {
		i = encodeVarintPdpb(dAtA, i, uint64(m.Scan))
		i--
		dAtA[i] = 0x18
	}
	if m.Get != 0 {
		i = encodeVarintPdpb(dAtA, i, uint64(m.Get))
		i--
		dAtA[i] = 0x10
	}
	if m.GC != 0 {
		i = encodeVarintPdpb(dAtA, i, uint64(m.GC))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ReportBucketsRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReportBucketsRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ReportBucketsRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Buckets != nil {
		{
			size, err := m.Buckets.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPdpb(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.RegionEpoch != nil {
		{
			size, err := m.RegionEpoch.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPdpb(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Header != nil {
		{
			size, err := m.Header.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPdpb(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ReportBucketsResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReportBucketsResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ReportBucketsResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Header != nil {
		{
			size, err := m.Header.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPdpb(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ReportMinResolvedTsRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReportMinResolvedTsRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ReportMinResolvedTsRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.MinResolvedTs != 0 {
		i = encodeVarintPdpb(dAtA, i, uint64(m.MinResolvedTs))
		i--
		dAtA[i] = 0x18
	}
	if m.StoreId != 0 {
		i = encodeVarintPdpb(dAtA, i, uint64(m.StoreId))
		i--
		dAtA[i] = 0x10
	}
	if m.Header != nil {
		{
			size, err := m.Header.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPdpb(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ReportMinResolvedTsResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReportMinResolvedTsResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ReportMinResolvedTsResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Header != nil {
		{
			size, err := m.Header.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPdpb(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SetExternalTimestampRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SetExternalTimestampRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SetExternalTimestampRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Timestamp != 0 {
		i = encodeVarintPdpb(dAtA, i, uint64(m.Timestamp))
		i--
		dAtA[i] = 0x10
	}
	if m.Header != nil {
		{
			size, err := m.Header.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPdpb(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SetExternalTimestampResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SetExternalTimestampResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SetExternalTimestampResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Header != nil {
		{
			size, err := m.Header.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPdpb(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GetExternalTimestampRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetExternalTimestampRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetExternalTimestampRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Header != nil {
		{
			size, err := m.Header.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPdpb(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GetExternalTimestampResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetExternalTimestampResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetExternalTimestampResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Timestamp != 0 {
		i = encodeVarintPdpb(dAtA, i, uint64(m.Timestamp))
		i--
		dAtA[i] = 0x10
	}
	if m.Header != nil {
		{
			size, err := m.Header.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPdpb(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintPdpb(dAtA []byte, offset int, v uint64) int {
	offset -= sovPdpb(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *WatchGlobalConfigRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ConfigPath)
	if l > 0 {
		n += 1 + l + sovPdpb(uint64(l))
	}
	if m.Revision != 0 {
		n += 1 + sovPdpb(uint64(m.Revision))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *WatchGlobalConfigResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Changes) > 0 {
		for _, e := range m.Changes {
			l = e.Size()
			n += 1 + l + sovPdpb(uint64(l))
		}
	}
	if m.Revision != 0 {
		n += 1 + sovPdpb(uint64(m.Revision))
	}
	if m.Header != nil {
		l = m.Header.Size()
		n += 1 + l + sovPdpb(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *StoreGlobalConfigRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Changes) > 0 {
		for _, e := range m.Changes {
			l = e.Size()
			n += 1 + l + sovPdpb(uint64(l))
		}
	}
	l = len(m.ConfigPath)
	if l > 0 {
		n += 1 + l + sovPdpb(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *StoreGlobalConfigResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Error != nil {
		l = m.Error.Size()
		n += 1 + l + sovPdpb(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *LoadGlobalConfigRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Names) > 0 {
		for _, s := range m.Names {
			l = len(s)
			n += 1 + l + sovPdpb(uint64(l))
		}
	}
	l = len(m.ConfigPath)
	if l > 0 {
		n += 1 + l + sovPdpb(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *LoadGlobalConfigResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Items) > 0 {
		for _, e := range m.Items {
			l = e.Size()
			n += 1 + l + sovPdpb(uint64(l))
		}
	}
	if m.Revision != 0 {
		n += 1 + sovPdpb(uint64(m.Revision))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GlobalConfigItem) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovPdpb(uint64(l))
	}
	l = len(m.Value)
	if l > 0 {
		n += 1 + l + sovPdpb(uint64(l))
	}
	if m.Error != nil {
		l = m.Error.Size()
		n += 1 + l + sovPdpb(uint64(l))
	}
	if m.Kind != 0 {
		n += 1 + sovPdpb(uint64(m.Kind))
	}
	l = len(m.Payload)
	if l > 0 {
		n += 1 + l + sovPdpb(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RequestHeader) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ClusterId != 0 {
		n += 1 + sovPdpb(uint64(m.ClusterId))
	}
	if m.SenderId != 0 {
		n += 1 + sovPdpb(uint64(m.SenderId))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ResponseHeader) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ClusterId != 0 {
		n += 1 + sovPdpb(uint64(m.ClusterId))
	}
	if m.Error != nil {
		l = m.Error.Size()
		n += 1 + l + sovPdpb(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Error) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Type != 0 {
		n += 1 + sovPdpb(uint64(m.Type))
	}
	l = len(m.Message)
	if l > 0 {
		n += 1 + l + sovPdpb(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TsoRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Header != nil {
		l = m.Header.Size()
		n += 1 + l + sovPdpb(uint64(l))
	}
	if m.Count != 0 {
		n += 1 + sovPdpb(uint64(m.Count))
	}
	l = len(m.DcLocation)
	if l > 0 {
		n += 1 + l + sovPdpb(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TaasRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Header != nil {
		l = m.Header.Size()
		n += 1 + l + sovPdpb(uint64(l))
	}
	if m.Stamp {
		n += 2
	}
	if m.Count != 0 {
		n += 1 + sovPdpb(uint64(m.Count))
	}
	l = len(m.DcLocation)
	if l > 0 {
		n += 1 + l + sovPdpb(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Timestamp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Physical != 0 {
		n += 1 + sovPdpb(uint64(m.Physical))
	}
	if m.Logical != 0 {
		n += 1 + sovPdpb(uint64(m.Logical))
	}
	if m.SuffixBits != 0 {
		n += 1 + sovPdpb(uint64(m.SuffixBits))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TsoResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Header != nil {
		l = m.Header.Size()
		n += 1 + l + sovPdpb(uint64(l))
	}
	if m.Count != 0 {
		n += 1 + sovPdpb(uint64(m.Count))
	}
	if m.Timestamp != nil {
		l = m.Timestamp.Size()
		n += 1 + l + sovPdpb(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *BootstrapRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Header != nil {
		l = m.Header.Size()
		n += 1 + l + sovPdpb(uint64(l))
	}
	if m.Store != nil {
		l = m.Store.Size()
		n += 1 + l + sovPdpb(uint64(l))
	}
	if m.Region != nil {
		l = m.Region.Size()
		n += 1 + l + sovPdpb(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *BootstrapResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Header != nil {
		l = m.Header.Size()
		n += 1 + l + sovPdpb(uint64(l))
	}
	if m.ReplicationStatus != nil {
		l = m.ReplicationStatus.Size()
		n += 1 + l + sovPdpb(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *IsBootstrappedRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Header != nil {
		l = m.Header.Size()
		n += 1 + l + sovPdpb(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *IsBootstrappedResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Header != nil {
		l = m.Header.Size()
		n += 1 + l + sovPdpb(uint64(l))
	}
	if m.Bootstrapped {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *AllocIDRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Header != nil {
		l = m.Header.Size()
		n += 1 + l + sovPdpb(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *AllocIDResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Header != nil {
		l = m.Header.Size()
		n += 1 + l + sovPdpb(uint64(l))
	}
	if m.Id != 0 {
		n += 1 + sovPdpb(uint64(m.Id))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *IsSnapshotRecoveringRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Header != nil {
		l = m.Header.Size()
		n += 1 + l + sovPdpb(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *IsSnapshotRecoveringResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Header != nil {
		l = m.Header.Size()
		n += 1 + l + sovPdpb(uint64(l))
	}
	if m.Marked {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GetStoreRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Header != nil {
		l = m.Header.Size()
		n += 1 + l + sovPdpb(uint64(l))
	}
	if m.StoreId != 0 {
		n += 1 + sovPdpb(uint64(m.StoreId))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GetStoreResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Header != nil {
		l = m.Header.Size()
		n += 1 + l + sovPdpb(uint64(l))
	}
	if m.Store != nil {
		l = m.Store.Size()
		n += 1 + l + sovPdpb(uint64(l))
	}
	if m.Stats != nil {
		l = m.Stats.Size()
		n += 1 + l + sovPdpb(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *PutStoreRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Header != nil {
		l = m.Header.Size()
		n += 1 + l + sovPdpb(uint64(l))
	}
	if m.Store != nil {
		l = m.Store.Size()
		n += 1 + l + sovPdpb(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *PutStoreResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Header != nil {
		l = m.Header.Size()
		n += 1 + l + sovPdpb(uint64(l))
	}
	if m.ReplicationStatus != nil {
		l = m.ReplicationStatus.Size()
		n += 1 + l + sovPdpb(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GetAllStoresRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Header != nil {
		l = m.Header.Size()
		n += 1 + l + sovPdpb(uint64(l))
	}
	if m.ExcludeTombstoneStores {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GetAllStoresResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Header != nil {
		l = m.Header.Size()
		n += 1 + l + sovPdpb(uint64(l))
	}
	if len(m.Stores) > 0 {
		for _, e := range m.Stores {
			l = e.Size()
			n += 1 + l + sovPdpb(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GetRegionRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Header != nil {
		l = m.Header.Size()
		n += 1 + l + sovPdpb(uint64(l))
	}
	l = len(m.RegionKey)
	if l > 0 {
		n += 1 + l + sovPdpb(uint64(l))
	}
	if m.NeedBuckets {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GetRegionResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Header != nil {
		l = m.Header.Size()
		n += 1 + l + sovPdpb(uint64(l))
	}
	if m.Region != nil {
		l = m.Region.Size()
		n += 1 + l + sovPdpb(uint64(l))
	}
	if m.Leader != nil {
		l = m.Leader.Size()
		n += 1 + l + sovPdpb(uint64(l))
	}
	if len(m.DownPeers) > 0 {
		for _, e := range m.DownPeers {
			l = e.Size()
			n += 1 + l + sovPdpb(uint64(l))
		}
	}
	if len(m.PendingPeers) > 0 {
		for _, e := range m.PendingPeers {
			l = e.Size()
			n += 1 + l + sovPdpb(uint64(l))
		}
	}
	if m.Buckets != nil {
		l = m.Buckets.Size()
		n += 1 + l + sovPdpb(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GetRegionByIDRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Header != nil {
		l = m.Header.Size()
		n += 1 + l + sovPdpb(uint64(l))
	}
	if m.RegionId != 0 {
		n += 1 + sovPdpb(uint64(m.RegionId))
	}
	if m.NeedBuckets {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ScanRegionsRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Header != nil {
		l = m.Header.Size()
		n += 1 + l + sovPdpb(uint64(l))
	}
	l = len(m.StartKey)
	if l > 0 {
		n += 1 + l + sovPdpb(uint64(l))
	}
	if m.Limit != 0 {
		n += 1 + sovPdpb(uint64(m.Limit))
	}
	l = len(m.EndKey)
	if l > 0 {
		n += 1 + l + sovPdpb(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Region) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Region != nil {
		l = m.Region.Size()
		n += 1 + l + sovPdpb(uint64(l))
	}
	if m.Leader != nil {
		l = m.Leader.Size()
		n += 1 + l + sovPdpb(uint64(l))
	}
	if len(m.DownPeers) > 0 {
		for _, e := range m.DownPeers {
			l = e.Size()
			n += 1 + l + sovPdpb(uint64(l))
		}
	}
	if len(m.PendingPeers) > 0 {
		for _, e := range m.PendingPeers {
			l = e.Size()
			n += 1 + l + sovPdpb(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ScanRegionsResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Header != nil {
		l = m.Header.Size()
		n += 1 + l + sovPdpb(uint64(l))
	}
	if len(m.RegionMetas) > 0 {
		for _, e := range m.RegionMetas {
			l = e.Size()
			n += 1 + l + sovPdpb(uint64(l))
		}
	}
	if len(m.Leaders) > 0 {
		for _, e := range m.Leaders {
			l = e.Size()
			n += 1 + l + sovPdpb(uint64(l))
		}
	}
	if len(m.Regions) > 0 {
		for _, e := range m.Regions {
			l = e.Size()
			n += 1 + l + sovPdpb(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GetClusterConfigRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Header != nil {
		l = m.Header.Size()
		n += 1 + l + sovPdpb(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GetClusterConfigResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Header != nil {
		l = m.Header.Size()
		n += 1 + l + sovPdpb(uint64(l))
	}
	if m.Cluster != nil {
		l = m.Cluster.Size()
		n += 1 + l + sovPdpb(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *PutClusterConfigRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Header != nil {
		l = m.Header.Size()
		n += 1 + l + sovPdpb(uint64(l))
	}
	if m.Cluster != nil {
		l = m.Cluster.Size()
		n += 1 + l + sovPdpb(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *PutClusterConfigResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Header != nil {
		l = m.Header.Size()
		n += 1 + l + sovPdpb(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Member) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovPdpb(uint64(l))
	}
	if m.MemberId != 0 {
		n += 1 + sovPdpb(uint64(m.MemberId))
	}
	if len(m.PeerUrls) > 0 {
		for _, s := range m.PeerUrls {
			l = len(s)
			n += 1 + l + sovPdpb(uint64(l))
		}
	}
	if len(m.ClientUrls) > 0 {
		for _, s := range m.ClientUrls {
			l = len(s)
			n += 1 + l + sovPdpb(uint64(l))
		}
	}
	if m.LeaderPriority != 0 {
		n += 1 + sovPdpb(uint64(m.LeaderPriority))
	}
	l = len(m.DeployPath)
	if l > 0 {
		n += 1 + l + sovPdpb(uint64(l))
	}
	l = len(m.BinaryVersion)
	if l > 0 {
		n += 1 + l + sovPdpb(uint64(l))
	}
	l = len(m.GitHash)
	if l > 0 {
		n += 1 + l + sovPdpb(uint64(l))
	}
	l = len(m.DcLocation)
	if l > 0 {
		n += 1 + l + sovPdpb(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GetMembersRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Header != nil {
		l = m.Header.Size()
		n += 1 + l + sovPdpb(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GetMembersResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Header != nil {
		l = m.Header.Size()
		n += 1 + l + sovPdpb(uint64(l))
	}
	if len(m.Members) > 0 {
		for _, e := range m.Members {
			l = e.Size()
			n += 1 + l + sovPdpb(uint64(l))
		}
	}
	if m.Leader != nil {
		l = m.Leader.Size()
		n += 1 + l + sovPdpb(uint64(l))
	}
	if m.EtcdLeader != nil {
		l = m.EtcdLeader.Size()
		n += 1 + l + sovPdpb(uint64(l))
	}
	if len(m.TsoAllocatorLeaders) > 0 {
		for k, v := range m.TsoAllocatorLeaders {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovPdpb(uint64(l))
			}
			mapEntrySize := 1 + len(k) + sovPdpb(uint64(len(k))) + l
			n += mapEntrySize + 1 + sovPdpb(uint64(mapEntrySize))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GetClusterInfoRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Header != nil {
		l = m.Header.Size()
		n += 1 + l + sovPdpb(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GetClusterInfoResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Header != nil {
		l = m.Header.Size()
		n += 1 + l + sovPdpb(uint64(l))
	}
	if len(m.ServiceModes) > 0 {
		l = 0
		for _, e := range m.ServiceModes {
			l += sovPdpb(uint64(e))
		}
		n += 1 + sovPdpb(uint64(l)) + l
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *PeerStats) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Peer != nil {
		l = m.Peer.Size()
		n += 1 + l + sovPdpb(uint64(l))
	}
	if m.DownSeconds != 0 {
		n += 1 + sovPdpb(uint64(m.DownSeconds))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RegionHeartbeatRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Header != nil {
		l = m.Header.Size()
		n += 1 + l + sovPdpb(uint64(l))
	}
	if m.Region != nil {
		l = m.Region.Size()
		n += 1 + l + sovPdpb(uint64(l))
	}
	if m.Leader != nil {
		l = m.Leader.Size()
		n += 1 + l + sovPdpb(uint64(l))
	}
	if len(m.DownPeers) > 0 {
		for _, e := range m.DownPeers {
			l = e.Size()
			n += 1 + l + sovPdpb(uint64(l))
		}
	}
	if len(m.PendingPeers) > 0 {
		for _, e := range m.PendingPeers {
			l = e.Size()
			n += 1 + l + sovPdpb(uint64(l))
		}
	}
	if m.BytesWritten != 0 {
		n += 1 + sovPdpb(uint64(m.BytesWritten))
	}
	if m.BytesRead != 0 {
		n += 1 + sovPdpb(uint64(m.BytesRead))
	}
	if m.KeysWritten != 0 {
		n += 1 + sovPdpb(uint64(m.KeysWritten))
	}
	if m.KeysRead != 0 {
		n += 1 + sovPdpb(uint64(m.KeysRead))
	}
	if m.ApproximateSize != 0 {
		n += 1 + sovPdpb(uint64(m.ApproximateSize))
	}
	if m.Interval != nil {
		l = m.Interval.Size()
		n += 1 + l + sovPdpb(uint64(l))
	}
	if m.ApproximateKeys != 0 {
		n += 1 + sovPdpb(uint64(m.ApproximateKeys))
	}
	if m.Term != 0 {
		n += 1 + sovPdpb(uint64(m.Term))
	}
	if m.ReplicationStatus != nil {
		l = m.ReplicationStatus.Size()
		n += 1 + l + sovPdpb(uint64(l))
	}
	if m.QueryStats != nil {
		l = m.QueryStats.Size()
		n += 2 + l + sovPdpb(uint64(l))
	}
	if m.CpuUsage != 0 {
		n += 2 + sovPdpb(uint64(m.CpuUsage))
	}
	if m.ApproximateKvSize != 0 {
		n += 2 + sovPdpb(uint64(m.ApproximateKvSize))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ChangePeer) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Peer != nil {
		l = m.Peer.Size()
		n += 1 + l + sovPdpb(uint64(l))
	}
	if m.ChangeType != 0 {
		n += 1 + sovPdpb(uint64(m.ChangeType))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ChangePeerV2) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Changes) > 0 {
		for _, e := range m.Changes {
			l = e.Size()
			n += 1 + l + sovPdpb(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TransferLeader) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Peer != nil {
		l = m.Peer.Size()
		n += 1 + l + sovPdpb(uint64(l))
	}
	if len(m.Peers) > 0 {
		for _, e := range m.Peers {
			l = e.Size()
			n += 1 + l + sovPdpb(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Merge) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Target != nil {
		l = m.Target.Size()
		n += 1 + l + sovPdpb(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SplitRegion) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Policy != 0 {
		n += 1 + sovPdpb(uint64(m.Policy))
	}
	if len(m.Keys) > 0 {
		for _, b := range m.Keys {
			l = len(b)
			n += 1 + l + sovPdpb(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SwitchWitness) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PeerId != 0 {
		n += 1 + sovPdpb(uint64(m.PeerId))
	}
	if m.IsWitness {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *BatchSwitchWitness) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.SwitchWitnesses) > 0 {
		for _, e := range m.SwitchWitnesses {
			l = e.Size()
			n += 1 + l + sovPdpb(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RegionHeartbeatResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Header != nil {
		l = m.Header.Size()
		n += 1 + l + sovPdpb(uint64(l))
	}
	if m.ChangePeer != nil {
		l = m.ChangePeer.Size()
		n += 1 + l + sovPdpb(uint64(l))
	}
	if m.TransferLeader != nil {
		l = m.TransferLeader.Size()
		n += 1 + l + sovPdpb(uint64(l))
	}
	if m.RegionId != 0 {
		n += 1 + sovPdpb(uint64(m.RegionId))
	}
	if m.RegionEpoch != nil {
		l = m.RegionEpoch.Size()
		n += 1 + l + sovPdpb(uint64(l))
	}
	if m.TargetPeer != nil {
		l = m.TargetPeer.Size()
		n += 1 + l + sovPdpb(uint64(l))
	}
	if m.Merge != nil {
		l = m.Merge.Size()
		n += 1 + l + sovPdpb(uint64(l))
	}
	if m.SplitRegion != nil {
		l = m.SplitRegion.Size()
		n += 1 + l + sovPdpb(uint64(l))
	}
	if m.ChangePeerV2 != nil {
		l = m.ChangePeerV2.Size()
		n += 1 + l + sovPdpb(uint64(l))
	}
	if m.SwitchWitnesses != nil {
		l = m.SwitchWitnesses.Size()
		n += 1 + l + sovPdpb(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *AskSplitRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Header != nil {
		l = m.Header.Size()
		n += 1 + l + sovPdpb(uint64(l))
	}
	if m.Region != nil {
		l = m.Region.Size()
		n += 1 + l + sovPdpb(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *AskSplitResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Header != nil {
		l = m.Header.Size()
		n += 1 + l + sovPdpb(uint64(l))
	}
	if m.NewRegionId != 0 {
		n += 1 + sovPdpb(uint64(m.NewRegionId))
	}
	if len(m.NewPeerIds) > 0 {
		l = 0
		for _, e := range m.NewPeerIds {
			l += sovPdpb(uint64(e))
		}
		n += 1 + sovPdpb(uint64(l)) + l
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ReportSplitRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Header != nil {
		l = m.Header.Size()
		n += 1 + l + sovPdpb(uint64(l))
	}
	if m.Left != nil {
		l = m.Left.Size()
		n += 1 + l + sovPdpb(uint64(l))
	}
	if m.Right != nil {
		l = m.Right.Size()
		n += 1 + l + sovPdpb(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ReportSplitResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Header != nil {
		l = m.Header.Size()
		n += 1 + l + sovPdpb(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *AskBatchSplitRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Header != nil {
		l = m.Header.Size()
		n += 1 + l + sovPdpb(uint64(l))
	}
	if m.Region != nil {
		l = m.Region.Size()
		n += 1 + l + sovPdpb(uint64(l))
	}
	if m.SplitCount != 0 {
		n += 1 + sovPdpb(uint64(m.SplitCount))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SplitID) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.NewRegionId != 0 {
		n += 1 + sovPdpb(uint64(m.NewRegionId))
	}
	if len(m.NewPeerIds) > 0 {
		l = 0
		for _, e := range m.NewPeerIds {
			l += sovPdpb(uint64(e))
		}
		n += 1 + sovPdpb(uint64(l)) + l
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *AskBatchSplitResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Header != nil {
		l = m.Header.Size()
		n += 1 + l + sovPdpb(uint64(l))
	}
	if len(m.Ids) > 0 {
		for _, e := range m.Ids {
			l = e.Size()
			n += 1 + l + sovPdpb(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ReportBatchSplitRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Header != nil {
		l = m.Header.Size()
		n += 1 + l + sovPdpb(uint64(l))
	}
	if len(m.Regions) > 0 {
		for _, e := range m.Regions {
			l = e.Size()
			n += 1 + l + sovPdpb(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ReportBatchSplitResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Header != nil {
		l = m.Header.Size()
		n += 1 + l + sovPdpb(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TimeInterval) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.StartTimestamp != 0 {
		n += 1 + sovPdpb(uint64(m.StartTimestamp))
	}
	if m.EndTimestamp != 0 {
		n += 1 + sovPdpb(uint64(m.EndTimestamp))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RecordPair) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Key)
	if l > 0 {
		n += 1 + l + sovPdpb(uint64(l))
	}
	if m.Value != 0 {
		n += 1 + sovPdpb(uint64(m.Value))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *PeerStat) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.RegionId != 0 {
		n += 1 + sovPdpb(uint64(m.RegionId))
	}
	if m.ReadKeys != 0 {
		n += 1 + sovPdpb(uint64(m.ReadKeys))
	}
	if m.ReadBytes != 0 {
		n += 1 + sovPdpb(uint64(m.ReadBytes))
	}
	if m.QueryStats != nil {
		l = m.QueryStats.Size()
		n += 1 + l + sovPdpb(uint64(l))
	}
	if m.WrittenKeys != 0 {
		n += 1 + sovPdpb(uint64(m.WrittenKeys))
	}
	if m.WrittenBytes != 0 {
		n += 1 + sovPdpb(uint64(m.WrittenBytes))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *StoreStats) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.StoreId != 0 {
		n += 1 + sovPdpb(uint64(m.StoreId))
	}
	if m.Capacity != 0 {
		n += 1 + sovPdpb(uint64(m.Capacity))
	}
	if m.Available != 0 {
		n += 1 + sovPdpb(uint64(m.Available))
	}
	if m.RegionCount != 0 {
		n += 1 + sovPdpb(uint64(m.RegionCount))
	}
	if m.SendingSnapCount != 0 {
		n += 1 + sovPdpb(uint64(m.SendingSnapCount))
	}
	if m.ReceivingSnapCount != 0 {
		n += 1 + sovPdpb(uint64(m.ReceivingSnapCount))
	}
	if m.StartTime != 0 {
		n += 1 + sovPdpb(uint64(m.StartTime))
	}
	if m.ApplyingSnapCount != 0 {
		n += 1 + sovPdpb(uint64(m.ApplyingSnapCount))
	}
	if m.IsBusy {
		n += 2
	}
	if m.UsedSize != 0 {
		n += 1 + sovPdpb(uint64(m.UsedSize))
	}
	if m.BytesWritten != 0 {
		n += 1 + sovPdpb(uint64(m.BytesWritten))
	}
	if m.KeysWritten != 0 {
		n += 1 + sovPdpb(uint64(m.KeysWritten))
	}
	if m.BytesRead != 0 {
		n += 1 + sovPdpb(uint64(m.BytesRead))
	}
	if m.KeysRead != 0 {
		n += 1 + sovPdpb(uint64(m.KeysRead))
	}
	if m.Interval != nil {
		l = m.Interval.Size()
		n += 1 + l + sovPdpb(uint64(l))
	}
	if len(m.CpuUsages) > 0 {
		for _, e := range m.CpuUsages {
			l = e.Size()
			n += 2 + l + sovPdpb(uint64(l))
		}
	}
	if len(m.ReadIoRates) > 0 {
		for _, e := range m.ReadIoRates {
			l = e.Size()
			n += 2 + l + sovPdpb(uint64(l))
		}
	}
	if len(m.WriteIoRates) > 0 {
		for _, e := range m.WriteIoRates {
			l = e.Size()
			n += 2 + l + sovPdpb(uint64(l))
		}
	}
	if len(m.OpLatencies) > 0 {
		for _, e := range m.OpLatencies {
			l = e.Size()
			n += 2 + l + sovPdpb(uint64(l))
		}
	}
	if len(m.PeerStats) > 0 {
		for _, e := range m.PeerStats {
			l = e.Size()
			n += 2 + l + sovPdpb(uint64(l))
		}
	}
	if m.QueryStats != nil {
		l = m.QueryStats.Size()
		n += 2 + l + sovPdpb(uint64(l))
	}
	if m.SlowScore != 0 {
		n += 2 + sovPdpb(uint64(m.SlowScore))
	}
	if len(m.DamagedRegionsId) > 0 {
		l = 0
		for _, e := range m.DamagedRegionsId {
			l += sovPdpb(uint64(e))
		}
		n += 2 + sovPdpb(uint64(l)) + l
	}
	if m.IsApplyBusy {
		n += 3
	}
	if len(m.SnapshotStats) > 0 {
		for _, e := range m.SnapshotStats {
			l = e.Size()
			n += 2 + l + sovPdpb(uint64(l))
		}
	}
	if m.SlowTrend != nil {
		l = m.SlowTrend.Size()
		n += 2 + l + sovPdpb(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SlowTrend) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CauseValue != 0 {
		n += 9
	}
	if m.CauseRate != 0 {
		n += 9
	}
	if m.ResultValue != 0 {
		n += 9
	}
	if m.ResultRate != 0 {
		n += 9
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SnapshotStat) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.RegionId != 0 {
		n += 1 + sovPdpb(uint64(m.RegionId))
	}
	if m.GenerateDurationSec != 0 {
		n += 1 + sovPdpb(uint64(m.GenerateDurationSec))
	}
	if m.SendDurationSec != 0 {
		n += 1 + sovPdpb(uint64(m.SendDurationSec))
	}
	if m.TotalDurationSec != 0 {
		n += 1 + sovPdpb(uint64(m.TotalDurationSec))
	}
	if m.TransportSize != 0 {
		n += 1 + sovPdpb(uint64(m.TransportSize))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *PeerReport) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.RaftState != nil {
		l = m.RaftState.Size()
		n += 1 + l + sovPdpb(uint64(l))
	}
	if m.RegionState != nil {
		l = m.RegionState.Size()
		n += 1 + l + sovPdpb(uint64(l))
	}
	if m.IsForceLeader {
		n += 2
	}
	if m.HasCommitMerge {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *StoreReport) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.PeerReports) > 0 {
		for _, e := range m.PeerReports {
			l = e.Size()
			n += 1 + l + sovPdpb(uint64(l))
		}
	}
	if m.Step != 0 {
		n += 1 + sovPdpb(uint64(m.Step))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *StoreHeartbeatRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Header != nil {
		l = m.Header.Size()
		n += 1 + l + sovPdpb(uint64(l))
	}
	if m.Stats != nil {
		l = m.Stats.Size()
		n += 1 + l + sovPdpb(uint64(l))
	}
	if m.StoreReport != nil {
		l = m.StoreReport.Size()
		n += 1 + l + sovPdpb(uint64(l))
	}
	if m.DrAutosyncStatus != nil {
		l = m.DrAutosyncStatus.Size()
		n += 1 + l + sovPdpb(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DemoteFailedVoters) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.RegionId != 0 {
		n += 1 + sovPdpb(uint64(m.RegionId))
	}
	if len(m.FailedVoters) > 0 {
		for _, e := range m.FailedVoters {
			l = e.Size()
			n += 1 + l + sovPdpb(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ForceLeader) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.FailedStores) > 0 {
		l = 0
		for _, e := range m.FailedStores {
			l += sovPdpb(uint64(e))
		}
		n += 1 + sovPdpb(uint64(l)) + l
	}
	if len(m.EnterForceLeaders) > 0 {
		l = 0
		for _, e := range m.EnterForceLeaders {
			l += sovPdpb(uint64(e))
		}
		n += 1 + sovPdpb(uint64(l)) + l
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RecoveryPlan) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Creates) > 0 {
		for _, e := range m.Creates {
			l = e.Size()
			n += 1 + l + sovPdpb(uint64(l))
		}
	}
	if len(m.Updates) > 0 {
		for _, e := range m.Updates {
			l = e.Size()
			n += 1 + l + sovPdpb(uint64(l))
		}
	}
	if len(m.Tombstones) > 0 {
		l = 0
		for _, e := range m.Tombstones {
			l += sovPdpb(uint64(e))
		}
		n += 1 + sovPdpb(uint64(l)) + l
	}
	if len(m.Demotes) > 0 {
		for _, e := range m.Demotes {
			l = e.Size()
			n += 1 + l + sovPdpb(uint64(l))
		}
	}
	if m.ForceLeader != nil {
		l = m.ForceLeader.Size()
		n += 1 + l + sovPdpb(uint64(l))
	}
	if m.Step != 0 {
		n += 1 + sovPdpb(uint64(m.Step))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *AwakenRegions) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.AbnormalStores) > 0 {
		l = 0
		for _, e := range m.AbnormalStores {
			l += sovPdpb(uint64(e))
		}
		n += 1 + sovPdpb(uint64(l)) + l
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *StoreHeartbeatResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Header != nil {
		l = m.Header.Size()
		n += 1 + l + sovPdpb(uint64(l))
	}
	if m.ReplicationStatus != nil {
		l = m.ReplicationStatus.Size()
		n += 1 + l + sovPdpb(uint64(l))
	}
	l = len(m.ClusterVersion)
	if l > 0 {
		n += 1 + l + sovPdpb(uint64(l))
	}
	if m.RequireDetailedReport {
		n += 2
	}
	if m.RecoveryPlan != nil {
		l = m.RecoveryPlan.Size()
		n += 1 + l + sovPdpb(uint64(l))
	}
	if m.AwakenRegions != nil {
		l = m.AwakenRegions.Size()
		n += 1 + l + sovPdpb(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ScatterRegionRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Header != nil {
		l = m.Header.Size()
		n += 1 + l + sovPdpb(uint64(l))
	}
	if m.RegionId != 0 {
		n += 1 + sovPdpb(uint64(m.RegionId))
	}
	if m.Region != nil {
		l = m.Region.Size()
		n += 1 + l + sovPdpb(uint64(l))
	}
	if m.Leader != nil {
		l = m.Leader.Size()
		n += 1 + l + sovPdpb(uint64(l))
	}
	l = len(m.Group)
	if l > 0 {
		n += 1 + l + sovPdpb(uint64(l))
	}
	if len(m.RegionsId) > 0 {
		l = 0
		for _, e := range m.RegionsId {
			l += sovPdpb(uint64(e))
		}
		n += 1 + sovPdpb(uint64(l)) + l
	}
	if m.RetryLimit != 0 {
		n += 1 + sovPdpb(uint64(m.RetryLimit))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ScatterRegionResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Header != nil {
		l = m.Header.Size()
		n += 1 + l + sovPdpb(uint64(l))
	}
	if m.FinishedPercentage != 0 {
		n += 1 + sovPdpb(uint64(m.FinishedPercentage))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GetGCSafePointRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Header != nil {
		l = m.Header.Size()
		n += 1 + l + sovPdpb(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GetGCSafePointResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Header != nil {
		l = m.Header.Size()
		n += 1 + l + sovPdpb(uint64(l))
	}
	if m.SafePoint != 0 {
		n += 1 + sovPdpb(uint64(m.SafePoint))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *UpdateGCSafePointRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Header != nil {
		l = m.Header.Size()
		n += 1 + l + sovPdpb(uint64(l))
	}
	if m.SafePoint != 0 {
		n += 1 + sovPdpb(uint64(m.SafePoint))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *UpdateGCSafePointResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Header != nil {
		l = m.Header.Size()
		n += 1 + l + sovPdpb(uint64(l))
	}
	if m.NewSafePoint != 0 {
		n += 1 + sovPdpb(uint64(m.NewSafePoint))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *UpdateServiceGCSafePointRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Header != nil {
		l = m.Header.Size()
		n += 1 + l + sovPdpb(uint64(l))
	}
	l = len(m.ServiceId)
	if l > 0 {
		n += 1 + l + sovPdpb(uint64(l))
	}
	if m.TTL != 0 {
		n += 1 + sovPdpb(uint64(m.TTL))
	}
	if m.SafePoint != 0 {
		n += 1 + sovPdpb(uint64(m.SafePoint))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *UpdateServiceGCSafePointResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Header != nil {
		l = m.Header.Size()
		n += 1 + l + sovPdpb(uint64(l))
	}
	l = len(m.ServiceId)
	if l > 0 {
		n += 1 + l + sovPdpb(uint64(l))
	}
	if m.TTL != 0 {
		n += 1 + sovPdpb(uint64(m.TTL))
	}
	if m.MinSafePoint != 0 {
		n += 1 + sovPdpb(uint64(m.MinSafePoint))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RegionStat) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.BytesWritten != 0 {
		n += 1 + sovPdpb(uint64(m.BytesWritten))
	}
	if m.BytesRead != 0 {
		n += 1 + sovPdpb(uint64(m.BytesRead))
	}
	if m.KeysWritten != 0 {
		n += 1 + sovPdpb(uint64(m.KeysWritten))
	}
	if m.KeysRead != 0 {
		n += 1 + sovPdpb(uint64(m.KeysRead))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SyncRegionRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Header != nil {
		l = m.Header.Size()
		n += 1 + l + sovPdpb(uint64(l))
	}
	if m.Member != nil {
		l = m.Member.Size()
		n += 1 + l + sovPdpb(uint64(l))
	}
	if m.StartIndex != 0 {
		n += 1 + sovPdpb(uint64(m.StartIndex))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SyncRegionResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Header != nil {
		l = m.Header.Size()
		n += 1 + l + sovPdpb(uint64(l))
	}
	if len(m.Regions) > 0 {
		for _, e := range m.Regions {
			l = e.Size()
			n += 1 + l + sovPdpb(uint64(l))
		}
	}
	if m.StartIndex != 0 {
		n += 1 + sovPdpb(uint64(m.StartIndex))
	}
	if len(m.RegionStats) > 0 {
		for _, e := range m.RegionStats {
			l = e.Size()
			n += 1 + l + sovPdpb(uint64(l))
		}
	}
	if len(m.RegionLeaders) > 0 {
		for _, e := range m.RegionLeaders {
			l = e.Size()
			n += 1 + l + sovPdpb(uint64(l))
		}
	}
	if len(m.Buckets) > 0 {
		for _, e := range m.Buckets {
			l = e.Size()
			n += 1 + l + sovPdpb(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GetOperatorRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Header != nil {
		l = m.Header.Size()
		n += 1 + l + sovPdpb(uint64(l))
	}
	if m.RegionId != 0 {
		n += 1 + sovPdpb(uint64(m.RegionId))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GetOperatorResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Header != nil {
		l = m.Header.Size()
		n += 1 + l + sovPdpb(uint64(l))
	}
	if m.RegionId != 0 {
		n += 1 + sovPdpb(uint64(m.RegionId))
	}
	l = len(m.Desc)
	if l > 0 {
		n += 1 + l + sovPdpb(uint64(l))
	}
	if m.Status != 0 {
		n += 1 + sovPdpb(uint64(m.Status))
	}
	l = len(m.Kind)
	if l > 0 {
		n += 1 + l + sovPdpb(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SyncMaxTSRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Header != nil {
		l = m.Header.Size()
		n += 1 + l + sovPdpb(uint64(l))
	}
	if m.MaxTs != nil {
		l = m.MaxTs.Size()
		n += 1 + l + sovPdpb(uint64(l))
	}
	if m.SkipCheck {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SyncMaxTSResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Header != nil {
		l = m.Header.Size()
		n += 1 + l + sovPdpb(uint64(l))
	}
	if m.MaxLocalTs != nil {
		l = m.MaxLocalTs.Size()
		n += 1 + l + sovPdpb(uint64(l))
	}
	if len(m.SyncedDcs) > 0 {
		for _, s := range m.SyncedDcs {
			l = len(s)
			n += 1 + l + sovPdpb(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SplitRegionsRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Header != nil {
		l = m.Header.Size()
		n += 1 + l + sovPdpb(uint64(l))
	}
	if len(m.SplitKeys) > 0 {
		for _, b := range m.SplitKeys {
			l = len(b)
			n += 1 + l + sovPdpb(uint64(l))
		}
	}
	if m.RetryLimit != 0 {
		n += 1 + sovPdpb(uint64(m.RetryLimit))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SplitRegionsResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Header != nil {
		l = m.Header.Size()
		n += 1 + l + sovPdpb(uint64(l))
	}
	if m.FinishedPercentage != 0 {
		n += 1 + sovPdpb(uint64(m.FinishedPercentage))
	}
	if len(m.RegionsId) > 0 {
		l = 0
		for _, e := range m.RegionsId {
			l += sovPdpb(uint64(e))
		}
		n += 1 + sovPdpb(uint64(l)) + l
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SplitAndScatterRegionsRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Header != nil {
		l = m.Header.Size()
		n += 1 + l + sovPdpb(uint64(l))
	}
	if len(m.SplitKeys) > 0 {
		for _, b := range m.SplitKeys {
			l = len(b)
			n += 1 + l + sovPdpb(uint64(l))
		}
	}
	l = len(m.Group)
	if l > 0 {
		n += 1 + l + sovPdpb(uint64(l))
	}
	if m.RetryLimit != 0 {
		n += 1 + sovPdpb(uint64(m.RetryLimit))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SplitAndScatterRegionsResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Header != nil {
		l = m.Header.Size()
		n += 1 + l + sovPdpb(uint64(l))
	}
	if m.SplitFinishedPercentage != 0 {
		n += 1 + sovPdpb(uint64(m.SplitFinishedPercentage))
	}
	if m.ScatterFinishedPercentage != 0 {
		n += 1 + sovPdpb(uint64(m.ScatterFinishedPercentage))
	}
	if len(m.RegionsId) > 0 {
		l = 0
		for _, e := range m.RegionsId {
			l += sovPdpb(uint64(e))
		}
		n += 1 + sovPdpb(uint64(l)) + l
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GetDCLocationInfoRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Header != nil {
		l = m.Header.Size()
		n += 1 + l + sovPdpb(uint64(l))
	}
	l = len(m.DcLocation)
	if l > 0 {
		n += 1 + l + sovPdpb(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GetDCLocationInfoResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Header != nil {
		l = m.Header.Size()
		n += 1 + l + sovPdpb(uint64(l))
	}
	if m.Suffix != 0 {
		n += 1 + sovPdpb(uint64(m.Suffix))
	}
	if m.MaxTs != nil {
		l = m.MaxTs.Size()
		n += 1 + l + sovPdpb(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *QueryStats) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.GC != 0 {
		n += 1 + sovPdpb(uint64(m.GC))
	}
	if m.Get != 0 {
		n += 1 + sovPdpb(uint64(m.Get))
	}
	if m.Scan != 0 {
		n += 1 + sovPdpb(uint64(m.Scan))
	}
	if m.Coprocessor != 0 {
		n += 1 + sovPdpb(uint64(m.Coprocessor))
	}
	if m.Delete != 0 {
		n += 1 + sovPdpb(uint64(m.Delete))
	}
	if m.DeleteRange != 0 {
		n += 1 + sovPdpb(uint64(m.DeleteRange))
	}
	if m.Put != 0 {
		n += 1 + sovPdpb(uint64(m.Put))
	}
	if m.Prewrite != 0 {
		n += 1 + sovPdpb(uint64(m.Prewrite))
	}
	if m.AcquirePessimisticLock != 0 {
		n += 1 + sovPdpb(uint64(m.AcquirePessimisticLock))
	}
	if m.Commit != 0 {
		n += 1 + sovPdpb(uint64(m.Commit))
	}
	if m.Rollback != 0 {
		n += 1 + sovPdpb(uint64(m.Rollback))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ReportBucketsRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Header != nil {
		l = m.Header.Size()
		n += 1 + l + sovPdpb(uint64(l))
	}
	if m.RegionEpoch != nil {
		l = m.RegionEpoch.Size()
		n += 1 + l + sovPdpb(uint64(l))
	}
	if m.Buckets != nil {
		l = m.Buckets.Size()
		n += 1 + l + sovPdpb(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ReportBucketsResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Header != nil {
		l = m.Header.Size()
		n += 1 + l + sovPdpb(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ReportMinResolvedTsRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Header != nil {
		l = m.Header.Size()
		n += 1 + l + sovPdpb(uint64(l))
	}
	if m.StoreId != 0 {
		n += 1 + sovPdpb(uint64(m.StoreId))
	}
	if m.MinResolvedTs != 0 {
		n += 1 + sovPdpb(uint64(m.MinResolvedTs))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ReportMinResolvedTsResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Header != nil {
		l = m.Header.Size()
		n += 1 + l + sovPdpb(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SetExternalTimestampRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Header != nil {
		l = m.Header.Size()
		n += 1 + l + sovPdpb(uint64(l))
	}
	if m.Timestamp != 0 {
		n += 1 + sovPdpb(uint64(m.Timestamp))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SetExternalTimestampResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Header != nil {
		l = m.Header.Size()
		n += 1 + l + sovPdpb(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GetExternalTimestampRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Header != nil {
		l = m.Header.Size()
		n += 1 + l + sovPdpb(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GetExternalTimestampResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Header != nil {
		l = m.Header.Size()
		n += 1 + l + sovPdpb(uint64(l))
	}
	if m.Timestamp != 0 {
		n += 1 + sovPdpb(uint64(m.Timestamp))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovPdpb(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozPdpb(x uint64) (n int) {
	return sovPdpb(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *WatchGlobalConfigRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPdpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: WatchGlobalConfigRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: WatchGlobalConfigRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConfigPath", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPdpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPdpb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPdpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ConfigPath = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Revision", wireType)
			}
			m.Revision = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPdpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Revision |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPdpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPdpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WatchGlobalConfigResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPdpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: WatchGlobalConfigResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: WatchGlobalConfigResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Changes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPdpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPdpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPdpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Changes = append(m.Changes, &GlobalConfigItem{})
			if err := m.Changes[len(m.Changes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Revision", wireType)
			}
			m.Revision = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPdpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Revision |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Header", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPdpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPdpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPdpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Header == nil {
				m.Header = &ResponseHeader{}
			}
			if err := m.Header.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPdpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPdpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StoreGlobalConfigRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPdpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StoreGlobalConfigRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StoreGlobalConfigRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Changes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPdpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPdpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPdpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Changes = append(m.Changes, &GlobalConfigItem{})
			if err := m.Changes[len(m.Changes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConfigPath", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPdpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPdpb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPdpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ConfigPath = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPdpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPdpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StoreGlobalConfigResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPdpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StoreGlobalConfigResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StoreGlobalConfigResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Error", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPdpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPdpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPdpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Error == nil {
				m.Error = &Error{}
			}
			if err := m.Error.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPdpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPdpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LoadGlobalConfigRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPdpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LoadGlobalConfigRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LoadGlobalConfigRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Names", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPdpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPdpb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPdpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Names = append(m.Names, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConfigPath", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPdpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPdpb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPdpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ConfigPath = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPdpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPdpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LoadGlobalConfigResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPdpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LoadGlobalConfigResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LoadGlobalConfigResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Items", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPdpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPdpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPdpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Items = append(m.Items, &GlobalConfigItem{})
			if err := m.Items[len(m.Items)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Revision", wireType)
			}
			m.Revision = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPdpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Revision |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPdpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPdpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GlobalConfigItem) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPdpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GlobalConfigItem: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GlobalConfigItem: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPdpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPdpb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPdpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPdpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPdpb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPdpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Value = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Error", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPdpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPdpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPdpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Error == nil {
				m.Error = &Error{}
			}
			if err := m.Error.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Kind", wireType)
			}
			m.Kind = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPdpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Kind |= EventType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Payload", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPdpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthPdpb
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthPdpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Payload = append(m.Payload[:0], dAtA[iNdEx:postIndex]...)
			if m.Payload == nil {
				m.Payload = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPdpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPdpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RequestHeader) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPdpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RequestHeader: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RequestHeader: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClusterId", wireType)
			}
			m.ClusterId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPdpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ClusterId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SenderId", wireType)
			}
			m.SenderId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPdpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SenderId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPdpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPdpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ResponseHeader) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPdpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ResponseHeader: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ResponseHeader: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClusterId", wireType)
			}
			m.ClusterId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPdpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ClusterId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Error", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPdpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPdpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPdpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Error == nil {
				m.Error = &Error{}
			}
			if err := m.Error.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPdpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPdpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Error) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPdpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Error: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Error: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPdpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= ErrorType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPdpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPdpb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPdpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Message = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPdpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPdpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TsoRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPdpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TsoRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TsoRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Header", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPdpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPdpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPdpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Header == nil {
				m.Header = &RequestHeader{}
			}
			if err := m.Header.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Count", wireType)
			}
			m.Count = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPdpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Count |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DcLocation", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPdpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPdpb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPdpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DcLocation = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPdpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPdpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TaasRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPdpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TaasRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TaasRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Header", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPdpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPdpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPdpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Header == nil {
				m.Header = &RequestHeader{}
			}
			if err := m.Header.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Stamp", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPdpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Stamp = bool(v != 0)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Count", wireType)
			}
			m.Count = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPdpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Count |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DcLocation", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPdpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPdpb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPdpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DcLocation = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPdpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPdpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Timestamp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPdpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Timestamp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Timestamp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Physical", wireType)
			}
			m.Physical = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPdpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Physical |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Logical", wireType)
			}
			m.Logical = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPdpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Logical |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SuffixBits", wireType)
			}
			m.SuffixBits = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPdpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SuffixBits |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPdpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPdpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TsoResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPdpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TsoResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TsoResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Header", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPdpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPdpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPdpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Header == nil {
				m.Header = &ResponseHeader{}
			}
			if err := m.Header.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Count", wireType)
			}
			m.Count = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPdpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Count |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPdpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPdpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPdpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Timestamp == nil {
				m.Timestamp = &Timestamp{}
			}
			if err := m.Timestamp.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPdpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPdpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BootstrapRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPdpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BootstrapRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BootstrapRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Header", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPdpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPdpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPdpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Header == nil {
				m.Header = &RequestHeader{}
			}
			if err := m.Header.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Store", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPdpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPdpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPdpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Store == nil {
				m.Store = &metapb.Store{}
			}
			if err := m.Store.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Region", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPdpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPdpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPdpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Region == nil {
				m.Region = &metapb.Region{}
			}
			if err := m.Region.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPdpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPdpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BootstrapResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPdpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BootstrapResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BootstrapResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Header", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPdpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPdpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPdpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Header == nil {
				m.Header = &ResponseHeader{}
			}
			if err := m.Header.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReplicationStatus", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPdpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPdpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPdpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ReplicationStatus == nil {
				m.ReplicationStatus = &replication_modepb.ReplicationStatus{}
			}
			if err := m.ReplicationStatus.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPdpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPdpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *IsBootstrappedRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPdpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: IsBootstrappedRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: IsBootstrappedRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Header", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPdpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPdpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPdpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Header == nil {
				m.Header = &RequestHeader{}
			}
			if err := m.Header.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPdpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPdpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *IsBootstrappedResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPdpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: IsBootstrappedResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: IsBootstrappedResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Header", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPdpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPdpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPdpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Header == nil {
				m.Header = &ResponseHeader{}
			}
			if err := m.Header.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Bootstrapped", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPdpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Bootstrapped = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipPdpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPdpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AllocIDRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPdpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AllocIDRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AllocIDRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Header", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPdpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPdpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPdpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Header == nil {
				m.Header = &RequestHeader{}
			}
			if err := m.Header.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPdpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPdpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AllocIDResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPdpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AllocIDResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AllocIDResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Header", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPdpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPdpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPdpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Header == nil {
				m.Header = &ResponseHeader{}
			}
			if err := m.Header.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPdpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPdpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPdpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *IsSnapshotRecoveringRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPdpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: IsSnapshotRecoveringRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: IsSnapshotRecoveringRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Header", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPdpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPdpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPdpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Header == nil {
				m.Header = &RequestHeader{}
			}
			if err := m.Header.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPdpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPdpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *IsSnapshotRecoveringResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPdpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: IsSnapshotRecoveringResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: IsSnapshotRecoveringResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Header", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPdpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPdpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPdpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Header == nil {
				m.Header = &ResponseHeader{}
			}
			if err := m.Header.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Marked", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPdpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Marked = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipPdpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPdpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetStoreRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPdpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetStoreRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetStoreRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Header", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPdpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPdpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPdpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Header == nil {
				m.Header = &RequestHeader{}
			}
			if err := m.Header.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StoreId", wireType)
			}
			m.StoreId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPdpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StoreId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPdpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPdpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetStoreResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPdpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetStoreResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetStoreResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Header", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPdpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPdpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPdpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Header == nil {
				m.Header = &ResponseHeader{}
			}
			if err := m.Header.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Store", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPdpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPdpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPdpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Store == nil {
				m.Store = &metapb.Store{}
			}
			if err := m.Store.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Stats", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPdpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPdpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPdpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Stats == nil {
				m.Stats = &StoreStats{}
			}
			if err := m.Stats.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPdpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPdpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PutStoreRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPdpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PutStoreRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PutStoreRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Header", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPdpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPdpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPdpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Header == nil {
				m.Header = &RequestHeader{}
			}
			if err := m.Header.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Store", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPdpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPdpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPdpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Store == nil {
				m.Store = &metapb.Store{}
			}
			if err := m.Store.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPdpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPdpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PutStoreResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPdpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PutStoreResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PutStoreResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Header", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPdpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPdpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPdpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Header == nil {
				m.Header = &ResponseHeader{}
			}
			if err := m.Header.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReplicationStatus", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPdpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPdpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPdpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ReplicationStatus == nil {
				m.ReplicationStatus = &replication_modepb.ReplicationStatus{}
			}
			if err := m.ReplicationStatus.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPdpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPdpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetAllStoresRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPdpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetAllStoresRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetAllStoresRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Header", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPdpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPdpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPdpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Header == nil {
				m.Header = &RequestHeader{}
			}
			if err := m.Header.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExcludeTombstoneStores", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPdpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ExcludeTombstoneStores = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipPdpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPdpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetAllStoresResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPdpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetAllStoresResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetAllStoresResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Header", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPdpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPdpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPdpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Header == nil {
				m.Header = &ResponseHeader{}
			}
			if err := m.Header.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Stores", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPdpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPdpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPdpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Stores = append(m.Stores, &metapb.Store{})
			if err := m.Stores[len(m.Stores)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPdpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPdpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetRegionRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPdpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetRegionRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetRegionRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Header", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPdpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPdpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPdpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Header == nil {
				m.Header = &RequestHeader{}
			}
			if err := m.Header.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RegionKey", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPdpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthPdpb
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthPdpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RegionKey = append(m.RegionKey[:0], dAtA[iNdEx:postIndex]...)
			if m.RegionKey == nil {
				m.RegionKey = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NeedBuckets", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPdpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.NeedBuckets = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipPdpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPdpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetRegionResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPdpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetRegionResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetRegionResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Header", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPdpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPdpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPdpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Header == nil {
				m.Header = &ResponseHeader{}
			}
			if err := m.Header.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Region", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPdpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPdpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPdpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Region == nil {
				m.Region = &metapb.Region{}
			}
			if err := m.Region.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Leader", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPdpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPdpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPdpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Leader == nil {
				m.Leader = &metapb.Peer{}
			}
			if err := m.Leader.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DownPeers", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPdpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPdpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPdpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DownPeers = append(m.DownPeers, &PeerStats{})
			if err := m.DownPeers[len(m.DownPeers)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PendingPeers", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPdpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPdpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPdpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PendingPeers = append(m.PendingPeers, &metapb.Peer{})
			if err := m.PendingPeers[len(m.PendingPeers)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Buckets", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPdpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPdpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPdpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Buckets == nil {
				m.Buckets = &metapb.Buckets{}
			}
			if err := m.Buckets.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPdpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPdpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetRegionByIDRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPdpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetRegionByIDRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetRegionByIDRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Header", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPdpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPdpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPdpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Header == nil {
				m.Header = &RequestHeader{}
			}
			if err := m.Header.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RegionId", wireType)
			}
			m.RegionId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPdpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RegionId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NeedBuckets", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPdpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.NeedBuckets = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipPdpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPdpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ScanRegionsRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPdpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ScanRegionsRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ScanRegionsRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Header", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPdpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPdpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPdpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Header == nil {
				m.Header = &RequestHeader{}
			}
			if err := m.Header.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartKey", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPdpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthPdpb
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthPdpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StartKey = append(m.StartKey[:0], dAtA[iNdEx:postIndex]...)
			if m.StartKey == nil {
				m.StartKey = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Limit", wireType)
			}
			m.Limit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPdpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Limit |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EndKey", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPdpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthPdpb
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthPdpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EndKey = append(m.EndKey[:0], dAtA[iNdEx:postIndex]...)
			if m.EndKey == nil {
				m.EndKey = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPdpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPdpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Region) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPdpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Region: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Region: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Region", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPdpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPdpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPdpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Region == nil {
				m.Region = &metapb.Region{}
			}
			if err := m.Region.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Leader", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPdpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPdpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPdpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Leader == nil {
				m.Leader = &metapb.Peer{}
			}
			if err := m.Leader.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DownPeers", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPdpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPdpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPdpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DownPeers = append(m.DownPeers, &PeerStats{})
			if err := m.DownPeers[len(m.DownPeers)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PendingPeers", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPdpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPdpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPdpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PendingPeers = append(m.PendingPeers, &metapb.Peer{})
			if err := m.PendingPeers[len(m.PendingPeers)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPdpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPdpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ScanRegionsResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPdpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ScanRegionsResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ScanRegionsResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Header", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPdpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPdpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPdpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Header == nil {
				m.Header = &ResponseHeader{}
			}
			if err := m.Header.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RegionMetas", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPdpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPdpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPdpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RegionMetas = append(m.RegionMetas, &metapb.Region{})
			if err := m.RegionMetas[len(m.RegionMetas)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Leaders", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPdpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPdpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPdpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Leaders = append(m.Leaders, &metapb.Peer{})
			if err := m.Leaders[len(m.Leaders)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Regions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPdpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPdpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPdpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Regions = append(m.Regions, &Region{})
			if err := m.Regions[len(m.Regions)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPdpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPdpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetClusterConfigRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPdpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetClusterConfigRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetClusterConfigRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Header", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPdpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPdpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPdpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Header == nil {
				m.Header = &RequestHeader{}
			}
			if err := m.Header.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPdpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPdpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetClusterConfigResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPdpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetClusterConfigResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetClusterConfigResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Header", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPdpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPdpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPdpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Header == nil {
				m.Header = &ResponseHeader{}
			}
			if err := m.Header.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cluster", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPdpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPdpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPdpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Cluster == nil {
				m.Cluster = &metapb.Cluster{}
			}
			if err := m.Cluster.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPdpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPdpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PutClusterConfigRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPdpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PutClusterConfigRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PutClusterConfigRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Header", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPdpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPdpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPdpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Header == nil {
				m.Header = &RequestHeader{}
			}
			if err := m.Header.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cluster", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPdpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPdpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPdpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Cluster == nil {
				m.Cluster = &metapb.Cluster{}
			}
			if err := m.Cluster.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPdpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPdpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PutClusterConfigResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPdpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PutClusterConfigResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PutClusterConfigResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Header", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPdpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPdpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPdpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Header == nil {
				m.Header = &ResponseHeader{}
			}
			if err := m.Header.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPdpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPdpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Member) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPdpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Member: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Member: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPdpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPdpb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPdpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MemberId", wireType)
			}
			m.MemberId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPdpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MemberId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PeerUrls", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPdpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPdpb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPdpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PeerUrls = append(m.PeerUrls, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClientUrls", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPdpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPdpb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPdpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClientUrls = append(m.ClientUrls, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LeaderPriority", wireType)
			}
			m.LeaderPriority = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPdpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LeaderPriority |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeployPath", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPdpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPdpb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPdpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DeployPath = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BinaryVersion", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPdpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPdpb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPdpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BinaryVersion = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GitHash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPdpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPdpb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPdpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GitHash = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DcLocation", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPdpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPdpb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPdpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DcLocation = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPdpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPdpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetMembersRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPdpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetMembersRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetMembersRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Header", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPdpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPdpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPdpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Header == nil {
				m.Header = &RequestHeader{}
			}
			if err := m.Header.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPdpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPdpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetMembersResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPdpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetMembersResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetMembersResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Header", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPdpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPdpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPdpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Header == nil {
				m.Header = &ResponseHeader{}
			}
			if err := m.Header.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Members", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPdpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPdpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPdpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Members = append(m.Members, &Member{})
			if err := m.Members[len(m.Members)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Leader", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPdpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPdpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPdpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Leader == nil {
				m.Leader = &Member{}
			}
			if err := m.Leader.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EtcdLeader", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPdpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPdpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPdpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.EtcdLeader == nil {
				m.EtcdLeader = &Member{}
			}
			if err := m.EtcdLeader.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TsoAllocatorLeaders", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPdpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPdpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPdpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TsoAllocatorLeaders == nil {
				m.TsoAllocatorLeaders = make(map[string]*Member)
			}
			var mapkey string
			var mapvalue *Member
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPdpb
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPdpb
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthPdpb
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthPdpb
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPdpb
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthPdpb
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthPdpb
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &Member{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipPdpb(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthPdpb
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.TsoAllocatorLeaders[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPdpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPdpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetClusterInfoRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPdpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetClusterInfoRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetClusterInfoRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Header", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPdpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPdpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPdpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Header == nil {
				m.Header = &ResponseHeader{}
			}
			if err := m.Header.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPdpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPdpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetClusterInfoResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPdpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetClusterInfoResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetClusterInfoResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Header", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPdpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPdpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPdpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Header == nil {
				m.Header = &ResponseHeader{}
			}
			if err := m.Header.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType == 0 {
				var v ServiceMode
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPdpb
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= ServiceMode(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.ServiceModes = append(m.ServiceModes, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPdpb
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthPdpb
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthPdpb
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				if elementCount != 0 && len(m.ServiceModes) == 0 {
					m.ServiceModes = make([]ServiceMode, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v ServiceMode
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPdpb
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= ServiceMode(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.ServiceModes = append(m.ServiceModes, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field ServiceModes", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPdpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPdpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PeerStats) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPdpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PeerStats: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PeerStats: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Peer", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPdpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPdpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPdpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Peer == nil {
				m.Peer = &metapb.Peer{}
			}
			if err := m.Peer.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DownSeconds", wireType)
			}
			m.DownSeconds = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPdpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DownSeconds |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPdpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPdpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RegionHeartbeatRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPdpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RegionHeartbeatRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RegionHeartbeatRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Header", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPdpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPdpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPdpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Header == nil {
				m.Header = &RequestHeader{}
			}
			if err := m.Header.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Region", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPdpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPdpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPdpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Region == nil {
				m.Region = &metapb.Region{}
			}
			if err := m.Region.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Leader", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPdpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPdpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPdpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Leader == nil {
				m.Leader = &metapb.Peer{}
			}
			if err := m.Leader.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DownPeers", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPdpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPdpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPdpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DownPeers = append(m.DownPeers, &PeerStats{})
			if err := m.DownPeers[len(m.DownPeers)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PendingPeers", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPdpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPdpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPdpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PendingPeers = append(m.PendingPeers, &metapb.Peer{})
			if err := m.PendingPeers[len(m.PendingPeers)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BytesWritten", wireType)
			}
			m.BytesWritten = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPdpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BytesWritten |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BytesRead", wireType)
			}
			m.BytesRead = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPdpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BytesRead |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeysWritten", wireType)
			}
			m.KeysWritten = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPdpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.KeysWritten |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeysRead", wireType)
			}
			m.KeysRead = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPdpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.KeysRead |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApproximateSize", wireType)
			}
			m.ApproximateSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPdpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ApproximateSize |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Interval", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPdpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPdpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPdpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Interval == nil {
				m.Interval = &TimeInterval{}
			}
			if err := m.Interval.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApproximateKeys", wireType)
			}
			m.ApproximateKeys = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPdpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ApproximateKeys |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Term", wireType)
			}
			m.Term = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPdpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Term |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReplicationStatus", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPdpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPdpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPdpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ReplicationStatus == nil {
				m.ReplicationStatus = &replication_modepb.RegionReplicationStatus{}
			}
			if err := m.ReplicationStatus.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field QueryStats", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPdpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPdpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPdpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.QueryStats == nil {
				m.QueryStats = &QueryStats{}
			}
			if err := m.QueryStats.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 17:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CpuUsage", wireType)
			}
			m.CpuUsage = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPdpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CpuUsage |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 18:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApproximateKvSize", wireType)
			}
			m.ApproximateKvSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPdpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ApproximateKvSize |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPdpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPdpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ChangePeer) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPdpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ChangePeer: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ChangePeer: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Peer", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPdpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPdpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPdpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Peer == nil {
				m.Peer = &metapb.Peer{}
			}
			if err := m.Peer.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChangeType", wireType)
			}
			m.ChangeType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPdpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ChangeType |= eraftpb.ConfChangeType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPdpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPdpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ChangePeerV2) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPdpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ChangePeerV2: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ChangePeerV2: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Changes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPdpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPdpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPdpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Changes = append(m.Changes, &ChangePeer{})
			if err := m.Changes[len(m.Changes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPdpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPdpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TransferLeader) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPdpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TransferLeader: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TransferLeader: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Peer", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPdpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPdpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPdpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Peer == nil {
				m.Peer = &metapb.Peer{}
			}
			if err := m.Peer.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Peers", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPdpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPdpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPdpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Peers = append(m.Peers, &metapb.Peer{})
			if err := m.Peers[len(m.Peers)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPdpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPdpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Merge) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPdpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Merge: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Merge: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Target", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPdpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPdpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPdpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Target == nil {
				m.Target = &metapb.Region{}
			}
			if err := m.Target.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPdpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPdpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SplitRegion) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPdpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SplitRegion: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SplitRegion: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Policy", wireType)
			}
			m.Policy = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPdpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Policy |= CheckPolicy(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Keys", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPdpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthPdpb
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthPdpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Keys = append(m.Keys, make([]byte, postIndex-iNdEx))
			copy(m.Keys[len(m.Keys)-1], dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPdpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPdpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SwitchWitness) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPdpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SwitchWitness: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SwitchWitness: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PeerId", wireType)
			}
			m.PeerId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPdpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PeerId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsWitness", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPdpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsWitness = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipPdpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPdpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BatchSwitchWitness) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPdpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BatchSwitchWitness: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BatchSwitchWitness: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SwitchWitnesses", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPdpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPdpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPdpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SwitchWitnesses = append(m.SwitchWitnesses, &SwitchWitness{})
			if err := m.SwitchWitnesses[len(m.SwitchWitnesses)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPdpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPdpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RegionHeartbeatResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPdpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RegionHeartbeatResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RegionHeartbeatResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Header", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPdpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPdpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPdpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Header == nil {
				m.Header = &ResponseHeader{}
			}
			if err := m.Header.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChangePeer", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPdpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPdpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPdpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ChangePeer == nil {
				m.ChangePeer = &ChangePeer{}
			}
			if err := m.ChangePeer.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TransferLeader", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPdpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPdpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPdpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TransferLeader == nil {
				m.TransferLeader = &TransferLeader{}
			}
			if err := m.TransferLeader.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RegionId", wireType)
			}
			m.RegionId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPdpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RegionId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RegionEpoch", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPdpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPdpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPdpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RegionEpoch == nil {
				m.RegionEpoch = &metapb.RegionEpoch{}
			}
			if err := m.RegionEpoch.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TargetPeer", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPdpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPdpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPdpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TargetPeer == nil {
				m.TargetPeer = &metapb.Peer{}
			}
			if err := m.TargetPeer.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Merge", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPdpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPdpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPdpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Merge == nil {
				m.Merge = &Merge{}
			}
			if err := m.Merge.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SplitRegion", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPdpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPdpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPdpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SplitRegion == nil {
				m.SplitRegion = &SplitRegion{}
			}
			if err := m.SplitRegion.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChangePeerV2", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPdpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPdpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPdpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ChangePeerV2 == nil {
				m.ChangePeerV2 = &ChangePeerV2{}
			}
			if err := m.ChangePeerV2.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SwitchWitnesses", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPdpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPdpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPdpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SwitchWitnesses == nil {
				m.SwitchWitnesses = &BatchSwitchWitness{}
			}
			if err := m.SwitchWitnesses.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPdpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPdpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AskSplitRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPdpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AskSplitRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AskSplitRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Header", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPdpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPdpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPdpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Header == nil {
				m.Header = &RequestHeader{}
			}
			if err := m.Header.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Region", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPdpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPdpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPdpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Region == nil {
				m.Region = &metapb.Region{}
			}
			if err := m.Region.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPdpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPdpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AskSplitResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPdpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AskSplitResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AskSplitResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Header", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPdpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPdpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPdpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Header == nil {
				m.Header = &ResponseHeader{}
			}
			if err := m.Header.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NewRegionId", wireType)
			}
			m.NewRegionId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPdpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NewRegionId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType == 0 {
				var v uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPdpb
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.NewPeerIds = append(m.NewPeerIds, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPdpb
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthPdpb
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthPdpb
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.NewPeerIds) == 0 {
					m.NewPeerIds = make([]uint64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPdpb
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.NewPeerIds = append(m.NewPeerIds, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field NewPeerIds", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPdpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPdpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReportSplitRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPdpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReportSplitRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReportSplitRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Header", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPdpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPdpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPdpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Header == nil {
				m.Header = &RequestHeader{}
			}
			if err := m.Header.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Left", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPdpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPdpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPdpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Left == nil {
				m.Left = &metapb.Region{}
			}
			if err := m.Left.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Right", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPdpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPdpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPdpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Right == nil {
				m.Right = &metapb.Region{}
			}
			if err := m.Right.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPdpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPdpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReportSplitResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPdpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReportSplitResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReportSplitResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Header", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPdpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPdpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPdpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Header == nil {
				m.Header = &ResponseHeader{}
			}
			if err := m.Header.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPdpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPdpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AskBatchSplitRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPdpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AskBatchSplitRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AskBatchSplitRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Header", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPdpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPdpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPdpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Header == nil {
				m.Header = &RequestHeader{}
			}
			if err := m.Header.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Region", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPdpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPdpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPdpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Region == nil {
				m.Region = &metapb.Region{}
			}
			if err := m.Region.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SplitCount", wireType)
			}
			m.SplitCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPdpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SplitCount |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPdpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPdpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SplitID) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPdpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SplitID: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SplitID: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NewRegionId", wireType)
			}
			m.NewRegionId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPdpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NewRegionId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType == 0 {
				var v uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPdpb
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.NewPeerIds = append(m.NewPeerIds, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPdpb
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthPdpb
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthPdpb
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.NewPeerIds) == 0 {
					m.NewPeerIds = make([]uint64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPdpb
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.NewPeerIds = append(m.NewPeerIds, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field NewPeerIds", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPdpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPdpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AskBatchSplitResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPdpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AskBatchSplitResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AskBatchSplitResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Header", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPdpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPdpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPdpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Header == nil {
				m.Header = &ResponseHeader{}
			}
			if err := m.Header.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ids", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPdpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPdpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPdpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ids = append(m.Ids, &SplitID{})
			if err := m.Ids[len(m.Ids)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPdpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPdpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReportBatchSplitRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPdpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReportBatchSplitRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReportBatchSplitRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Header", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPdpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPdpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPdpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Header == nil {
				m.Header = &RequestHeader{}
			}
			if err := m.Header.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Regions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPdpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPdpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPdpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Regions = append(m.Regions, &metapb.Region{})
			if err := m.Regions[len(m.Regions)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPdpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPdpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReportBatchSplitResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPdpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReportBatchSplitResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReportBatchSplitResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Header", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPdpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPdpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPdpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Header == nil {
				m.Header = &ResponseHeader{}
			}
			if err := m.Header.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPdpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPdpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TimeInterval) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPdpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TimeInterval: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TimeInterval: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartTimestamp", wireType)
			}
			m.StartTimestamp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPdpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StartTimestamp |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EndTimestamp", wireType)
			}
			m.EndTimestamp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPdpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EndTimestamp |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPdpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPdpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RecordPair) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPdpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RecordPair: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RecordPair: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPdpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPdpb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPdpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Key = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			m.Value = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPdpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Value |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPdpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPdpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PeerStat) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPdpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PeerStat: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PeerStat: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RegionId", wireType)
			}
			m.RegionId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPdpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RegionId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReadKeys", wireType)
			}
			m.ReadKeys = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPdpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ReadKeys |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReadBytes", wireType)
			}
			m.ReadBytes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPdpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ReadBytes |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field QueryStats", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPdpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPdpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPdpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.QueryStats == nil {
				m.QueryStats = &QueryStats{}
			}
			if err := m.QueryStats.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WrittenKeys", wireType)
			}
			m.WrittenKeys = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPdpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.WrittenKeys |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WrittenBytes", wireType)
			}
			m.WrittenBytes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPdpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.WrittenBytes |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPdpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPdpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StoreStats) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPdpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StoreStats: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StoreStats: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StoreId", wireType)
			}
			m.StoreId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPdpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StoreId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Capacity", wireType)
			}
			m.Capacity = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPdpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Capacity |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Available", wireType)
			}
			m.Available = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPdpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Available |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RegionCount", wireType)
			}
			m.RegionCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPdpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RegionCount |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SendingSnapCount", wireType)
			}
			m.SendingSnapCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPdpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SendingSnapCount |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReceivingSnapCount", wireType)
			}
			m.ReceivingSnapCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPdpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ReceivingSnapCount |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartTime", wireType)
			}
			m.StartTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPdpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StartTime |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApplyingSnapCount", wireType)
			}
			m.ApplyingSnapCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPdpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ApplyingSnapCount |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsBusy", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPdpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsBusy = bool(v != 0)
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UsedSize", wireType)
			}
			m.UsedSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPdpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UsedSize |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BytesWritten", wireType)
			}
			m.BytesWritten = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPdpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BytesWritten |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeysWritten", wireType)
			}
			m.KeysWritten = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPdpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.KeysWritten |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BytesRead", wireType)
			}
			m.BytesRead = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPdpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BytesRead |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeysRead", wireType)
			}
			m.KeysRead = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPdpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.KeysRead |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Interval", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPdpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPdpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPdpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Interval == nil {
				m.Interval = &TimeInterval{}
			}
			if err := m.Interval.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CpuUsages", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPdpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPdpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPdpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CpuUsages = append(m.CpuUsages, &RecordPair{})
			if err := m.CpuUsages[len(m.CpuUsages)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 17:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReadIoRates", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPdpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPdpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPdpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ReadIoRates = append(m.ReadIoRates, &RecordPair{})
			if err := m.ReadIoRates[len(m.ReadIoRates)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 18:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field WriteIoRates", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPdpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPdpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPdpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.WriteIoRates = append(m.WriteIoRates, &RecordPair{})
			if err := m.WriteIoRates[len(m.WriteIoRates)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 19:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OpLatencies", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPdpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPdpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPdpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OpLatencies = append(m.OpLatencies, &RecordPair{})
			if err := m.OpLatencies[len(m.OpLatencies)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 20:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PeerStats", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPdpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPdpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPdpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PeerStats = append(m.PeerStats, &PeerStat{})
			if err := m.PeerStats[len(m.PeerStats)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 21:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field QueryStats", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPdpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPdpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPdpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.QueryStats == nil {
				m.QueryStats = &QueryStats{}
			}
			if err := m.QueryStats.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 22:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SlowScore", wireType)
			}
			m.SlowScore = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPdpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SlowScore |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 23:
			if wireType == 0 {
				var v uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPdpb
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.DamagedRegionsId = append(m.DamagedRegionsId, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPdpb
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthPdpb
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthPdpb
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.DamagedRegionsId) == 0 {
					m.DamagedRegionsId = make([]uint64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPdpb
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.DamagedRegionsId = append(m.DamagedRegionsId, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field DamagedRegionsId", wireType)
			}
		case 24:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsApplyBusy", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPdpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsApplyBusy = bool(v != 0)
		case 25:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SnapshotStats", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPdpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPdpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPdpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SnapshotStats = append(m.SnapshotStats, &SnapshotStat{})
			if err := m.SnapshotStats[len(m.SnapshotStats)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 26:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SlowTrend", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPdpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPdpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPdpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SlowTrend == nil {
				m.SlowTrend = &SlowTrend{}
			}
			if err := m.SlowTrend.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPdpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPdpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SlowTrend) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPdpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SlowTrend: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SlowTrend: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field CauseValue", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.CauseValue = float64(math.Float64frombits(v))
		case 2:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field CauseRate", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.CauseRate = float64(math.Float64frombits(v))
		case 3:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResultValue", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.ResultValue = float64(math.Float64frombits(v))
		case 4:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResultRate", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.ResultRate = float64(math.Float64frombits(v))
		default:
			iNdEx = preIndex
			skippy, err := skipPdpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPdpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SnapshotStat) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPdpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SnapshotStat: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SnapshotStat: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RegionId", wireType)
			}
			m.RegionId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPdpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RegionId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GenerateDurationSec", wireType)
			}
			m.GenerateDurationSec = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPdpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GenerateDurationSec |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SendDurationSec", wireType)
			}
			m.SendDurationSec = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPdpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SendDurationSec |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalDurationSec", wireType)
			}
			m.TotalDurationSec = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPdpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TotalDurationSec |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TransportSize", wireType)
			}
			m.TransportSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPdpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TransportSize |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPdpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPdpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PeerReport) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPdpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PeerReport: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PeerReport: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RaftState", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPdpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPdpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPdpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RaftState == nil {
				m.RaftState = &raft_serverpb.RaftLocalState{}
			}
			if err := m.RaftState.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RegionState", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPdpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPdpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPdpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RegionState == nil {
				m.RegionState = &raft_serverpb.RegionLocalState{}
			}
			if err := m.RegionState.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsForceLeader", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPdpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsForceLeader = bool(v != 0)
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HasCommitMerge", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPdpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.HasCommitMerge = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipPdpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPdpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StoreReport) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPdpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StoreReport: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StoreReport: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PeerReports", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPdpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPdpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPdpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PeerReports = append(m.PeerReports, &PeerReport{})
			if err := m.PeerReports[len(m.PeerReports)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Step", wireType)
			}
			m.Step = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPdpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Step |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPdpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPdpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StoreHeartbeatRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPdpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StoreHeartbeatRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StoreHeartbeatRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Header", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPdpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPdpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPdpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Header == nil {
				m.Header = &RequestHeader{}
			}
			if err := m.Header.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Stats", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPdpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPdpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPdpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Stats == nil {
				m.Stats = &StoreStats{}
			}
			if err := m.Stats.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StoreReport", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPdpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPdpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPdpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.StoreReport == nil {
				m.StoreReport = &StoreReport{}
			}
			if err := m.StoreReport.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DrAutosyncStatus", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPdpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPdpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPdpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DrAutosyncStatus == nil {
				m.DrAutosyncStatus = &replication_modepb.StoreDRAutoSyncStatus{}
			}
			if err := m.DrAutosyncStatus.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPdpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPdpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DemoteFailedVoters) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPdpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DemoteFailedVoters: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DemoteFailedVoters: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RegionId", wireType)
			}
			m.RegionId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPdpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RegionId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FailedVoters", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPdpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPdpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPdpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FailedVoters = append(m.FailedVoters, &metapb.Peer{})
			if err := m.FailedVoters[len(m.FailedVoters)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPdpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPdpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ForceLeader) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPdpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ForceLeader: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ForceLeader: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPdpb
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.FailedStores = append(m.FailedStores, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPdpb
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthPdpb
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthPdpb
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.FailedStores) == 0 {
					m.FailedStores = make([]uint64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPdpb
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.FailedStores = append(m.FailedStores, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field FailedStores", wireType)
			}
		case 2:
			if wireType == 0 {
				var v uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPdpb
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.EnterForceLeaders = append(m.EnterForceLeaders, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPdpb
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthPdpb
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthPdpb
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.EnterForceLeaders) == 0 {
					m.EnterForceLeaders = make([]uint64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPdpb
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.EnterForceLeaders = append(m.EnterForceLeaders, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field EnterForceLeaders", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPdpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPdpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RecoveryPlan) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPdpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RecoveryPlan: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RecoveryPlan: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Creates", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPdpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPdpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPdpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Creates = append(m.Creates, &metapb.Region{})
			if err := m.Creates[len(m.Creates)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Updates", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPdpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPdpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPdpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Updates = append(m.Updates, &metapb.Region{})
			if err := m.Updates[len(m.Updates)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType == 0 {
				var v uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPdpb
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Tombstones = append(m.Tombstones, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPdpb
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthPdpb
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthPdpb
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.Tombstones) == 0 {
					m.Tombstones = make([]uint64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPdpb
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Tombstones = append(m.Tombstones, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Tombstones", wireType)
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Demotes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPdpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPdpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPdpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Demotes = append(m.Demotes, &DemoteFailedVoters{})
			if err := m.Demotes[len(m.Demotes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ForceLeader", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPdpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPdpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPdpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ForceLeader == nil {
				m.ForceLeader = &ForceLeader{}
			}
			if err := m.ForceLeader.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Step", wireType)
			}
			m.Step = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPdpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Step |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPdpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPdpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AwakenRegions) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPdpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AwakenRegions: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AwakenRegions: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPdpb
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.AbnormalStores = append(m.AbnormalStores, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPdpb
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthPdpb
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthPdpb
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.AbnormalStores) == 0 {
					m.AbnormalStores = make([]uint64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPdpb
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.AbnormalStores = append(m.AbnormalStores, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field AbnormalStores", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPdpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPdpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StoreHeartbeatResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPdpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StoreHeartbeatResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StoreHeartbeatResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Header", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPdpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPdpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPdpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Header == nil {
				m.Header = &ResponseHeader{}
			}
			if err := m.Header.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReplicationStatus", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPdpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPdpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPdpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ReplicationStatus == nil {
				m.ReplicationStatus = &replication_modepb.ReplicationStatus{}
			}
			if err := m.ReplicationStatus.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClusterVersion", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPdpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPdpb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPdpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClusterVersion = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequireDetailedReport", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPdpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.RequireDetailedReport = bool(v != 0)
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RecoveryPlan", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPdpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPdpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPdpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RecoveryPlan == nil {
				m.RecoveryPlan = &RecoveryPlan{}
			}
			if err := m.RecoveryPlan.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AwakenRegions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPdpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPdpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPdpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.AwakenRegions == nil {
				m.AwakenRegions = &AwakenRegions{}
			}
			if err := m.AwakenRegions.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPdpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPdpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ScatterRegionRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPdpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ScatterRegionRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ScatterRegionRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Header", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPdpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPdpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPdpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Header == nil {
				m.Header = &RequestHeader{}
			}
			if err := m.Header.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RegionId", wireType)
			}
			m.RegionId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPdpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RegionId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Region", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPdpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPdpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPdpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Region == nil {
				m.Region = &metapb.Region{}
			}
			if err := m.Region.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Leader", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPdpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPdpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPdpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Leader == nil {
				m.Leader = &metapb.Peer{}
			}
			if err := m.Leader.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Group", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPdpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPdpb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPdpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Group = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType == 0 {
				var v uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPdpb
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.RegionsId = append(m.RegionsId, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPdpb
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthPdpb
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthPdpb
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.RegionsId) == 0 {
					m.RegionsId = make([]uint64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPdpb
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.RegionsId = append(m.RegionsId, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field RegionsId", wireType)
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RetryLimit", wireType)
			}
			m.RetryLimit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPdpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RetryLimit |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPdpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPdpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ScatterRegionResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPdpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ScatterRegionResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ScatterRegionResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Header", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPdpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPdpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPdpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Header == nil {
				m.Header = &ResponseHeader{}
			}
			if err := m.Header.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FinishedPercentage", wireType)
			}
			m.FinishedPercentage = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPdpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FinishedPercentage |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPdpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPdpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetGCSafePointRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPdpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetGCSafePointRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetGCSafePointRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Header", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPdpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPdpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPdpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Header == nil {
				m.Header = &RequestHeader{}
			}
			if err := m.Header.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPdpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPdpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetGCSafePointResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPdpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetGCSafePointResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetGCSafePointResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Header", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPdpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPdpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPdpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Header == nil {
				m.Header = &ResponseHeader{}
			}
			if err := m.Header.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SafePoint", wireType)
			}
			m.SafePoint = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPdpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SafePoint |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPdpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPdpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UpdateGCSafePointRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPdpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UpdateGCSafePointRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UpdateGCSafePointRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Header", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPdpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPdpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPdpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Header == nil {
				m.Header = &RequestHeader{}
			}
			if err := m.Header.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SafePoint", wireType)
			}
			m.SafePoint = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPdpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SafePoint |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPdpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPdpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UpdateGCSafePointResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPdpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UpdateGCSafePointResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UpdateGCSafePointResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Header", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPdpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPdpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPdpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Header == nil {
				m.Header = &ResponseHeader{}
			}
			if err := m.Header.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NewSafePoint", wireType)
			}
			m.NewSafePoint = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPdpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NewSafePoint |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPdpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPdpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UpdateServiceGCSafePointRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPdpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UpdateServiceGCSafePointRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UpdateServiceGCSafePointRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Header", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPdpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPdpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPdpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Header == nil {
				m.Header = &RequestHeader{}
			}
			if err := m.Header.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServiceId", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPdpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthPdpb
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthPdpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ServiceId = append(m.ServiceId[:0], dAtA[iNdEx:postIndex]...)
			if m.ServiceId == nil {
				m.ServiceId = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TTL", wireType)
			}
			m.TTL = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPdpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TTL |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SafePoint", wireType)
			}
			m.SafePoint = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPdpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SafePoint |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPdpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPdpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UpdateServiceGCSafePointResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPdpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UpdateServiceGCSafePointResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UpdateServiceGCSafePointResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Header", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPdpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPdpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPdpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Header == nil {
				m.Header = &ResponseHeader{}
			}
			if err := m.Header.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServiceId", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPdpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthPdpb
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthPdpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ServiceId = append(m.ServiceId[:0], dAtA[iNdEx:postIndex]...)
			if m.ServiceId == nil {
				m.ServiceId = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TTL", wireType)
			}
			m.TTL = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPdpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TTL |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinSafePoint", wireType)
			}
			m.MinSafePoint = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPdpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MinSafePoint |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPdpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPdpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RegionStat) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPdpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RegionStat: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RegionStat: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BytesWritten", wireType)
			}
			m.BytesWritten = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPdpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BytesWritten |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BytesRead", wireType)
			}
			m.BytesRead = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPdpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BytesRead |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeysWritten", wireType)
			}
			m.KeysWritten = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPdpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.KeysWritten |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeysRead", wireType)
			}
			m.KeysRead = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPdpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.KeysRead |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPdpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPdpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SyncRegionRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPdpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SyncRegionRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SyncRegionRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Header", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPdpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPdpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPdpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Header == nil {
				m.Header = &RequestHeader{}
			}
			if err := m.Header.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Member", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPdpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPdpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPdpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Member == nil {
				m.Member = &Member{}
			}
			if err := m.Member.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartIndex", wireType)
			}
			m.StartIndex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPdpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StartIndex |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPdpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPdpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SyncRegionResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPdpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SyncRegionResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SyncRegionResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Header", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPdpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPdpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPdpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Header == nil {
				m.Header = &ResponseHeader{}
			}
			if err := m.Header.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Regions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPdpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPdpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPdpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Regions = append(m.Regions, &metapb.Region{})
			if err := m.Regions[len(m.Regions)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartIndex", wireType)
			}
			m.StartIndex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPdpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StartIndex |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RegionStats", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPdpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPdpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPdpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RegionStats = append(m.RegionStats, &RegionStat{})
			if err := m.RegionStats[len(m.RegionStats)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RegionLeaders", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPdpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPdpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPdpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RegionLeaders = append(m.RegionLeaders, &metapb.Peer{})
			if err := m.RegionLeaders[len(m.RegionLeaders)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Buckets", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPdpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPdpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPdpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Buckets = append(m.Buckets, &metapb.Buckets{})
			if err := m.Buckets[len(m.Buckets)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPdpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPdpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetOperatorRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPdpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetOperatorRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetOperatorRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Header", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPdpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPdpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPdpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Header == nil {
				m.Header = &RequestHeader{}
			}
			if err := m.Header.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RegionId", wireType)
			}
			m.RegionId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPdpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RegionId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPdpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPdpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetOperatorResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPdpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetOperatorResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetOperatorResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Header", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPdpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPdpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPdpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Header == nil {
				m.Header = &ResponseHeader{}
			}
			if err := m.Header.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RegionId", wireType)
			}
			m.RegionId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPdpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RegionId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Desc", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPdpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthPdpb
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthPdpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Desc = append(m.Desc[:0], dAtA[iNdEx:postIndex]...)
			if m.Desc == nil {
				m.Desc = []byte{}
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPdpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= OperatorStatus(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Kind", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPdpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthPdpb
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthPdpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Kind = append(m.Kind[:0], dAtA[iNdEx:postIndex]...)
			if m.Kind == nil {
				m.Kind = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPdpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPdpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SyncMaxTSRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPdpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SyncMaxTSRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SyncMaxTSRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Header", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPdpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPdpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPdpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Header == nil {
				m.Header = &RequestHeader{}
			}
			if err := m.Header.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxTs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPdpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPdpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPdpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MaxTs == nil {
				m.MaxTs = &Timestamp{}
			}
			if err := m.MaxTs.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SkipCheck", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPdpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.SkipCheck = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipPdpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPdpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SyncMaxTSResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPdpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SyncMaxTSResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SyncMaxTSResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Header", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPdpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPdpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPdpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Header == nil {
				m.Header = &ResponseHeader{}
			}
			if err := m.Header.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxLocalTs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPdpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPdpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPdpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MaxLocalTs == nil {
				m.MaxLocalTs = &Timestamp{}
			}
			if err := m.MaxLocalTs.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SyncedDcs", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPdpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPdpb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPdpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SyncedDcs = append(m.SyncedDcs, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPdpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPdpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SplitRegionsRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPdpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SplitRegionsRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SplitRegionsRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Header", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPdpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPdpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPdpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Header == nil {
				m.Header = &RequestHeader{}
			}
			if err := m.Header.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SplitKeys", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPdpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthPdpb
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthPdpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SplitKeys = append(m.SplitKeys, make([]byte, postIndex-iNdEx))
			copy(m.SplitKeys[len(m.SplitKeys)-1], dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RetryLimit", wireType)
			}
			m.RetryLimit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPdpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RetryLimit |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPdpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPdpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SplitRegionsResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPdpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SplitRegionsResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SplitRegionsResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Header", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPdpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPdpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPdpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Header == nil {
				m.Header = &ResponseHeader{}
			}
			if err := m.Header.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FinishedPercentage", wireType)
			}
			m.FinishedPercentage = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPdpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FinishedPercentage |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType == 0 {
				var v uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPdpb
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.RegionsId = append(m.RegionsId, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPdpb
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthPdpb
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthPdpb
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.RegionsId) == 0 {
					m.RegionsId = make([]uint64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPdpb
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.RegionsId = append(m.RegionsId, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field RegionsId", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPdpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPdpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SplitAndScatterRegionsRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPdpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SplitAndScatterRegionsRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SplitAndScatterRegionsRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Header", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPdpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPdpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPdpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Header == nil {
				m.Header = &RequestHeader{}
			}
			if err := m.Header.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SplitKeys", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPdpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthPdpb
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthPdpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SplitKeys = append(m.SplitKeys, make([]byte, postIndex-iNdEx))
			copy(m.SplitKeys[len(m.SplitKeys)-1], dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Group", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPdpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPdpb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPdpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Group = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RetryLimit", wireType)
			}
			m.RetryLimit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPdpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RetryLimit |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPdpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPdpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SplitAndScatterRegionsResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPdpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SplitAndScatterRegionsResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SplitAndScatterRegionsResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Header", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPdpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPdpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPdpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Header == nil {
				m.Header = &ResponseHeader{}
			}
			if err := m.Header.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SplitFinishedPercentage", wireType)
			}
			m.SplitFinishedPercentage = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPdpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SplitFinishedPercentage |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ScatterFinishedPercentage", wireType)
			}
			m.ScatterFinishedPercentage = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPdpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ScatterFinishedPercentage |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType == 0 {
				var v uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPdpb
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.RegionsId = append(m.RegionsId, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPdpb
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthPdpb
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthPdpb
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.RegionsId) == 0 {
					m.RegionsId = make([]uint64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPdpb
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.RegionsId = append(m.RegionsId, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field RegionsId", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPdpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPdpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetDCLocationInfoRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPdpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetDCLocationInfoRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetDCLocationInfoRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Header", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPdpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPdpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPdpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Header == nil {
				m.Header = &RequestHeader{}
			}
			if err := m.Header.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DcLocation", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPdpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPdpb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPdpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DcLocation = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPdpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPdpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetDCLocationInfoResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPdpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetDCLocationInfoResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetDCLocationInfoResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Header", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPdpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPdpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPdpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Header == nil {
				m.Header = &ResponseHeader{}
			}
			if err := m.Header.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Suffix", wireType)
			}
			m.Suffix = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPdpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Suffix |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxTs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPdpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPdpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPdpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MaxTs == nil {
				m.MaxTs = &Timestamp{}
			}
			if err := m.MaxTs.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPdpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPdpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueryStats) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPdpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueryStats: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueryStats: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GC", wireType)
			}
			m.GC = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPdpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GC |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Get", wireType)
			}
			m.Get = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPdpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Get |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Scan", wireType)
			}
			m.Scan = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPdpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Scan |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Coprocessor", wireType)
			}
			m.Coprocessor = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPdpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Coprocessor |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Delete", wireType)
			}
			m.Delete = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPdpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Delete |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeleteRange", wireType)
			}
			m.DeleteRange = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPdpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DeleteRange |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Put", wireType)
			}
			m.Put = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPdpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Put |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Prewrite", wireType)
			}
			m.Prewrite = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPdpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Prewrite |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AcquirePessimisticLock", wireType)
			}
			m.AcquirePessimisticLock = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPdpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AcquirePessimisticLock |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Commit", wireType)
			}
			m.Commit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPdpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Commit |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rollback", wireType)
			}
			m.Rollback = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPdpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Rollback |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPdpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPdpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReportBucketsRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPdpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReportBucketsRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReportBucketsRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Header", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPdpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPdpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPdpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Header == nil {
				m.Header = &RequestHeader{}
			}
			if err := m.Header.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RegionEpoch", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPdpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPdpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPdpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RegionEpoch == nil {
				m.RegionEpoch = &metapb.RegionEpoch{}
			}
			if err := m.RegionEpoch.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Buckets", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPdpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPdpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPdpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Buckets == nil {
				m.Buckets = &metapb.Buckets{}
			}
			if err := m.Buckets.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPdpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPdpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReportBucketsResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPdpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReportBucketsResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReportBucketsResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Header", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPdpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPdpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPdpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Header == nil {
				m.Header = &ResponseHeader{}
			}
			if err := m.Header.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPdpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPdpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReportMinResolvedTsRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPdpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReportMinResolvedTsRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReportMinResolvedTsRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Header", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPdpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPdpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPdpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Header == nil {
				m.Header = &RequestHeader{}
			}
			if err := m.Header.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StoreId", wireType)
			}
			m.StoreId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPdpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StoreId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinResolvedTs", wireType)
			}
			m.MinResolvedTs = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPdpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MinResolvedTs |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPdpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPdpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReportMinResolvedTsResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPdpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReportMinResolvedTsResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReportMinResolvedTsResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Header", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPdpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPdpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPdpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Header == nil {
				m.Header = &ResponseHeader{}
			}
			if err := m.Header.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPdpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPdpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SetExternalTimestampRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPdpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SetExternalTimestampRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SetExternalTimestampRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Header", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPdpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPdpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPdpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Header == nil {
				m.Header = &RequestHeader{}
			}
			if err := m.Header.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			m.Timestamp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPdpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Timestamp |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPdpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPdpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SetExternalTimestampResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPdpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SetExternalTimestampResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SetExternalTimestampResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Header", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPdpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPdpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPdpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Header == nil {
				m.Header = &ResponseHeader{}
			}
			if err := m.Header.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPdpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPdpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetExternalTimestampRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPdpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetExternalTimestampRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetExternalTimestampRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Header", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPdpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPdpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPdpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Header == nil {
				m.Header = &RequestHeader{}
			}
			if err := m.Header.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPdpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPdpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetExternalTimestampResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPdpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetExternalTimestampResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetExternalTimestampResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Header", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPdpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPdpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPdpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Header == nil {
				m.Header = &ResponseHeader{}
			}
			if err := m.Header.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			m.Timestamp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPdpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Timestamp |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPdpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPdpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipPdpb(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowPdpb
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowPdpb
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowPdpb
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthPdpb
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupPdpb
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthPdpb
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthPdpb        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowPdpb          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupPdpb = fmt.Errorf("proto: unexpected end of group")
)
